
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignStatus
 * 
 */
export type CampaignStatus = $Result.DefaultSelection<Prisma.$CampaignStatusPayload>
/**
 * Model CampaignComputedValue
 * 
 */
export type CampaignComputedValue = $Result.DefaultSelection<Prisma.$CampaignComputedValuePayload>
/**
 * Model UserComputedValue
 * 
 */
export type UserComputedValue = $Result.DefaultSelection<Prisma.$UserComputedValuePayload>
/**
 * Model Chain
 * 
 */
export type Chain = $Result.DefaultSelection<Prisma.$ChainPayload>
/**
 * Model Explorer
 * 
 */
export type Explorer = $Result.DefaultSelection<Prisma.$ExplorerPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model Protocol
 * 
 */
export type Protocol = $Result.DefaultSelection<Prisma.$ProtocolPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model AprRecord
 * 
 */
export type AprRecord = $Result.DefaultSelection<Prisma.$AprRecordPayload>
/**
 * Model AprBreakdown
 * 
 */
export type AprBreakdown = $Result.DefaultSelection<Prisma.$AprBreakdownPayload>
/**
 * Model TVLRecord
 * 
 */
export type TVLRecord = $Result.DefaultSelection<Prisma.$TVLRecordPayload>
/**
 * Model TVLBreakdown
 * 
 */
export type TVLBreakdown = $Result.DefaultSelection<Prisma.$TVLBreakdownPayload>
/**
 * Model DailyRewardsRecord
 * 
 */
export type DailyRewardsRecord = $Result.DefaultSelection<Prisma.$DailyRewardsRecordPayload>
/**
 * Model DailyRewardsBreakdown
 * 
 */
export type DailyRewardsBreakdown = $Result.DefaultSelection<Prisma.$DailyRewardsBreakdownPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Creator
 * 
 */
export type Creator = $Result.DefaultSelection<Prisma.$CreatorPayload>
/**
 * Model Reward
 * 
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>
/**
 * Model RewardBreakdown
 * 
 */
export type RewardBreakdown = $Result.DefaultSelection<Prisma.$RewardBreakdownPayload>
/**
 * Model MerklRoot
 * 
 */
export type MerklRoot = $Result.DefaultSelection<Prisma.$MerklRootPayload>
/**
 * Model PriceSource
 * 
 */
export type PriceSource = $Result.DefaultSelection<Prisma.$PriceSourcePayload>
/**
 * Model Blacklist
 * 
 */
export type Blacklist = $Result.DefaultSelection<Prisma.$BlacklistPayload>
/**
 * Model Dump
 * 
 */
export type Dump = $Result.DefaultSelection<Prisma.$DumpPayload>
/**
 * Model Logged
 * 
 */
export type Logged = $Result.DefaultSelection<Prisma.$LoggedPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LoggedEntityType: {
  UNKNOWN: 'UNKNOWN',
  EULER_VAULT: 'EULER_VAULT',
  UNISWAP_V4: 'UNISWAP_V4',
  COMPOUND_v2: 'COMPOUND_v2'
};

export type LoggedEntityType = (typeof LoggedEntityType)[keyof typeof LoggedEntityType]


export const RunStatus: {
  PROCESSING: 'PROCESSING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED'
};

export type RunStatus = (typeof RunStatus)[keyof typeof RunStatus]


export const OpportunityAction: {
  POOL: 'POOL',
  HOLD: 'HOLD',
  DROP: 'DROP',
  LEND: 'LEND',
  BORROW: 'BORROW',
  LONG: 'LONG',
  SHORT: 'SHORT',
  SWAP: 'SWAP',
  INVALID: 'INVALID'
};

export type OpportunityAction = (typeof OpportunityAction)[keyof typeof OpportunityAction]


export const Status: {
  NONE: 'NONE',
  PAST: 'PAST',
  LIVE: 'LIVE',
  SOON: 'SOON'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ExplorerType: {
  ETHERSCAN: 'ETHERSCAN',
  BLOCKSCOUT: 'BLOCKSCOUT'
};

export type ExplorerType = (typeof ExplorerType)[keyof typeof ExplorerType]


export const AprType: {
  CAMPAIGN: 'CAMPAIGN',
  TOKEN: 'TOKEN',
  PROTOCOL: 'PROTOCOL'
};

export type AprType = (typeof AprType)[keyof typeof AprType]


export const TvlType: {
  TOKEN: 'TOKEN',
  PROTOCOL: 'PROTOCOL'
};

export type TvlType = (typeof TvlType)[keyof typeof TvlType]


export const PriceSourceMethod: {
  COINGECKO: 'COINGECKO',
  CONSTANT: 'CONSTANT',
  EQUAL_TO: 'EQUAL_TO',
  ERC4626: 'ERC4626',
  DEXSCREENER: 'DEXSCREENER',
  INDEXCOOP: 'INDEXCOOP',
  DEFILLAMA: 'DEFILLAMA'
};

export type PriceSourceMethod = (typeof PriceSourceMethod)[keyof typeof PriceSourceMethod]


export const CampaignManualOverride: {
  opportunityId: 'opportunityId',
  creatorAddress: 'creatorAddress'
};

export type CampaignManualOverride = (typeof CampaignManualOverride)[keyof typeof CampaignManualOverride]


export const OpportunityManualOverride: {
  name: 'name',
  depositUrl: 'depositUrl',
  explorerAddress: 'explorerAddress',
  action: 'action',
  description: 'description',
  howToSteps: 'howToSteps'
};

export type OpportunityManualOverride = (typeof OpportunityManualOverride)[keyof typeof OpportunityManualOverride]


export const DistributionType: {
  DUTCH_AUCTION: 'DUTCH_AUCTION',
  FIX_REWARD_VALUE_PER_LIQUIDITY_VALUE: 'FIX_REWARD_VALUE_PER_LIQUIDITY_VALUE',
  FIX_REWARD_AMOUNT_PER_LIQUIDITY_VALUE: 'FIX_REWARD_AMOUNT_PER_LIQUIDITY_VALUE',
  FIX_REWARD_VALUE_PER_LIQUIDITY_AMOUNT: 'FIX_REWARD_VALUE_PER_LIQUIDITY_AMOUNT',
  FIX_REWARD_AMOUNT_PER_LIQUIDITY_AMOUNT: 'FIX_REWARD_AMOUNT_PER_LIQUIDITY_AMOUNT'
};

export type DistributionType = (typeof DistributionType)[keyof typeof DistributionType]

}

export type LoggedEntityType = $Enums.LoggedEntityType

export const LoggedEntityType: typeof $Enums.LoggedEntityType

export type RunStatus = $Enums.RunStatus

export const RunStatus: typeof $Enums.RunStatus

export type OpportunityAction = $Enums.OpportunityAction

export const OpportunityAction: typeof $Enums.OpportunityAction

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ExplorerType = $Enums.ExplorerType

export const ExplorerType: typeof $Enums.ExplorerType

export type AprType = $Enums.AprType

export const AprType: typeof $Enums.AprType

export type TvlType = $Enums.TvlType

export const TvlType: typeof $Enums.TvlType

export type PriceSourceMethod = $Enums.PriceSourceMethod

export const PriceSourceMethod: typeof $Enums.PriceSourceMethod

export type CampaignManualOverride = $Enums.CampaignManualOverride

export const CampaignManualOverride: typeof $Enums.CampaignManualOverride

export type OpportunityManualOverride = $Enums.OpportunityManualOverride

export const OpportunityManualOverride: typeof $Enums.OpportunityManualOverride

export type DistributionType = $Enums.DistributionType

export const DistributionType: typeof $Enums.DistributionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Campaigns
 * const campaigns = await prisma.campaign.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Campaigns
   * const campaigns = await prisma.campaign.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignStatus`: Exposes CRUD operations for the **CampaignStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignStatuses
    * const campaignStatuses = await prisma.campaignStatus.findMany()
    * ```
    */
  get campaignStatus(): Prisma.CampaignStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignComputedValue`: Exposes CRUD operations for the **CampaignComputedValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignComputedValues
    * const campaignComputedValues = await prisma.campaignComputedValue.findMany()
    * ```
    */
  get campaignComputedValue(): Prisma.CampaignComputedValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userComputedValue`: Exposes CRUD operations for the **UserComputedValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserComputedValues
    * const userComputedValues = await prisma.userComputedValue.findMany()
    * ```
    */
  get userComputedValue(): Prisma.UserComputedValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chain`: Exposes CRUD operations for the **Chain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chains
    * const chains = await prisma.chain.findMany()
    * ```
    */
  get chain(): Prisma.ChainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.explorer`: Exposes CRUD operations for the **Explorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Explorers
    * const explorers = await prisma.explorer.findMany()
    * ```
    */
  get explorer(): Prisma.ExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.protocol`: Exposes CRUD operations for the **Protocol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Protocols
    * const protocols = await prisma.protocol.findMany()
    * ```
    */
  get protocol(): Prisma.ProtocolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aprRecord`: Exposes CRUD operations for the **AprRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AprRecords
    * const aprRecords = await prisma.aprRecord.findMany()
    * ```
    */
  get aprRecord(): Prisma.AprRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aprBreakdown`: Exposes CRUD operations for the **AprBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AprBreakdowns
    * const aprBreakdowns = await prisma.aprBreakdown.findMany()
    * ```
    */
  get aprBreakdown(): Prisma.AprBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tVLRecord`: Exposes CRUD operations for the **TVLRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TVLRecords
    * const tVLRecords = await prisma.tVLRecord.findMany()
    * ```
    */
  get tVLRecord(): Prisma.TVLRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tVLBreakdown`: Exposes CRUD operations for the **TVLBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TVLBreakdowns
    * const tVLBreakdowns = await prisma.tVLBreakdown.findMany()
    * ```
    */
  get tVLBreakdown(): Prisma.TVLBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyRewardsRecord`: Exposes CRUD operations for the **DailyRewardsRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRewardsRecords
    * const dailyRewardsRecords = await prisma.dailyRewardsRecord.findMany()
    * ```
    */
  get dailyRewardsRecord(): Prisma.DailyRewardsRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyRewardsBreakdown`: Exposes CRUD operations for the **DailyRewardsBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRewardsBreakdowns
    * const dailyRewardsBreakdowns = await prisma.dailyRewardsBreakdown.findMany()
    * ```
    */
  get dailyRewardsBreakdown(): Prisma.DailyRewardsBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creator`: Exposes CRUD operations for the **Creator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creators
    * const creators = await prisma.creator.findMany()
    * ```
    */
  get creator(): Prisma.CreatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardBreakdown`: Exposes CRUD operations for the **RewardBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardBreakdowns
    * const rewardBreakdowns = await prisma.rewardBreakdown.findMany()
    * ```
    */
  get rewardBreakdown(): Prisma.RewardBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merklRoot`: Exposes CRUD operations for the **MerklRoot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerklRoots
    * const merklRoots = await prisma.merklRoot.findMany()
    * ```
    */
  get merklRoot(): Prisma.MerklRootDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceSource`: Exposes CRUD operations for the **PriceSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceSources
    * const priceSources = await prisma.priceSource.findMany()
    * ```
    */
  get priceSource(): Prisma.PriceSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklist`: Exposes CRUD operations for the **Blacklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blacklists
    * const blacklists = await prisma.blacklist.findMany()
    * ```
    */
  get blacklist(): Prisma.BlacklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dump`: Exposes CRUD operations for the **Dump** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dumps
    * const dumps = await prisma.dump.findMany()
    * ```
    */
  get dump(): Prisma.DumpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logged`: Exposes CRUD operations for the **Logged** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loggeds
    * const loggeds = await prisma.logged.findMany()
    * ```
    */
  get logged(): Prisma.LoggedDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Campaign: 'Campaign',
    CampaignStatus: 'CampaignStatus',
    CampaignComputedValue: 'CampaignComputedValue',
    UserComputedValue: 'UserComputedValue',
    Chain: 'Chain',
    Explorer: 'Explorer',
    Opportunity: 'Opportunity',
    Protocol: 'Protocol',
    Token: 'Token',
    AprRecord: 'AprRecord',
    AprBreakdown: 'AprBreakdown',
    TVLRecord: 'TVLRecord',
    TVLBreakdown: 'TVLBreakdown',
    DailyRewardsRecord: 'DailyRewardsRecord',
    DailyRewardsBreakdown: 'DailyRewardsBreakdown',
    User: 'User',
    Creator: 'Creator',
    Reward: 'Reward',
    RewardBreakdown: 'RewardBreakdown',
    MerklRoot: 'MerklRoot',
    PriceSource: 'PriceSource',
    Blacklist: 'Blacklist',
    Dump: 'Dump',
    Logged: 'Logged'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "campaign" | "campaignStatus" | "campaignComputedValue" | "userComputedValue" | "chain" | "explorer" | "opportunity" | "protocol" | "token" | "aprRecord" | "aprBreakdown" | "tVLRecord" | "tVLBreakdown" | "dailyRewardsRecord" | "dailyRewardsBreakdown" | "user" | "creator" | "reward" | "rewardBreakdown" | "merklRoot" | "priceSource" | "blacklist" | "dump" | "logged"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignStatus: {
        payload: Prisma.$CampaignStatusPayload<ExtArgs>
        fields: Prisma.CampaignStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          findFirst: {
            args: Prisma.CampaignStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          findMany: {
            args: Prisma.CampaignStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>[]
          }
          create: {
            args: Prisma.CampaignStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          createMany: {
            args: Prisma.CampaignStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>[]
          }
          delete: {
            args: Prisma.CampaignStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          update: {
            args: Prisma.CampaignStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          deleteMany: {
            args: Prisma.CampaignStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>[]
          }
          upsert: {
            args: Prisma.CampaignStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatusPayload>
          }
          aggregate: {
            args: Prisma.CampaignStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignStatus>
          }
          groupBy: {
            args: Prisma.CampaignStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignStatusCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatusCountAggregateOutputType> | number
          }
        }
      }
      CampaignComputedValue: {
        payload: Prisma.$CampaignComputedValuePayload<ExtArgs>
        fields: Prisma.CampaignComputedValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignComputedValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignComputedValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          findFirst: {
            args: Prisma.CampaignComputedValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignComputedValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          findMany: {
            args: Prisma.CampaignComputedValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>[]
          }
          create: {
            args: Prisma.CampaignComputedValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          createMany: {
            args: Prisma.CampaignComputedValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignComputedValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>[]
          }
          delete: {
            args: Prisma.CampaignComputedValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          update: {
            args: Prisma.CampaignComputedValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          deleteMany: {
            args: Prisma.CampaignComputedValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignComputedValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignComputedValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>[]
          }
          upsert: {
            args: Prisma.CampaignComputedValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignComputedValuePayload>
          }
          aggregate: {
            args: Prisma.CampaignComputedValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignComputedValue>
          }
          groupBy: {
            args: Prisma.CampaignComputedValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignComputedValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignComputedValueCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignComputedValueCountAggregateOutputType> | number
          }
        }
      }
      UserComputedValue: {
        payload: Prisma.$UserComputedValuePayload<ExtArgs>
        fields: Prisma.UserComputedValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserComputedValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserComputedValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          findFirst: {
            args: Prisma.UserComputedValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserComputedValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          findMany: {
            args: Prisma.UserComputedValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>[]
          }
          create: {
            args: Prisma.UserComputedValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          createMany: {
            args: Prisma.UserComputedValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserComputedValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>[]
          }
          delete: {
            args: Prisma.UserComputedValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          update: {
            args: Prisma.UserComputedValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          deleteMany: {
            args: Prisma.UserComputedValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserComputedValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserComputedValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>[]
          }
          upsert: {
            args: Prisma.UserComputedValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserComputedValuePayload>
          }
          aggregate: {
            args: Prisma.UserComputedValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserComputedValue>
          }
          groupBy: {
            args: Prisma.UserComputedValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserComputedValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserComputedValueCountArgs<ExtArgs>
            result: $Utils.Optional<UserComputedValueCountAggregateOutputType> | number
          }
        }
      }
      Chain: {
        payload: Prisma.$ChainPayload<ExtArgs>
        fields: Prisma.ChainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          findFirst: {
            args: Prisma.ChainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          findMany: {
            args: Prisma.ChainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>[]
          }
          create: {
            args: Prisma.ChainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          createMany: {
            args: Prisma.ChainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>[]
          }
          delete: {
            args: Prisma.ChainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          update: {
            args: Prisma.ChainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          deleteMany: {
            args: Prisma.ChainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>[]
          }
          upsert: {
            args: Prisma.ChainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainPayload>
          }
          aggregate: {
            args: Prisma.ChainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChain>
          }
          groupBy: {
            args: Prisma.ChainGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChainGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChainCountArgs<ExtArgs>
            result: $Utils.Optional<ChainCountAggregateOutputType> | number
          }
        }
      }
      Explorer: {
        payload: Prisma.$ExplorerPayload<ExtArgs>
        fields: Prisma.ExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          findFirst: {
            args: Prisma.ExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          findMany: {
            args: Prisma.ExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>[]
          }
          create: {
            args: Prisma.ExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          createMany: {
            args: Prisma.ExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>[]
          }
          delete: {
            args: Prisma.ExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          update: {
            args: Prisma.ExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          deleteMany: {
            args: Prisma.ExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>[]
          }
          upsert: {
            args: Prisma.ExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExplorerPayload>
          }
          aggregate: {
            args: Prisma.ExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExplorer>
          }
          groupBy: {
            args: Prisma.ExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<ExplorerCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      Protocol: {
        payload: Prisma.$ProtocolPayload<ExtArgs>
        fields: Prisma.ProtocolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          findFirst: {
            args: Prisma.ProtocolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          findMany: {
            args: Prisma.ProtocolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>[]
          }
          create: {
            args: Prisma.ProtocolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          createMany: {
            args: Prisma.ProtocolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>[]
          }
          delete: {
            args: Prisma.ProtocolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          update: {
            args: Prisma.ProtocolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          deleteMany: {
            args: Prisma.ProtocolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProtocolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>[]
          }
          upsert: {
            args: Prisma.ProtocolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          aggregate: {
            args: Prisma.ProtocolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocol>
          }
          groupBy: {
            args: Prisma.ProtocolGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      AprRecord: {
        payload: Prisma.$AprRecordPayload<ExtArgs>
        fields: Prisma.AprRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AprRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AprRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          findFirst: {
            args: Prisma.AprRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AprRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          findMany: {
            args: Prisma.AprRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>[]
          }
          create: {
            args: Prisma.AprRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          createMany: {
            args: Prisma.AprRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AprRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>[]
          }
          delete: {
            args: Prisma.AprRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          update: {
            args: Prisma.AprRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          deleteMany: {
            args: Prisma.AprRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AprRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AprRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>[]
          }
          upsert: {
            args: Prisma.AprRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprRecordPayload>
          }
          aggregate: {
            args: Prisma.AprRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAprRecord>
          }
          groupBy: {
            args: Prisma.AprRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AprRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AprRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AprRecordCountAggregateOutputType> | number
          }
        }
      }
      AprBreakdown: {
        payload: Prisma.$AprBreakdownPayload<ExtArgs>
        fields: Prisma.AprBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AprBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AprBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          findFirst: {
            args: Prisma.AprBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AprBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          findMany: {
            args: Prisma.AprBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>[]
          }
          create: {
            args: Prisma.AprBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          createMany: {
            args: Prisma.AprBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AprBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>[]
          }
          delete: {
            args: Prisma.AprBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          update: {
            args: Prisma.AprBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.AprBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AprBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AprBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.AprBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AprBreakdownPayload>
          }
          aggregate: {
            args: Prisma.AprBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAprBreakdown>
          }
          groupBy: {
            args: Prisma.AprBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<AprBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.AprBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<AprBreakdownCountAggregateOutputType> | number
          }
        }
      }
      TVLRecord: {
        payload: Prisma.$TVLRecordPayload<ExtArgs>
        fields: Prisma.TVLRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TVLRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TVLRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          findFirst: {
            args: Prisma.TVLRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TVLRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          findMany: {
            args: Prisma.TVLRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>[]
          }
          create: {
            args: Prisma.TVLRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          createMany: {
            args: Prisma.TVLRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TVLRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>[]
          }
          delete: {
            args: Prisma.TVLRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          update: {
            args: Prisma.TVLRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          deleteMany: {
            args: Prisma.TVLRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TVLRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TVLRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>[]
          }
          upsert: {
            args: Prisma.TVLRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLRecordPayload>
          }
          aggregate: {
            args: Prisma.TVLRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTVLRecord>
          }
          groupBy: {
            args: Prisma.TVLRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TVLRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TVLRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TVLRecordCountAggregateOutputType> | number
          }
        }
      }
      TVLBreakdown: {
        payload: Prisma.$TVLBreakdownPayload<ExtArgs>
        fields: Prisma.TVLBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TVLBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TVLBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          findFirst: {
            args: Prisma.TVLBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TVLBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          findMany: {
            args: Prisma.TVLBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>[]
          }
          create: {
            args: Prisma.TVLBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          createMany: {
            args: Prisma.TVLBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TVLBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>[]
          }
          delete: {
            args: Prisma.TVLBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          update: {
            args: Prisma.TVLBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.TVLBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TVLBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TVLBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.TVLBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVLBreakdownPayload>
          }
          aggregate: {
            args: Prisma.TVLBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTVLBreakdown>
          }
          groupBy: {
            args: Prisma.TVLBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<TVLBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.TVLBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<TVLBreakdownCountAggregateOutputType> | number
          }
        }
      }
      DailyRewardsRecord: {
        payload: Prisma.$DailyRewardsRecordPayload<ExtArgs>
        fields: Prisma.DailyRewardsRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRewardsRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRewardsRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          findFirst: {
            args: Prisma.DailyRewardsRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRewardsRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          findMany: {
            args: Prisma.DailyRewardsRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>[]
          }
          create: {
            args: Prisma.DailyRewardsRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          createMany: {
            args: Prisma.DailyRewardsRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRewardsRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>[]
          }
          delete: {
            args: Prisma.DailyRewardsRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          update: {
            args: Prisma.DailyRewardsRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          deleteMany: {
            args: Prisma.DailyRewardsRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRewardsRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyRewardsRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>[]
          }
          upsert: {
            args: Prisma.DailyRewardsRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsRecordPayload>
          }
          aggregate: {
            args: Prisma.DailyRewardsRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRewardsRecord>
          }
          groupBy: {
            args: Prisma.DailyRewardsRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardsRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRewardsRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardsRecordCountAggregateOutputType> | number
          }
        }
      }
      DailyRewardsBreakdown: {
        payload: Prisma.$DailyRewardsBreakdownPayload<ExtArgs>
        fields: Prisma.DailyRewardsBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRewardsBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRewardsBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          findFirst: {
            args: Prisma.DailyRewardsBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRewardsBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          findMany: {
            args: Prisma.DailyRewardsBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>[]
          }
          create: {
            args: Prisma.DailyRewardsBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          createMany: {
            args: Prisma.DailyRewardsBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRewardsBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>[]
          }
          delete: {
            args: Prisma.DailyRewardsBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          update: {
            args: Prisma.DailyRewardsBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.DailyRewardsBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRewardsBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyRewardsBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.DailyRewardsBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRewardsBreakdownPayload>
          }
          aggregate: {
            args: Prisma.DailyRewardsBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRewardsBreakdown>
          }
          groupBy: {
            args: Prisma.DailyRewardsBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardsBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRewardsBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRewardsBreakdownCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Creator: {
        payload: Prisma.$CreatorPayload<ExtArgs>
        fields: Prisma.CreatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findFirst: {
            args: Prisma.CreatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          findMany: {
            args: Prisma.CreatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          create: {
            args: Prisma.CreatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          createMany: {
            args: Prisma.CreatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          delete: {
            args: Prisma.CreatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          update: {
            args: Prisma.CreatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          deleteMany: {
            args: Prisma.CreatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>[]
          }
          upsert: {
            args: Prisma.CreatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatorPayload>
          }
          aggregate: {
            args: Prisma.CreatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreator>
          }
          groupBy: {
            args: Prisma.CreatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatorCountArgs<ExtArgs>
            result: $Utils.Optional<CreatorCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>
        fields: Prisma.RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      RewardBreakdown: {
        payload: Prisma.$RewardBreakdownPayload<ExtArgs>
        fields: Prisma.RewardBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          findFirst: {
            args: Prisma.RewardBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          findMany: {
            args: Prisma.RewardBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>[]
          }
          create: {
            args: Prisma.RewardBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          createMany: {
            args: Prisma.RewardBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>[]
          }
          delete: {
            args: Prisma.RewardBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          update: {
            args: Prisma.RewardBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.RewardBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.RewardBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardBreakdownPayload>
          }
          aggregate: {
            args: Prisma.RewardBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardBreakdown>
          }
          groupBy: {
            args: Prisma.RewardBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<RewardBreakdownCountAggregateOutputType> | number
          }
        }
      }
      MerklRoot: {
        payload: Prisma.$MerklRootPayload<ExtArgs>
        fields: Prisma.MerklRootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerklRootFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerklRootFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          findFirst: {
            args: Prisma.MerklRootFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerklRootFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          findMany: {
            args: Prisma.MerklRootFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>[]
          }
          create: {
            args: Prisma.MerklRootCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          createMany: {
            args: Prisma.MerklRootCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerklRootCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>[]
          }
          delete: {
            args: Prisma.MerklRootDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          update: {
            args: Prisma.MerklRootUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          deleteMany: {
            args: Prisma.MerklRootDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerklRootUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerklRootUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>[]
          }
          upsert: {
            args: Prisma.MerklRootUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerklRootPayload>
          }
          aggregate: {
            args: Prisma.MerklRootAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerklRoot>
          }
          groupBy: {
            args: Prisma.MerklRootGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerklRootGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerklRootCountArgs<ExtArgs>
            result: $Utils.Optional<MerklRootCountAggregateOutputType> | number
          }
        }
      }
      PriceSource: {
        payload: Prisma.$PriceSourcePayload<ExtArgs>
        fields: Prisma.PriceSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          findFirst: {
            args: Prisma.PriceSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          findMany: {
            args: Prisma.PriceSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>[]
          }
          create: {
            args: Prisma.PriceSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          createMany: {
            args: Prisma.PriceSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>[]
          }
          delete: {
            args: Prisma.PriceSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          update: {
            args: Prisma.PriceSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          deleteMany: {
            args: Prisma.PriceSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>[]
          }
          upsert: {
            args: Prisma.PriceSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceSourcePayload>
          }
          aggregate: {
            args: Prisma.PriceSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceSource>
          }
          groupBy: {
            args: Prisma.PriceSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceSourceCountArgs<ExtArgs>
            result: $Utils.Optional<PriceSourceCountAggregateOutputType> | number
          }
        }
      }
      Blacklist: {
        payload: Prisma.$BlacklistPayload<ExtArgs>
        fields: Prisma.BlacklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          findFirst: {
            args: Prisma.BlacklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          findMany: {
            args: Prisma.BlacklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          create: {
            args: Prisma.BlacklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          createMany: {
            args: Prisma.BlacklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlacklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          delete: {
            args: Prisma.BlacklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          update: {
            args: Prisma.BlacklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          deleteMany: {
            args: Prisma.BlacklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlacklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          upsert: {
            args: Prisma.BlacklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          aggregate: {
            args: Prisma.BlacklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklist>
          }
          groupBy: {
            args: Prisma.BlacklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklistCountAggregateOutputType> | number
          }
        }
      }
      Dump: {
        payload: Prisma.$DumpPayload<ExtArgs>
        fields: Prisma.DumpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DumpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DumpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          findFirst: {
            args: Prisma.DumpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DumpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          findMany: {
            args: Prisma.DumpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>[]
          }
          create: {
            args: Prisma.DumpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          createMany: {
            args: Prisma.DumpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DumpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>[]
          }
          delete: {
            args: Prisma.DumpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          update: {
            args: Prisma.DumpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          deleteMany: {
            args: Prisma.DumpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DumpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DumpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>[]
          }
          upsert: {
            args: Prisma.DumpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DumpPayload>
          }
          aggregate: {
            args: Prisma.DumpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDump>
          }
          groupBy: {
            args: Prisma.DumpGroupByArgs<ExtArgs>
            result: $Utils.Optional<DumpGroupByOutputType>[]
          }
          count: {
            args: Prisma.DumpCountArgs<ExtArgs>
            result: $Utils.Optional<DumpCountAggregateOutputType> | number
          }
        }
      }
      Logged: {
        payload: Prisma.$LoggedPayload<ExtArgs>
        fields: Prisma.LoggedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoggedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoggedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          findFirst: {
            args: Prisma.LoggedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoggedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          findMany: {
            args: Prisma.LoggedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>[]
          }
          create: {
            args: Prisma.LoggedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          createMany: {
            args: Prisma.LoggedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoggedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>[]
          }
          delete: {
            args: Prisma.LoggedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          update: {
            args: Prisma.LoggedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          deleteMany: {
            args: Prisma.LoggedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoggedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoggedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>[]
          }
          upsert: {
            args: Prisma.LoggedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoggedPayload>
          }
          aggregate: {
            args: Prisma.LoggedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogged>
          }
          groupBy: {
            args: Prisma.LoggedGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoggedGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoggedCountArgs<ExtArgs>
            result: $Utils.Optional<LoggedCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    campaign?: CampaignOmit
    campaignStatus?: CampaignStatusOmit
    campaignComputedValue?: CampaignComputedValueOmit
    userComputedValue?: UserComputedValueOmit
    chain?: ChainOmit
    explorer?: ExplorerOmit
    opportunity?: OpportunityOmit
    protocol?: ProtocolOmit
    token?: TokenOmit
    aprRecord?: AprRecordOmit
    aprBreakdown?: AprBreakdownOmit
    tVLRecord?: TVLRecordOmit
    tVLBreakdown?: TVLBreakdownOmit
    dailyRewardsRecord?: DailyRewardsRecordOmit
    dailyRewardsBreakdown?: DailyRewardsBreakdownOmit
    user?: UserOmit
    creator?: CreatorOmit
    reward?: RewardOmit
    rewardBreakdown?: RewardBreakdownOmit
    merklRoot?: MerklRootOmit
    priceSource?: PriceSourceOmit
    blacklist?: BlacklistOmit
    dump?: DumpOmit
    logged?: LoggedOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    RewardBreakdown: number
    DailyRewardsBreakdown: number
    CampaignStatus: number
    CampaignEngineValues: number
    UserComputedValue: number
    subCampaigns: number
    childCampaigns: number
    RewardBreakdownSubCampaign: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RewardBreakdown?: boolean | CampaignCountOutputTypeCountRewardBreakdownArgs
    DailyRewardsBreakdown?: boolean | CampaignCountOutputTypeCountDailyRewardsBreakdownArgs
    CampaignStatus?: boolean | CampaignCountOutputTypeCountCampaignStatusArgs
    CampaignEngineValues?: boolean | CampaignCountOutputTypeCountCampaignEngineValuesArgs
    UserComputedValue?: boolean | CampaignCountOutputTypeCountUserComputedValueArgs
    subCampaigns?: boolean | CampaignCountOutputTypeCountSubCampaignsArgs
    childCampaigns?: boolean | CampaignCountOutputTypeCountChildCampaignsArgs
    RewardBreakdownSubCampaign?: boolean | CampaignCountOutputTypeCountRewardBreakdownSubCampaignArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRewardBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardBreakdownWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountDailyRewardsBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardsBreakdownWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignStatusWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignEngineValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignComputedValueWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountUserComputedValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserComputedValueWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSubCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountChildCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRewardBreakdownSubCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardBreakdownWhereInput
  }


  /**
   * Count Type ChainCountOutputType
   */

  export type ChainCountOutputType = {
    Explorer: number
    Campaigns: number
    Distribution: number
    Token: number
    Opportunity: number
    MerklRoot: number
    Blacklist: number
    Dump: number
  }

  export type ChainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Explorer?: boolean | ChainCountOutputTypeCountExplorerArgs
    Campaigns?: boolean | ChainCountOutputTypeCountCampaignsArgs
    Distribution?: boolean | ChainCountOutputTypeCountDistributionArgs
    Token?: boolean | ChainCountOutputTypeCountTokenArgs
    Opportunity?: boolean | ChainCountOutputTypeCountOpportunityArgs
    MerklRoot?: boolean | ChainCountOutputTypeCountMerklRootArgs
    Blacklist?: boolean | ChainCountOutputTypeCountBlacklistArgs
    Dump?: boolean | ChainCountOutputTypeCountDumpArgs
  }

  // Custom InputTypes
  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainCountOutputType
     */
    select?: ChainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExplorerWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountDistributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountOpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountMerklRootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerklRootWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
  }

  /**
   * ChainCountOutputType without action
   */
  export type ChainCountOutputTypeCountDumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DumpWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    Tokens: number
    Campaigns: number
    Protocols: number
    TvlRecords: number
    AprRecords: number
    DailyRewardsRecords: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tokens?: boolean | OpportunityCountOutputTypeCountTokensArgs
    Campaigns?: boolean | OpportunityCountOutputTypeCountCampaignsArgs
    Protocols?: boolean | OpportunityCountOutputTypeCountProtocolsArgs
    TvlRecords?: boolean | OpportunityCountOutputTypeCountTvlRecordsArgs
    AprRecords?: boolean | OpportunityCountOutputTypeCountAprRecordsArgs
    DailyRewardsRecords?: boolean | OpportunityCountOutputTypeCountDailyRewardsRecordsArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountTvlRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVLRecordWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountAprRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AprRecordWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountDailyRewardsRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardsRecordWhereInput
  }


  /**
   * Count Type ProtocolCountOutputType
   */

  export type ProtocolCountOutputType = {
    MainOpportunities: number
    Opportunities: number
    RewardBreakdown: number
  }

  export type ProtocolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MainOpportunities?: boolean | ProtocolCountOutputTypeCountMainOpportunitiesArgs
    Opportunities?: boolean | ProtocolCountOutputTypeCountOpportunitiesArgs
    RewardBreakdown?: boolean | ProtocolCountOutputTypeCountRewardBreakdownArgs
  }

  // Custom InputTypes
  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolCountOutputType
     */
    select?: ProtocolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountMainOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountRewardBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardBreakdownWhereInput
  }


  /**
   * Count Type TokenCountOutputType
   */

  export type TokenCountOutputType = {
    Opportunity: number
    Campaigns: number
    Reward: number
    DumpTo: number
    DumpFrom: number
  }

  export type TokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | TokenCountOutputTypeCountOpportunityArgs
    Campaigns?: boolean | TokenCountOutputTypeCountCampaignsArgs
    Reward?: boolean | TokenCountOutputTypeCountRewardArgs
    DumpTo?: boolean | TokenCountOutputTypeCountDumpToArgs
    DumpFrom?: boolean | TokenCountOutputTypeCountDumpFromArgs
  }

  // Custom InputTypes
  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenCountOutputType
     */
    select?: TokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountOpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDumpToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DumpWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDumpFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DumpWhereInput
  }


  /**
   * Count Type AprRecordCountOutputType
   */

  export type AprRecordCountOutputType = {
    AprBreakdown: number
  }

  export type AprRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AprBreakdown?: boolean | AprRecordCountOutputTypeCountAprBreakdownArgs
  }

  // Custom InputTypes
  /**
   * AprRecordCountOutputType without action
   */
  export type AprRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecordCountOutputType
     */
    select?: AprRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AprRecordCountOutputType without action
   */
  export type AprRecordCountOutputTypeCountAprBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AprBreakdownWhereInput
  }


  /**
   * Count Type TVLRecordCountOutputType
   */

  export type TVLRecordCountOutputType = {
    TvlBreakdown: number
  }

  export type TVLRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TvlBreakdown?: boolean | TVLRecordCountOutputTypeCountTvlBreakdownArgs
  }

  // Custom InputTypes
  /**
   * TVLRecordCountOutputType without action
   */
  export type TVLRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecordCountOutputType
     */
    select?: TVLRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TVLRecordCountOutputType without action
   */
  export type TVLRecordCountOutputTypeCountTvlBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVLBreakdownWhereInput
  }


  /**
   * Count Type DailyRewardsRecordCountOutputType
   */

  export type DailyRewardsRecordCountOutputType = {
    DailyRewardsBreakdown: number
  }

  export type DailyRewardsRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DailyRewardsBreakdown?: boolean | DailyRewardsRecordCountOutputTypeCountDailyRewardsBreakdownArgs
  }

  // Custom InputTypes
  /**
   * DailyRewardsRecordCountOutputType without action
   */
  export type DailyRewardsRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecordCountOutputType
     */
    select?: DailyRewardsRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyRewardsRecordCountOutputType without action
   */
  export type DailyRewardsRecordCountOutputTypeCountDailyRewardsBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardsBreakdownWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Rewards: number
    Blacklist: number
    CampaignsCreated: number
    UserComputedValue: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rewards?: boolean | UserCountOutputTypeCountRewardsArgs
    Blacklist?: boolean | UserCountOutputTypeCountBlacklistArgs
    CampaignsCreated?: boolean | UserCountOutputTypeCountCampaignsCreatedArgs
    UserComputedValue?: boolean | UserCountOutputTypeCountUserComputedValueArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserComputedValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserComputedValueWhereInput
  }


  /**
   * Count Type CreatorCountOutputType
   */

  export type CreatorCountOutputType = {
    Users: number
  }

  export type CreatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | CreatorCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatorCountOutputType
     */
    select?: CreatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RewardCountOutputType
   */

  export type RewardCountOutputType = {
    Breakdown: number
  }

  export type RewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Breakdown?: boolean | RewardCountOutputTypeCountBreakdownArgs
  }

  // Custom InputTypes
  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardCountOutputType
     */
    select?: RewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeCountBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardBreakdownWhereInput
  }


  /**
   * Count Type MerklRootCountOutputType
   */

  export type MerklRootCountOutputType = {
    Rewards: number
  }

  export type MerklRootCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rewards?: boolean | MerklRootCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * MerklRootCountOutputType without action
   */
  export type MerklRootCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRootCountOutputType
     */
    select?: MerklRootCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerklRootCountOutputType without action
   */
  export type MerklRootCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    computeChainId: number | null
    distributionChainId: number | null
    subType: number | null
    startTimestamp: number | null
    endTimestamp: number | null
  }

  export type CampaignSumAggregateOutputType = {
    computeChainId: number | null
    distributionChainId: number | null
    subType: number | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    computeChainId: number | null
    distributionChainId: number | null
    campaignId: string | null
    type: string | null
    distributionType: $Enums.DistributionType | null
    subType: number | null
    rewardTokenId: string | null
    amount: string | null
    opportunityId: string | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
    description: string | null
    creatorAddress: string | null
    createdAt: Date | null
    rootCampaignId: string | null
    parentCampaignId: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    computeChainId: number | null
    distributionChainId: number | null
    campaignId: string | null
    type: string | null
    distributionType: $Enums.DistributionType | null
    subType: number | null
    rewardTokenId: string | null
    amount: string | null
    opportunityId: string | null
    startTimestamp: bigint | null
    endTimestamp: bigint | null
    description: string | null
    creatorAddress: string | null
    createdAt: Date | null
    rootCampaignId: string | null
    parentCampaignId: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    computeChainId: number
    distributionChainId: number
    campaignId: number
    type: number
    distributionType: number
    subType: number
    rewardTokenId: number
    amount: number
    opportunityId: number
    startTimestamp: number
    endTimestamp: number
    params: number
    description: number
    creatorAddress: number
    manualOverrides: number
    createdAt: number
    rootCampaignId: number
    parentCampaignId: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    computeChainId?: true
    distributionChainId?: true
    subType?: true
    startTimestamp?: true
    endTimestamp?: true
  }

  export type CampaignSumAggregateInputType = {
    computeChainId?: true
    distributionChainId?: true
    subType?: true
    startTimestamp?: true
    endTimestamp?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    computeChainId?: true
    distributionChainId?: true
    campaignId?: true
    type?: true
    distributionType?: true
    subType?: true
    rewardTokenId?: true
    amount?: true
    opportunityId?: true
    startTimestamp?: true
    endTimestamp?: true
    description?: true
    creatorAddress?: true
    createdAt?: true
    rootCampaignId?: true
    parentCampaignId?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    computeChainId?: true
    distributionChainId?: true
    campaignId?: true
    type?: true
    distributionType?: true
    subType?: true
    rewardTokenId?: true
    amount?: true
    opportunityId?: true
    startTimestamp?: true
    endTimestamp?: true
    description?: true
    creatorAddress?: true
    createdAt?: true
    rootCampaignId?: true
    parentCampaignId?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    computeChainId?: true
    distributionChainId?: true
    campaignId?: true
    type?: true
    distributionType?: true
    subType?: true
    rewardTokenId?: true
    amount?: true
    opportunityId?: true
    startTimestamp?: true
    endTimestamp?: true
    params?: true
    description?: true
    creatorAddress?: true
    manualOverrides?: true
    createdAt?: true
    rootCampaignId?: true
    parentCampaignId?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType: $Enums.DistributionType
    subType: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint
    endTimestamp: bigint
    params: JsonValue
    description: string | null
    creatorAddress: string
    manualOverrides: $Enums.CampaignManualOverride[]
    createdAt: Date
    rootCampaignId: string | null
    parentCampaignId: string | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computeChainId?: boolean
    distributionChainId?: boolean
    campaignId?: boolean
    type?: boolean
    distributionType?: boolean
    subType?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    opportunityId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    params?: boolean
    description?: boolean
    creatorAddress?: boolean
    manualOverrides?: boolean
    createdAt?: boolean
    rootCampaignId?: boolean
    parentCampaignId?: boolean
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    RewardBreakdown?: boolean | Campaign$RewardBreakdownArgs<ExtArgs>
    DailyRewardsBreakdown?: boolean | Campaign$DailyRewardsBreakdownArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    CampaignStatus?: boolean | Campaign$CampaignStatusArgs<ExtArgs>
    CampaignEngineValues?: boolean | Campaign$CampaignEngineValuesArgs<ExtArgs>
    UserComputedValue?: boolean | Campaign$UserComputedValueArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    subCampaigns?: boolean | Campaign$subCampaignsArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
    childCampaigns?: boolean | Campaign$childCampaignsArgs<ExtArgs>
    RewardBreakdownSubCampaign?: boolean | Campaign$RewardBreakdownSubCampaignArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computeChainId?: boolean
    distributionChainId?: boolean
    campaignId?: boolean
    type?: boolean
    distributionType?: boolean
    subType?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    opportunityId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    params?: boolean
    description?: boolean
    creatorAddress?: boolean
    manualOverrides?: boolean
    createdAt?: boolean
    rootCampaignId?: boolean
    parentCampaignId?: boolean
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    computeChainId?: boolean
    distributionChainId?: boolean
    campaignId?: boolean
    type?: boolean
    distributionType?: boolean
    subType?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    opportunityId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    params?: boolean
    description?: boolean
    creatorAddress?: boolean
    manualOverrides?: boolean
    createdAt?: boolean
    rootCampaignId?: boolean
    parentCampaignId?: boolean
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    computeChainId?: boolean
    distributionChainId?: boolean
    campaignId?: boolean
    type?: boolean
    distributionType?: boolean
    subType?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    opportunityId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    params?: boolean
    description?: boolean
    creatorAddress?: boolean
    manualOverrides?: boolean
    createdAt?: boolean
    rootCampaignId?: boolean
    parentCampaignId?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "computeChainId" | "distributionChainId" | "campaignId" | "type" | "distributionType" | "subType" | "rewardTokenId" | "amount" | "opportunityId" | "startTimestamp" | "endTimestamp" | "params" | "description" | "creatorAddress" | "manualOverrides" | "createdAt" | "rootCampaignId" | "parentCampaignId", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    RewardBreakdown?: boolean | Campaign$RewardBreakdownArgs<ExtArgs>
    DailyRewardsBreakdown?: boolean | Campaign$DailyRewardsBreakdownArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    CampaignStatus?: boolean | Campaign$CampaignStatusArgs<ExtArgs>
    CampaignEngineValues?: boolean | Campaign$CampaignEngineValuesArgs<ExtArgs>
    UserComputedValue?: boolean | Campaign$UserComputedValueArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    subCampaigns?: boolean | Campaign$subCampaignsArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
    childCampaigns?: boolean | Campaign$childCampaignsArgs<ExtArgs>
    RewardBreakdownSubCampaign?: boolean | Campaign$RewardBreakdownSubCampaignArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ComputeChain?: boolean | ChainDefaultArgs<ExtArgs>
    DistributionChain?: boolean | ChainDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    Creator?: boolean | UserDefaultArgs<ExtArgs>
    rootCampaign?: boolean | Campaign$rootCampaignArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      ComputeChain: Prisma.$ChainPayload<ExtArgs>
      DistributionChain: Prisma.$ChainPayload<ExtArgs>
      RewardToken: Prisma.$TokenPayload<ExtArgs>
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>
      RewardBreakdown: Prisma.$RewardBreakdownPayload<ExtArgs>[]
      DailyRewardsBreakdown: Prisma.$DailyRewardsBreakdownPayload<ExtArgs>[]
      Creator: Prisma.$UserPayload<ExtArgs>
      CampaignStatus: Prisma.$CampaignStatusPayload<ExtArgs>[]
      CampaignEngineValues: Prisma.$CampaignComputedValuePayload<ExtArgs>[]
      UserComputedValue: Prisma.$UserComputedValuePayload<ExtArgs>[]
      rootCampaign: Prisma.$CampaignPayload<ExtArgs> | null
      subCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      parentCampaign: Prisma.$CampaignPayload<ExtArgs> | null
      childCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      RewardBreakdownSubCampaign: Prisma.$RewardBreakdownPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      computeChainId: number
      distributionChainId: number
      campaignId: string
      type: string
      distributionType: $Enums.DistributionType
      subType: number | null
      rewardTokenId: string
      amount: string
      opportunityId: string
      startTimestamp: bigint
      endTimestamp: bigint
      params: Prisma.JsonValue
      description: string | null
      creatorAddress: string
      manualOverrides: $Enums.CampaignManualOverride[]
      createdAt: Date
      rootCampaignId: string | null
      parentCampaignId: string | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ComputeChain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DistributionChain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    RewardToken<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    RewardBreakdown<T extends Campaign$RewardBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$RewardBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DailyRewardsBreakdown<T extends Campaign$DailyRewardsBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$DailyRewardsBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    CampaignStatus<T extends Campaign$CampaignStatusArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$CampaignStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    CampaignEngineValues<T extends Campaign$CampaignEngineValuesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$CampaignEngineValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserComputedValue<T extends Campaign$UserComputedValueArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$UserComputedValueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rootCampaign<T extends Campaign$rootCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$rootCampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    subCampaigns<T extends Campaign$subCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$subCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    parentCampaign<T extends Campaign$parentCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$parentCampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    childCampaigns<T extends Campaign$childCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$childCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RewardBreakdownSubCampaign<T extends Campaign$RewardBreakdownSubCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$RewardBreakdownSubCampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly computeChainId: FieldRef<"Campaign", 'Int'>
    readonly distributionChainId: FieldRef<"Campaign", 'Int'>
    readonly campaignId: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly distributionType: FieldRef<"Campaign", 'DistributionType'>
    readonly subType: FieldRef<"Campaign", 'Int'>
    readonly rewardTokenId: FieldRef<"Campaign", 'String'>
    readonly amount: FieldRef<"Campaign", 'String'>
    readonly opportunityId: FieldRef<"Campaign", 'String'>
    readonly startTimestamp: FieldRef<"Campaign", 'BigInt'>
    readonly endTimestamp: FieldRef<"Campaign", 'BigInt'>
    readonly params: FieldRef<"Campaign", 'Json'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly creatorAddress: FieldRef<"Campaign", 'String'>
    readonly manualOverrides: FieldRef<"Campaign", 'CampaignManualOverride[]'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly rootCampaignId: FieldRef<"Campaign", 'String'>
    readonly parentCampaignId: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.RewardBreakdown
   */
  export type Campaign$RewardBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    where?: RewardBreakdownWhereInput
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    cursor?: RewardBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
  }

  /**
   * Campaign.DailyRewardsBreakdown
   */
  export type Campaign$DailyRewardsBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    where?: DailyRewardsBreakdownWhereInput
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRewardsBreakdownScalarFieldEnum | DailyRewardsBreakdownScalarFieldEnum[]
  }

  /**
   * Campaign.CampaignStatus
   */
  export type Campaign$CampaignStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    where?: CampaignStatusWhereInput
    orderBy?: CampaignStatusOrderByWithRelationInput | CampaignStatusOrderByWithRelationInput[]
    cursor?: CampaignStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignStatusScalarFieldEnum | CampaignStatusScalarFieldEnum[]
  }

  /**
   * Campaign.CampaignEngineValues
   */
  export type Campaign$CampaignEngineValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    where?: CampaignComputedValueWhereInput
    orderBy?: CampaignComputedValueOrderByWithRelationInput | CampaignComputedValueOrderByWithRelationInput[]
    cursor?: CampaignComputedValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignComputedValueScalarFieldEnum | CampaignComputedValueScalarFieldEnum[]
  }

  /**
   * Campaign.UserComputedValue
   */
  export type Campaign$UserComputedValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    where?: UserComputedValueWhereInput
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    cursor?: UserComputedValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserComputedValueScalarFieldEnum | UserComputedValueScalarFieldEnum[]
  }

  /**
   * Campaign.rootCampaign
   */
  export type Campaign$rootCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Campaign.subCampaigns
   */
  export type Campaign$subCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign.parentCampaign
   */
  export type Campaign$parentCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Campaign.childCampaigns
   */
  export type Campaign$childCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign.RewardBreakdownSubCampaign
   */
  export type Campaign$RewardBreakdownSubCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    where?: RewardBreakdownWhereInput
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    cursor?: RewardBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignStatus
   */

  export type AggregateCampaignStatus = {
    _count: CampaignStatusCountAggregateOutputType | null
    _avg: CampaignStatusAvgAggregateOutputType | null
    _sum: CampaignStatusSumAggregateOutputType | null
    _min: CampaignStatusMinAggregateOutputType | null
    _max: CampaignStatusMaxAggregateOutputType | null
  }

  export type CampaignStatusAvgAggregateOutputType = {
    computedUntil: number | null
    processingStarted: number | null
  }

  export type CampaignStatusSumAggregateOutputType = {
    computedUntil: bigint | null
    processingStarted: bigint | null
  }

  export type CampaignStatusMinAggregateOutputType = {
    campaignId: string | null
    computedUntil: bigint | null
    processingStarted: bigint | null
    status: $Enums.RunStatus | null
    error: string | null
  }

  export type CampaignStatusMaxAggregateOutputType = {
    campaignId: string | null
    computedUntil: bigint | null
    processingStarted: bigint | null
    status: $Enums.RunStatus | null
    error: string | null
  }

  export type CampaignStatusCountAggregateOutputType = {
    campaignId: number
    computedUntil: number
    processingStarted: number
    status: number
    error: number
    details: number
    _all: number
  }


  export type CampaignStatusAvgAggregateInputType = {
    computedUntil?: true
    processingStarted?: true
  }

  export type CampaignStatusSumAggregateInputType = {
    computedUntil?: true
    processingStarted?: true
  }

  export type CampaignStatusMinAggregateInputType = {
    campaignId?: true
    computedUntil?: true
    processingStarted?: true
    status?: true
    error?: true
  }

  export type CampaignStatusMaxAggregateInputType = {
    campaignId?: true
    computedUntil?: true
    processingStarted?: true
    status?: true
    error?: true
  }

  export type CampaignStatusCountAggregateInputType = {
    campaignId?: true
    computedUntil?: true
    processingStarted?: true
    status?: true
    error?: true
    details?: true
    _all?: true
  }

  export type CampaignStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatus to aggregate.
     */
    where?: CampaignStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatuses to fetch.
     */
    orderBy?: CampaignStatusOrderByWithRelationInput | CampaignStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignStatuses
    **/
    _count?: true | CampaignStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignStatusMaxAggregateInputType
  }

  export type GetCampaignStatusAggregateType<T extends CampaignStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignStatus[P]>
      : GetScalarType<T[P], AggregateCampaignStatus[P]>
  }




  export type CampaignStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignStatusWhereInput
    orderBy?: CampaignStatusOrderByWithAggregationInput | CampaignStatusOrderByWithAggregationInput[]
    by: CampaignStatusScalarFieldEnum[] | CampaignStatusScalarFieldEnum
    having?: CampaignStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignStatusCountAggregateInputType | true
    _avg?: CampaignStatusAvgAggregateInputType
    _sum?: CampaignStatusSumAggregateInputType
    _min?: CampaignStatusMinAggregateInputType
    _max?: CampaignStatusMaxAggregateInputType
  }

  export type CampaignStatusGroupByOutputType = {
    campaignId: string
    computedUntil: bigint
    processingStarted: bigint
    status: $Enums.RunStatus
    error: string
    details: JsonValue
    _count: CampaignStatusCountAggregateOutputType | null
    _avg: CampaignStatusAvgAggregateOutputType | null
    _sum: CampaignStatusSumAggregateOutputType | null
    _min: CampaignStatusMinAggregateOutputType | null
    _max: CampaignStatusMaxAggregateOutputType | null
  }

  type GetCampaignStatusGroupByPayload<T extends CampaignStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignStatusGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignStatusGroupByOutputType[P]>
        }
      >
    >


  export type CampaignStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    computedUntil?: boolean
    processingStarted?: boolean
    status?: boolean
    error?: boolean
    details?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatus"]>

  export type CampaignStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    computedUntil?: boolean
    processingStarted?: boolean
    status?: boolean
    error?: boolean
    details?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatus"]>

  export type CampaignStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    computedUntil?: boolean
    processingStarted?: boolean
    status?: boolean
    error?: boolean
    details?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatus"]>

  export type CampaignStatusSelectScalar = {
    campaignId?: boolean
    computedUntil?: boolean
    processingStarted?: boolean
    status?: boolean
    error?: boolean
    details?: boolean
  }

  export type CampaignStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"campaignId" | "computedUntil" | "processingStarted" | "status" | "error" | "details", ExtArgs["result"]["campaignStatus"]>
  export type CampaignStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignStatus"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      campaignId: string
      computedUntil: bigint
      processingStarted: bigint
      status: $Enums.RunStatus
      error: string
      details: Prisma.JsonValue
    }, ExtArgs["result"]["campaignStatus"]>
    composites: {}
  }

  type CampaignStatusGetPayload<S extends boolean | null | undefined | CampaignStatusDefaultArgs> = $Result.GetResult<Prisma.$CampaignStatusPayload, S>

  type CampaignStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CampaignStatusCountAggregateInputType | true
    }

  export interface CampaignStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignStatus'], meta: { name: 'CampaignStatus' } }
    /**
     * Find zero or one CampaignStatus that matches the filter.
     * @param {CampaignStatusFindUniqueArgs} args - Arguments to find a CampaignStatus
     * @example
     * // Get one CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignStatusFindUniqueArgs>(args: SelectSubset<T, CampaignStatusFindUniqueArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CampaignStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignStatusFindUniqueOrThrowArgs} args - Arguments to find a CampaignStatus
     * @example
     * // Get one CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CampaignStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusFindFirstArgs} args - Arguments to find a CampaignStatus
     * @example
     * // Get one CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignStatusFindFirstArgs>(args?: SelectSubset<T, CampaignStatusFindFirstArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CampaignStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusFindFirstOrThrowArgs} args - Arguments to find a CampaignStatus
     * @example
     * // Get one CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CampaignStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignStatuses
     * const campaignStatuses = await prisma.campaignStatus.findMany()
     * 
     * // Get first 10 CampaignStatuses
     * const campaignStatuses = await prisma.campaignStatus.findMany({ take: 10 })
     * 
     * // Only select the `campaignId`
     * const campaignStatusWithCampaignIdOnly = await prisma.campaignStatus.findMany({ select: { campaignId: true } })
     * 
     */
    findMany<T extends CampaignStatusFindManyArgs>(args?: SelectSubset<T, CampaignStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CampaignStatus.
     * @param {CampaignStatusCreateArgs} args - Arguments to create a CampaignStatus.
     * @example
     * // Create one CampaignStatus
     * const CampaignStatus = await prisma.campaignStatus.create({
     *   data: {
     *     // ... data to create a CampaignStatus
     *   }
     * })
     * 
     */
    create<T extends CampaignStatusCreateArgs>(args: SelectSubset<T, CampaignStatusCreateArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CampaignStatuses.
     * @param {CampaignStatusCreateManyArgs} args - Arguments to create many CampaignStatuses.
     * @example
     * // Create many CampaignStatuses
     * const campaignStatus = await prisma.campaignStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignStatusCreateManyArgs>(args?: SelectSubset<T, CampaignStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignStatuses and returns the data saved in the database.
     * @param {CampaignStatusCreateManyAndReturnArgs} args - Arguments to create many CampaignStatuses.
     * @example
     * // Create many CampaignStatuses
     * const campaignStatus = await prisma.campaignStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignStatuses and only return the `campaignId`
     * const campaignStatusWithCampaignIdOnly = await prisma.campaignStatus.createManyAndReturn({
     *   select: { campaignId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CampaignStatus.
     * @param {CampaignStatusDeleteArgs} args - Arguments to delete one CampaignStatus.
     * @example
     * // Delete one CampaignStatus
     * const CampaignStatus = await prisma.campaignStatus.delete({
     *   where: {
     *     // ... filter to delete one CampaignStatus
     *   }
     * })
     * 
     */
    delete<T extends CampaignStatusDeleteArgs>(args: SelectSubset<T, CampaignStatusDeleteArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CampaignStatus.
     * @param {CampaignStatusUpdateArgs} args - Arguments to update one CampaignStatus.
     * @example
     * // Update one CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignStatusUpdateArgs>(args: SelectSubset<T, CampaignStatusUpdateArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CampaignStatuses.
     * @param {CampaignStatusDeleteManyArgs} args - Arguments to filter CampaignStatuses to delete.
     * @example
     * // Delete a few CampaignStatuses
     * const { count } = await prisma.campaignStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignStatusDeleteManyArgs>(args?: SelectSubset<T, CampaignStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignStatuses
     * const campaignStatus = await prisma.campaignStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignStatusUpdateManyArgs>(args: SelectSubset<T, CampaignStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignStatuses and returns the data updated in the database.
     * @param {CampaignStatusUpdateManyAndReturnArgs} args - Arguments to update many CampaignStatuses.
     * @example
     * // Update many CampaignStatuses
     * const campaignStatus = await prisma.campaignStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignStatuses and only return the `campaignId`
     * const campaignStatusWithCampaignIdOnly = await prisma.campaignStatus.updateManyAndReturn({
     *   select: { campaignId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CampaignStatus.
     * @param {CampaignStatusUpsertArgs} args - Arguments to update or create a CampaignStatus.
     * @example
     * // Update or create a CampaignStatus
     * const campaignStatus = await prisma.campaignStatus.upsert({
     *   create: {
     *     // ... data to create a CampaignStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignStatus we want to update
     *   }
     * })
     */
    upsert<T extends CampaignStatusUpsertArgs>(args: SelectSubset<T, CampaignStatusUpsertArgs<ExtArgs>>): Prisma__CampaignStatusClient<$Result.GetResult<Prisma.$CampaignStatusPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CampaignStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusCountArgs} args - Arguments to filter CampaignStatuses to count.
     * @example
     * // Count the number of CampaignStatuses
     * const count = await prisma.campaignStatus.count({
     *   where: {
     *     // ... the filter for the CampaignStatuses we want to count
     *   }
     * })
    **/
    count<T extends CampaignStatusCountArgs>(
      args?: Subset<T, CampaignStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignStatusAggregateArgs>(args: Subset<T, CampaignStatusAggregateArgs>): Prisma.PrismaPromise<GetCampaignStatusAggregateType<T>>

    /**
     * Group by CampaignStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignStatusGroupByArgs['orderBy'] }
        : { orderBy?: CampaignStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignStatus model
   */
  readonly fields: CampaignStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignStatus model
   */ 
  interface CampaignStatusFieldRefs {
    readonly campaignId: FieldRef<"CampaignStatus", 'String'>
    readonly computedUntil: FieldRef<"CampaignStatus", 'BigInt'>
    readonly processingStarted: FieldRef<"CampaignStatus", 'BigInt'>
    readonly status: FieldRef<"CampaignStatus", 'RunStatus'>
    readonly error: FieldRef<"CampaignStatus", 'String'>
    readonly details: FieldRef<"CampaignStatus", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CampaignStatus findUnique
   */
  export type CampaignStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatus to fetch.
     */
    where: CampaignStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus findUniqueOrThrow
   */
  export type CampaignStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatus to fetch.
     */
    where: CampaignStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus findFirst
   */
  export type CampaignStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatus to fetch.
     */
    where?: CampaignStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatuses to fetch.
     */
    orderBy?: CampaignStatusOrderByWithRelationInput | CampaignStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatuses.
     */
    cursor?: CampaignStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatuses.
     */
    distinct?: CampaignStatusScalarFieldEnum | CampaignStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus findFirstOrThrow
   */
  export type CampaignStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatus to fetch.
     */
    where?: CampaignStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatuses to fetch.
     */
    orderBy?: CampaignStatusOrderByWithRelationInput | CampaignStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatuses.
     */
    cursor?: CampaignStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatuses.
     */
    distinct?: CampaignStatusScalarFieldEnum | CampaignStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus findMany
   */
  export type CampaignStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatuses to fetch.
     */
    where?: CampaignStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatuses to fetch.
     */
    orderBy?: CampaignStatusOrderByWithRelationInput | CampaignStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignStatuses.
     */
    cursor?: CampaignStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatuses.
     */
    skip?: number
    distinct?: CampaignStatusScalarFieldEnum | CampaignStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus create
   */
  export type CampaignStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignStatus.
     */
    data: XOR<CampaignStatusCreateInput, CampaignStatusUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus createMany
   */
  export type CampaignStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignStatuses.
     */
    data: CampaignStatusCreateManyInput | CampaignStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignStatus createManyAndReturn
   */
  export type CampaignStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignStatuses.
     */
    data: CampaignStatusCreateManyInput | CampaignStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignStatus update
   */
  export type CampaignStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignStatus.
     */
    data: XOR<CampaignStatusUpdateInput, CampaignStatusUncheckedUpdateInput>
    /**
     * Choose, which CampaignStatus to update.
     */
    where: CampaignStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus updateMany
   */
  export type CampaignStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignStatuses.
     */
    data: XOR<CampaignStatusUpdateManyMutationInput, CampaignStatusUncheckedUpdateManyInput>
    /**
     * Filter which CampaignStatuses to update
     */
    where?: CampaignStatusWhereInput
    /**
     * Limit how many CampaignStatuses to update.
     */
    limit?: number
  }

  /**
   * CampaignStatus updateManyAndReturn
   */
  export type CampaignStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * The data used to update CampaignStatuses.
     */
    data: XOR<CampaignStatusUpdateManyMutationInput, CampaignStatusUncheckedUpdateManyInput>
    /**
     * Filter which CampaignStatuses to update
     */
    where?: CampaignStatusWhereInput
    /**
     * Limit how many CampaignStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignStatus upsert
   */
  export type CampaignStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignStatus to update in case it exists.
     */
    where: CampaignStatusWhereUniqueInput
    /**
     * In case the CampaignStatus found by the `where` argument doesn't exist, create a new CampaignStatus with this data.
     */
    create: XOR<CampaignStatusCreateInput, CampaignStatusUncheckedCreateInput>
    /**
     * In case the CampaignStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignStatusUpdateInput, CampaignStatusUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus delete
   */
  export type CampaignStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
    /**
     * Filter which CampaignStatus to delete.
     */
    where: CampaignStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignStatus deleteMany
   */
  export type CampaignStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatuses to delete
     */
    where?: CampaignStatusWhereInput
    /**
     * Limit how many CampaignStatuses to delete.
     */
    limit?: number
  }

  /**
   * CampaignStatus without action
   */
  export type CampaignStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatus
     */
    select?: CampaignStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatus
     */
    omit?: CampaignStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatusInclude<ExtArgs> | null
  }


  /**
   * Model CampaignComputedValue
   */

  export type AggregateCampaignComputedValue = {
    _count: CampaignComputedValueCountAggregateOutputType | null
    _avg: CampaignComputedValueAvgAggregateOutputType | null
    _sum: CampaignComputedValueSumAggregateOutputType | null
    _min: CampaignComputedValueMinAggregateOutputType | null
    _max: CampaignComputedValueMaxAggregateOutputType | null
  }

  export type CampaignComputedValueAvgAggregateOutputType = {
    averageBoost: number | null
    totalDistributedInUSD: number | null
    forfeitingBoost: number | null
  }

  export type CampaignComputedValueSumAggregateOutputType = {
    averageBoost: number | null
    totalDistributedInUSD: number | null
    forfeitingBoost: number | null
  }

  export type CampaignComputedValueMinAggregateOutputType = {
    campaignId: string | null
    averageBoost: number | null
    totalDistributedInUSD: number | null
    forfeitingBoost: number | null
  }

  export type CampaignComputedValueMaxAggregateOutputType = {
    campaignId: string | null
    averageBoost: number | null
    totalDistributedInUSD: number | null
    forfeitingBoost: number | null
  }

  export type CampaignComputedValueCountAggregateOutputType = {
    campaignId: number
    averageBoost: number
    totalDistributedInUSD: number
    forfeitingBoost: number
    _all: number
  }


  export type CampaignComputedValueAvgAggregateInputType = {
    averageBoost?: true
    totalDistributedInUSD?: true
    forfeitingBoost?: true
  }

  export type CampaignComputedValueSumAggregateInputType = {
    averageBoost?: true
    totalDistributedInUSD?: true
    forfeitingBoost?: true
  }

  export type CampaignComputedValueMinAggregateInputType = {
    campaignId?: true
    averageBoost?: true
    totalDistributedInUSD?: true
    forfeitingBoost?: true
  }

  export type CampaignComputedValueMaxAggregateInputType = {
    campaignId?: true
    averageBoost?: true
    totalDistributedInUSD?: true
    forfeitingBoost?: true
  }

  export type CampaignComputedValueCountAggregateInputType = {
    campaignId?: true
    averageBoost?: true
    totalDistributedInUSD?: true
    forfeitingBoost?: true
    _all?: true
  }

  export type CampaignComputedValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignComputedValue to aggregate.
     */
    where?: CampaignComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignComputedValues to fetch.
     */
    orderBy?: CampaignComputedValueOrderByWithRelationInput | CampaignComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignComputedValues
    **/
    _count?: true | CampaignComputedValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignComputedValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignComputedValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignComputedValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignComputedValueMaxAggregateInputType
  }

  export type GetCampaignComputedValueAggregateType<T extends CampaignComputedValueAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignComputedValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignComputedValue[P]>
      : GetScalarType<T[P], AggregateCampaignComputedValue[P]>
  }




  export type CampaignComputedValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignComputedValueWhereInput
    orderBy?: CampaignComputedValueOrderByWithAggregationInput | CampaignComputedValueOrderByWithAggregationInput[]
    by: CampaignComputedValueScalarFieldEnum[] | CampaignComputedValueScalarFieldEnum
    having?: CampaignComputedValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignComputedValueCountAggregateInputType | true
    _avg?: CampaignComputedValueAvgAggregateInputType
    _sum?: CampaignComputedValueSumAggregateInputType
    _min?: CampaignComputedValueMinAggregateInputType
    _max?: CampaignComputedValueMaxAggregateInputType
  }

  export type CampaignComputedValueGroupByOutputType = {
    campaignId: string
    averageBoost: number | null
    totalDistributedInUSD: number | null
    forfeitingBoost: number | null
    _count: CampaignComputedValueCountAggregateOutputType | null
    _avg: CampaignComputedValueAvgAggregateOutputType | null
    _sum: CampaignComputedValueSumAggregateOutputType | null
    _min: CampaignComputedValueMinAggregateOutputType | null
    _max: CampaignComputedValueMaxAggregateOutputType | null
  }

  type GetCampaignComputedValueGroupByPayload<T extends CampaignComputedValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignComputedValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignComputedValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignComputedValueGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignComputedValueGroupByOutputType[P]>
        }
      >
    >


  export type CampaignComputedValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    averageBoost?: boolean
    totalDistributedInUSD?: boolean
    forfeitingBoost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignComputedValue"]>

  export type CampaignComputedValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    averageBoost?: boolean
    totalDistributedInUSD?: boolean
    forfeitingBoost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignComputedValue"]>

  export type CampaignComputedValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    campaignId?: boolean
    averageBoost?: boolean
    totalDistributedInUSD?: boolean
    forfeitingBoost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignComputedValue"]>

  export type CampaignComputedValueSelectScalar = {
    campaignId?: boolean
    averageBoost?: boolean
    totalDistributedInUSD?: boolean
    forfeitingBoost?: boolean
  }

  export type CampaignComputedValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"campaignId" | "averageBoost" | "totalDistributedInUSD" | "forfeitingBoost", ExtArgs["result"]["campaignComputedValue"]>
  export type CampaignComputedValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignComputedValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignComputedValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignComputedValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignComputedValue"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      campaignId: string
      averageBoost: number | null
      totalDistributedInUSD: number | null
      forfeitingBoost: number | null
    }, ExtArgs["result"]["campaignComputedValue"]>
    composites: {}
  }

  type CampaignComputedValueGetPayload<S extends boolean | null | undefined | CampaignComputedValueDefaultArgs> = $Result.GetResult<Prisma.$CampaignComputedValuePayload, S>

  type CampaignComputedValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignComputedValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CampaignComputedValueCountAggregateInputType | true
    }

  export interface CampaignComputedValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignComputedValue'], meta: { name: 'CampaignComputedValue' } }
    /**
     * Find zero or one CampaignComputedValue that matches the filter.
     * @param {CampaignComputedValueFindUniqueArgs} args - Arguments to find a CampaignComputedValue
     * @example
     * // Get one CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignComputedValueFindUniqueArgs>(args: SelectSubset<T, CampaignComputedValueFindUniqueArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CampaignComputedValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignComputedValueFindUniqueOrThrowArgs} args - Arguments to find a CampaignComputedValue
     * @example
     * // Get one CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignComputedValueFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignComputedValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CampaignComputedValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueFindFirstArgs} args - Arguments to find a CampaignComputedValue
     * @example
     * // Get one CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignComputedValueFindFirstArgs>(args?: SelectSubset<T, CampaignComputedValueFindFirstArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CampaignComputedValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueFindFirstOrThrowArgs} args - Arguments to find a CampaignComputedValue
     * @example
     * // Get one CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignComputedValueFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignComputedValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CampaignComputedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignComputedValues
     * const campaignComputedValues = await prisma.campaignComputedValue.findMany()
     * 
     * // Get first 10 CampaignComputedValues
     * const campaignComputedValues = await prisma.campaignComputedValue.findMany({ take: 10 })
     * 
     * // Only select the `campaignId`
     * const campaignComputedValueWithCampaignIdOnly = await prisma.campaignComputedValue.findMany({ select: { campaignId: true } })
     * 
     */
    findMany<T extends CampaignComputedValueFindManyArgs>(args?: SelectSubset<T, CampaignComputedValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CampaignComputedValue.
     * @param {CampaignComputedValueCreateArgs} args - Arguments to create a CampaignComputedValue.
     * @example
     * // Create one CampaignComputedValue
     * const CampaignComputedValue = await prisma.campaignComputedValue.create({
     *   data: {
     *     // ... data to create a CampaignComputedValue
     *   }
     * })
     * 
     */
    create<T extends CampaignComputedValueCreateArgs>(args: SelectSubset<T, CampaignComputedValueCreateArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CampaignComputedValues.
     * @param {CampaignComputedValueCreateManyArgs} args - Arguments to create many CampaignComputedValues.
     * @example
     * // Create many CampaignComputedValues
     * const campaignComputedValue = await prisma.campaignComputedValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignComputedValueCreateManyArgs>(args?: SelectSubset<T, CampaignComputedValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignComputedValues and returns the data saved in the database.
     * @param {CampaignComputedValueCreateManyAndReturnArgs} args - Arguments to create many CampaignComputedValues.
     * @example
     * // Create many CampaignComputedValues
     * const campaignComputedValue = await prisma.campaignComputedValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignComputedValues and only return the `campaignId`
     * const campaignComputedValueWithCampaignIdOnly = await prisma.campaignComputedValue.createManyAndReturn({
     *   select: { campaignId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignComputedValueCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignComputedValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CampaignComputedValue.
     * @param {CampaignComputedValueDeleteArgs} args - Arguments to delete one CampaignComputedValue.
     * @example
     * // Delete one CampaignComputedValue
     * const CampaignComputedValue = await prisma.campaignComputedValue.delete({
     *   where: {
     *     // ... filter to delete one CampaignComputedValue
     *   }
     * })
     * 
     */
    delete<T extends CampaignComputedValueDeleteArgs>(args: SelectSubset<T, CampaignComputedValueDeleteArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CampaignComputedValue.
     * @param {CampaignComputedValueUpdateArgs} args - Arguments to update one CampaignComputedValue.
     * @example
     * // Update one CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignComputedValueUpdateArgs>(args: SelectSubset<T, CampaignComputedValueUpdateArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CampaignComputedValues.
     * @param {CampaignComputedValueDeleteManyArgs} args - Arguments to filter CampaignComputedValues to delete.
     * @example
     * // Delete a few CampaignComputedValues
     * const { count } = await prisma.campaignComputedValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignComputedValueDeleteManyArgs>(args?: SelectSubset<T, CampaignComputedValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignComputedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignComputedValues
     * const campaignComputedValue = await prisma.campaignComputedValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignComputedValueUpdateManyArgs>(args: SelectSubset<T, CampaignComputedValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignComputedValues and returns the data updated in the database.
     * @param {CampaignComputedValueUpdateManyAndReturnArgs} args - Arguments to update many CampaignComputedValues.
     * @example
     * // Update many CampaignComputedValues
     * const campaignComputedValue = await prisma.campaignComputedValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignComputedValues and only return the `campaignId`
     * const campaignComputedValueWithCampaignIdOnly = await prisma.campaignComputedValue.updateManyAndReturn({
     *   select: { campaignId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignComputedValueUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignComputedValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CampaignComputedValue.
     * @param {CampaignComputedValueUpsertArgs} args - Arguments to update or create a CampaignComputedValue.
     * @example
     * // Update or create a CampaignComputedValue
     * const campaignComputedValue = await prisma.campaignComputedValue.upsert({
     *   create: {
     *     // ... data to create a CampaignComputedValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignComputedValue we want to update
     *   }
     * })
     */
    upsert<T extends CampaignComputedValueUpsertArgs>(args: SelectSubset<T, CampaignComputedValueUpsertArgs<ExtArgs>>): Prisma__CampaignComputedValueClient<$Result.GetResult<Prisma.$CampaignComputedValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CampaignComputedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueCountArgs} args - Arguments to filter CampaignComputedValues to count.
     * @example
     * // Count the number of CampaignComputedValues
     * const count = await prisma.campaignComputedValue.count({
     *   where: {
     *     // ... the filter for the CampaignComputedValues we want to count
     *   }
     * })
    **/
    count<T extends CampaignComputedValueCountArgs>(
      args?: Subset<T, CampaignComputedValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignComputedValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignComputedValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignComputedValueAggregateArgs>(args: Subset<T, CampaignComputedValueAggregateArgs>): Prisma.PrismaPromise<GetCampaignComputedValueAggregateType<T>>

    /**
     * Group by CampaignComputedValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignComputedValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignComputedValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignComputedValueGroupByArgs['orderBy'] }
        : { orderBy?: CampaignComputedValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignComputedValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignComputedValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignComputedValue model
   */
  readonly fields: CampaignComputedValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignComputedValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignComputedValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignComputedValue model
   */ 
  interface CampaignComputedValueFieldRefs {
    readonly campaignId: FieldRef<"CampaignComputedValue", 'String'>
    readonly averageBoost: FieldRef<"CampaignComputedValue", 'Float'>
    readonly totalDistributedInUSD: FieldRef<"CampaignComputedValue", 'Float'>
    readonly forfeitingBoost: FieldRef<"CampaignComputedValue", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CampaignComputedValue findUnique
   */
  export type CampaignComputedValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which CampaignComputedValue to fetch.
     */
    where: CampaignComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue findUniqueOrThrow
   */
  export type CampaignComputedValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which CampaignComputedValue to fetch.
     */
    where: CampaignComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue findFirst
   */
  export type CampaignComputedValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which CampaignComputedValue to fetch.
     */
    where?: CampaignComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignComputedValues to fetch.
     */
    orderBy?: CampaignComputedValueOrderByWithRelationInput | CampaignComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignComputedValues.
     */
    cursor?: CampaignComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignComputedValues.
     */
    distinct?: CampaignComputedValueScalarFieldEnum | CampaignComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue findFirstOrThrow
   */
  export type CampaignComputedValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which CampaignComputedValue to fetch.
     */
    where?: CampaignComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignComputedValues to fetch.
     */
    orderBy?: CampaignComputedValueOrderByWithRelationInput | CampaignComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignComputedValues.
     */
    cursor?: CampaignComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignComputedValues.
     */
    distinct?: CampaignComputedValueScalarFieldEnum | CampaignComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue findMany
   */
  export type CampaignComputedValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which CampaignComputedValues to fetch.
     */
    where?: CampaignComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignComputedValues to fetch.
     */
    orderBy?: CampaignComputedValueOrderByWithRelationInput | CampaignComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignComputedValues.
     */
    cursor?: CampaignComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignComputedValues.
     */
    skip?: number
    distinct?: CampaignComputedValueScalarFieldEnum | CampaignComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue create
   */
  export type CampaignComputedValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignComputedValue.
     */
    data: XOR<CampaignComputedValueCreateInput, CampaignComputedValueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue createMany
   */
  export type CampaignComputedValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignComputedValues.
     */
    data: CampaignComputedValueCreateManyInput | CampaignComputedValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignComputedValue createManyAndReturn
   */
  export type CampaignComputedValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignComputedValues.
     */
    data: CampaignComputedValueCreateManyInput | CampaignComputedValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignComputedValue update
   */
  export type CampaignComputedValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignComputedValue.
     */
    data: XOR<CampaignComputedValueUpdateInput, CampaignComputedValueUncheckedUpdateInput>
    /**
     * Choose, which CampaignComputedValue to update.
     */
    where: CampaignComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue updateMany
   */
  export type CampaignComputedValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignComputedValues.
     */
    data: XOR<CampaignComputedValueUpdateManyMutationInput, CampaignComputedValueUncheckedUpdateManyInput>
    /**
     * Filter which CampaignComputedValues to update
     */
    where?: CampaignComputedValueWhereInput
    /**
     * Limit how many CampaignComputedValues to update.
     */
    limit?: number
  }

  /**
   * CampaignComputedValue updateManyAndReturn
   */
  export type CampaignComputedValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * The data used to update CampaignComputedValues.
     */
    data: XOR<CampaignComputedValueUpdateManyMutationInput, CampaignComputedValueUncheckedUpdateManyInput>
    /**
     * Filter which CampaignComputedValues to update
     */
    where?: CampaignComputedValueWhereInput
    /**
     * Limit how many CampaignComputedValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignComputedValue upsert
   */
  export type CampaignComputedValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignComputedValue to update in case it exists.
     */
    where: CampaignComputedValueWhereUniqueInput
    /**
     * In case the CampaignComputedValue found by the `where` argument doesn't exist, create a new CampaignComputedValue with this data.
     */
    create: XOR<CampaignComputedValueCreateInput, CampaignComputedValueUncheckedCreateInput>
    /**
     * In case the CampaignComputedValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignComputedValueUpdateInput, CampaignComputedValueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue delete
   */
  export type CampaignComputedValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
    /**
     * Filter which CampaignComputedValue to delete.
     */
    where: CampaignComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignComputedValue deleteMany
   */
  export type CampaignComputedValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignComputedValues to delete
     */
    where?: CampaignComputedValueWhereInput
    /**
     * Limit how many CampaignComputedValues to delete.
     */
    limit?: number
  }

  /**
   * CampaignComputedValue without action
   */
  export type CampaignComputedValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignComputedValue
     */
    select?: CampaignComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignComputedValue
     */
    omit?: CampaignComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignComputedValueInclude<ExtArgs> | null
  }


  /**
   * Model UserComputedValue
   */

  export type AggregateUserComputedValue = {
    _count: UserComputedValueCountAggregateOutputType | null
    _avg: UserComputedValueAvgAggregateOutputType | null
    _sum: UserComputedValueSumAggregateOutputType | null
    _min: UserComputedValueMinAggregateOutputType | null
    _max: UserComputedValueMaxAggregateOutputType | null
  }

  export type UserComputedValueAvgAggregateOutputType = {
    boost: number | null
  }

  export type UserComputedValueSumAggregateOutputType = {
    boost: number | null
  }

  export type UserComputedValueMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    address: string | null
    reason: string | null
    boost: number | null
  }

  export type UserComputedValueMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    address: string | null
    reason: string | null
    boost: number | null
  }

  export type UserComputedValueCountAggregateOutputType = {
    id: number
    campaignId: number
    address: number
    reason: number
    boost: number
    _all: number
  }


  export type UserComputedValueAvgAggregateInputType = {
    boost?: true
  }

  export type UserComputedValueSumAggregateInputType = {
    boost?: true
  }

  export type UserComputedValueMinAggregateInputType = {
    id?: true
    campaignId?: true
    address?: true
    reason?: true
    boost?: true
  }

  export type UserComputedValueMaxAggregateInputType = {
    id?: true
    campaignId?: true
    address?: true
    reason?: true
    boost?: true
  }

  export type UserComputedValueCountAggregateInputType = {
    id?: true
    campaignId?: true
    address?: true
    reason?: true
    boost?: true
    _all?: true
  }

  export type UserComputedValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserComputedValue to aggregate.
     */
    where?: UserComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComputedValues to fetch.
     */
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserComputedValues
    **/
    _count?: true | UserComputedValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserComputedValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserComputedValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserComputedValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserComputedValueMaxAggregateInputType
  }

  export type GetUserComputedValueAggregateType<T extends UserComputedValueAggregateArgs> = {
        [P in keyof T & keyof AggregateUserComputedValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserComputedValue[P]>
      : GetScalarType<T[P], AggregateUserComputedValue[P]>
  }




  export type UserComputedValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserComputedValueWhereInput
    orderBy?: UserComputedValueOrderByWithAggregationInput | UserComputedValueOrderByWithAggregationInput[]
    by: UserComputedValueScalarFieldEnum[] | UserComputedValueScalarFieldEnum
    having?: UserComputedValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserComputedValueCountAggregateInputType | true
    _avg?: UserComputedValueAvgAggregateInputType
    _sum?: UserComputedValueSumAggregateInputType
    _min?: UserComputedValueMinAggregateInputType
    _max?: UserComputedValueMaxAggregateInputType
  }

  export type UserComputedValueGroupByOutputType = {
    id: string
    campaignId: string
    address: string
    reason: string
    boost: number | null
    _count: UserComputedValueCountAggregateOutputType | null
    _avg: UserComputedValueAvgAggregateOutputType | null
    _sum: UserComputedValueSumAggregateOutputType | null
    _min: UserComputedValueMinAggregateOutputType | null
    _max: UserComputedValueMaxAggregateOutputType | null
  }

  type GetUserComputedValueGroupByPayload<T extends UserComputedValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserComputedValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserComputedValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserComputedValueGroupByOutputType[P]>
            : GetScalarType<T[P], UserComputedValueGroupByOutputType[P]>
        }
      >
    >


  export type UserComputedValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    address?: boolean
    reason?: boolean
    boost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }, ExtArgs["result"]["userComputedValue"]>

  export type UserComputedValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    address?: boolean
    reason?: boolean
    boost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }, ExtArgs["result"]["userComputedValue"]>

  export type UserComputedValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    address?: boolean
    reason?: boolean
    boost?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }, ExtArgs["result"]["userComputedValue"]>

  export type UserComputedValueSelectScalar = {
    id?: boolean
    campaignId?: boolean
    address?: boolean
    reason?: boolean
    boost?: boolean
  }

  export type UserComputedValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "address" | "reason" | "boost", ExtArgs["result"]["userComputedValue"]>
  export type UserComputedValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }
  export type UserComputedValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }
  export type UserComputedValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    User?: boolean | UserComputedValue$UserArgs<ExtArgs>
  }

  export type $UserComputedValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserComputedValue"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      address: string
      reason: string
      boost: number | null
    }, ExtArgs["result"]["userComputedValue"]>
    composites: {}
  }

  type UserComputedValueGetPayload<S extends boolean | null | undefined | UserComputedValueDefaultArgs> = $Result.GetResult<Prisma.$UserComputedValuePayload, S>

  type UserComputedValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserComputedValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserComputedValueCountAggregateInputType | true
    }

  export interface UserComputedValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserComputedValue'], meta: { name: 'UserComputedValue' } }
    /**
     * Find zero or one UserComputedValue that matches the filter.
     * @param {UserComputedValueFindUniqueArgs} args - Arguments to find a UserComputedValue
     * @example
     * // Get one UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserComputedValueFindUniqueArgs>(args: SelectSubset<T, UserComputedValueFindUniqueArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserComputedValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserComputedValueFindUniqueOrThrowArgs} args - Arguments to find a UserComputedValue
     * @example
     * // Get one UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserComputedValueFindUniqueOrThrowArgs>(args: SelectSubset<T, UserComputedValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserComputedValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueFindFirstArgs} args - Arguments to find a UserComputedValue
     * @example
     * // Get one UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserComputedValueFindFirstArgs>(args?: SelectSubset<T, UserComputedValueFindFirstArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserComputedValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueFindFirstOrThrowArgs} args - Arguments to find a UserComputedValue
     * @example
     * // Get one UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserComputedValueFindFirstOrThrowArgs>(args?: SelectSubset<T, UserComputedValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserComputedValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserComputedValues
     * const userComputedValues = await prisma.userComputedValue.findMany()
     * 
     * // Get first 10 UserComputedValues
     * const userComputedValues = await prisma.userComputedValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userComputedValueWithIdOnly = await prisma.userComputedValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserComputedValueFindManyArgs>(args?: SelectSubset<T, UserComputedValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserComputedValue.
     * @param {UserComputedValueCreateArgs} args - Arguments to create a UserComputedValue.
     * @example
     * // Create one UserComputedValue
     * const UserComputedValue = await prisma.userComputedValue.create({
     *   data: {
     *     // ... data to create a UserComputedValue
     *   }
     * })
     * 
     */
    create<T extends UserComputedValueCreateArgs>(args: SelectSubset<T, UserComputedValueCreateArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserComputedValues.
     * @param {UserComputedValueCreateManyArgs} args - Arguments to create many UserComputedValues.
     * @example
     * // Create many UserComputedValues
     * const userComputedValue = await prisma.userComputedValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserComputedValueCreateManyArgs>(args?: SelectSubset<T, UserComputedValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserComputedValues and returns the data saved in the database.
     * @param {UserComputedValueCreateManyAndReturnArgs} args - Arguments to create many UserComputedValues.
     * @example
     * // Create many UserComputedValues
     * const userComputedValue = await prisma.userComputedValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserComputedValues and only return the `id`
     * const userComputedValueWithIdOnly = await prisma.userComputedValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserComputedValueCreateManyAndReturnArgs>(args?: SelectSubset<T, UserComputedValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserComputedValue.
     * @param {UserComputedValueDeleteArgs} args - Arguments to delete one UserComputedValue.
     * @example
     * // Delete one UserComputedValue
     * const UserComputedValue = await prisma.userComputedValue.delete({
     *   where: {
     *     // ... filter to delete one UserComputedValue
     *   }
     * })
     * 
     */
    delete<T extends UserComputedValueDeleteArgs>(args: SelectSubset<T, UserComputedValueDeleteArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserComputedValue.
     * @param {UserComputedValueUpdateArgs} args - Arguments to update one UserComputedValue.
     * @example
     * // Update one UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserComputedValueUpdateArgs>(args: SelectSubset<T, UserComputedValueUpdateArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserComputedValues.
     * @param {UserComputedValueDeleteManyArgs} args - Arguments to filter UserComputedValues to delete.
     * @example
     * // Delete a few UserComputedValues
     * const { count } = await prisma.userComputedValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserComputedValueDeleteManyArgs>(args?: SelectSubset<T, UserComputedValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserComputedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserComputedValues
     * const userComputedValue = await prisma.userComputedValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserComputedValueUpdateManyArgs>(args: SelectSubset<T, UserComputedValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserComputedValues and returns the data updated in the database.
     * @param {UserComputedValueUpdateManyAndReturnArgs} args - Arguments to update many UserComputedValues.
     * @example
     * // Update many UserComputedValues
     * const userComputedValue = await prisma.userComputedValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserComputedValues and only return the `id`
     * const userComputedValueWithIdOnly = await prisma.userComputedValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserComputedValueUpdateManyAndReturnArgs>(args: SelectSubset<T, UserComputedValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserComputedValue.
     * @param {UserComputedValueUpsertArgs} args - Arguments to update or create a UserComputedValue.
     * @example
     * // Update or create a UserComputedValue
     * const userComputedValue = await prisma.userComputedValue.upsert({
     *   create: {
     *     // ... data to create a UserComputedValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserComputedValue we want to update
     *   }
     * })
     */
    upsert<T extends UserComputedValueUpsertArgs>(args: SelectSubset<T, UserComputedValueUpsertArgs<ExtArgs>>): Prisma__UserComputedValueClient<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserComputedValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueCountArgs} args - Arguments to filter UserComputedValues to count.
     * @example
     * // Count the number of UserComputedValues
     * const count = await prisma.userComputedValue.count({
     *   where: {
     *     // ... the filter for the UserComputedValues we want to count
     *   }
     * })
    **/
    count<T extends UserComputedValueCountArgs>(
      args?: Subset<T, UserComputedValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserComputedValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserComputedValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserComputedValueAggregateArgs>(args: Subset<T, UserComputedValueAggregateArgs>): Prisma.PrismaPromise<GetUserComputedValueAggregateType<T>>

    /**
     * Group by UserComputedValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserComputedValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserComputedValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserComputedValueGroupByArgs['orderBy'] }
        : { orderBy?: UserComputedValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserComputedValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserComputedValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserComputedValue model
   */
  readonly fields: UserComputedValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserComputedValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserComputedValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserComputedValue$UserArgs<ExtArgs> = {}>(args?: Subset<T, UserComputedValue$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserComputedValue model
   */ 
  interface UserComputedValueFieldRefs {
    readonly id: FieldRef<"UserComputedValue", 'String'>
    readonly campaignId: FieldRef<"UserComputedValue", 'String'>
    readonly address: FieldRef<"UserComputedValue", 'String'>
    readonly reason: FieldRef<"UserComputedValue", 'String'>
    readonly boost: FieldRef<"UserComputedValue", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UserComputedValue findUnique
   */
  export type UserComputedValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which UserComputedValue to fetch.
     */
    where: UserComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue findUniqueOrThrow
   */
  export type UserComputedValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which UserComputedValue to fetch.
     */
    where: UserComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue findFirst
   */
  export type UserComputedValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which UserComputedValue to fetch.
     */
    where?: UserComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComputedValues to fetch.
     */
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserComputedValues.
     */
    cursor?: UserComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserComputedValues.
     */
    distinct?: UserComputedValueScalarFieldEnum | UserComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue findFirstOrThrow
   */
  export type UserComputedValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which UserComputedValue to fetch.
     */
    where?: UserComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComputedValues to fetch.
     */
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserComputedValues.
     */
    cursor?: UserComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComputedValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserComputedValues.
     */
    distinct?: UserComputedValueScalarFieldEnum | UserComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue findMany
   */
  export type UserComputedValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter, which UserComputedValues to fetch.
     */
    where?: UserComputedValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComputedValues to fetch.
     */
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserComputedValues.
     */
    cursor?: UserComputedValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComputedValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComputedValues.
     */
    skip?: number
    distinct?: UserComputedValueScalarFieldEnum | UserComputedValueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue create
   */
  export type UserComputedValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * The data needed to create a UserComputedValue.
     */
    data: XOR<UserComputedValueCreateInput, UserComputedValueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue createMany
   */
  export type UserComputedValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserComputedValues.
     */
    data: UserComputedValueCreateManyInput | UserComputedValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserComputedValue createManyAndReturn
   */
  export type UserComputedValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * The data used to create many UserComputedValues.
     */
    data: UserComputedValueCreateManyInput | UserComputedValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserComputedValue update
   */
  export type UserComputedValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * The data needed to update a UserComputedValue.
     */
    data: XOR<UserComputedValueUpdateInput, UserComputedValueUncheckedUpdateInput>
    /**
     * Choose, which UserComputedValue to update.
     */
    where: UserComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue updateMany
   */
  export type UserComputedValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserComputedValues.
     */
    data: XOR<UserComputedValueUpdateManyMutationInput, UserComputedValueUncheckedUpdateManyInput>
    /**
     * Filter which UserComputedValues to update
     */
    where?: UserComputedValueWhereInput
    /**
     * Limit how many UserComputedValues to update.
     */
    limit?: number
  }

  /**
   * UserComputedValue updateManyAndReturn
   */
  export type UserComputedValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * The data used to update UserComputedValues.
     */
    data: XOR<UserComputedValueUpdateManyMutationInput, UserComputedValueUncheckedUpdateManyInput>
    /**
     * Filter which UserComputedValues to update
     */
    where?: UserComputedValueWhereInput
    /**
     * Limit how many UserComputedValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserComputedValue upsert
   */
  export type UserComputedValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * The filter to search for the UserComputedValue to update in case it exists.
     */
    where: UserComputedValueWhereUniqueInput
    /**
     * In case the UserComputedValue found by the `where` argument doesn't exist, create a new UserComputedValue with this data.
     */
    create: XOR<UserComputedValueCreateInput, UserComputedValueUncheckedCreateInput>
    /**
     * In case the UserComputedValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserComputedValueUpdateInput, UserComputedValueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue delete
   */
  export type UserComputedValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    /**
     * Filter which UserComputedValue to delete.
     */
    where: UserComputedValueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserComputedValue deleteMany
   */
  export type UserComputedValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserComputedValues to delete
     */
    where?: UserComputedValueWhereInput
    /**
     * Limit how many UserComputedValues to delete.
     */
    limit?: number
  }

  /**
   * UserComputedValue.User
   */
  export type UserComputedValue$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserComputedValue without action
   */
  export type UserComputedValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
  }


  /**
   * Model Chain
   */

  export type AggregateChain = {
    _count: ChainCountAggregateOutputType | null
    _avg: ChainAvgAggregateOutputType | null
    _sum: ChainSumAggregateOutputType | null
    _min: ChainMinAggregateOutputType | null
    _max: ChainMaxAggregateOutputType | null
  }

  export type ChainAvgAggregateOutputType = {
    id: number | null
  }

  export type ChainSumAggregateOutputType = {
    id: number | null
  }

  export type ChainMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
  }

  export type ChainMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
  }

  export type ChainCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    _all: number
  }


  export type ChainAvgAggregateInputType = {
    id?: true
  }

  export type ChainSumAggregateInputType = {
    id?: true
  }

  export type ChainMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
  }

  export type ChainMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
  }

  export type ChainCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    _all?: true
  }

  export type ChainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chain to aggregate.
     */
    where?: ChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chains to fetch.
     */
    orderBy?: ChainOrderByWithRelationInput | ChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chains
    **/
    _count?: true | ChainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChainMaxAggregateInputType
  }

  export type GetChainAggregateType<T extends ChainAggregateArgs> = {
        [P in keyof T & keyof AggregateChain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChain[P]>
      : GetScalarType<T[P], AggregateChain[P]>
  }




  export type ChainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChainWhereInput
    orderBy?: ChainOrderByWithAggregationInput | ChainOrderByWithAggregationInput[]
    by: ChainScalarFieldEnum[] | ChainScalarFieldEnum
    having?: ChainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChainCountAggregateInputType | true
    _avg?: ChainAvgAggregateInputType
    _sum?: ChainSumAggregateInputType
    _min?: ChainMinAggregateInputType
    _max?: ChainMaxAggregateInputType
  }

  export type ChainGroupByOutputType = {
    id: number
    name: string
    icon: string
    _count: ChainCountAggregateOutputType | null
    _avg: ChainAvgAggregateOutputType | null
    _sum: ChainSumAggregateOutputType | null
    _min: ChainMinAggregateOutputType | null
    _max: ChainMaxAggregateOutputType | null
  }

  type GetChainGroupByPayload<T extends ChainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChainGroupByOutputType[P]>
            : GetScalarType<T[P], ChainGroupByOutputType[P]>
        }
      >
    >


  export type ChainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    Explorer?: boolean | Chain$ExplorerArgs<ExtArgs>
    Campaigns?: boolean | Chain$CampaignsArgs<ExtArgs>
    Distribution?: boolean | Chain$DistributionArgs<ExtArgs>
    Token?: boolean | Chain$TokenArgs<ExtArgs>
    Opportunity?: boolean | Chain$OpportunityArgs<ExtArgs>
    MerklRoot?: boolean | Chain$MerklRootArgs<ExtArgs>
    Blacklist?: boolean | Chain$BlacklistArgs<ExtArgs>
    Dump?: boolean | Chain$DumpArgs<ExtArgs>
    _count?: boolean | ChainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chain"]>

  export type ChainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
  }, ExtArgs["result"]["chain"]>

  export type ChainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
  }, ExtArgs["result"]["chain"]>

  export type ChainSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
  }

  export type ChainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon", ExtArgs["result"]["chain"]>
  export type ChainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Explorer?: boolean | Chain$ExplorerArgs<ExtArgs>
    Campaigns?: boolean | Chain$CampaignsArgs<ExtArgs>
    Distribution?: boolean | Chain$DistributionArgs<ExtArgs>
    Token?: boolean | Chain$TokenArgs<ExtArgs>
    Opportunity?: boolean | Chain$OpportunityArgs<ExtArgs>
    MerklRoot?: boolean | Chain$MerklRootArgs<ExtArgs>
    Blacklist?: boolean | Chain$BlacklistArgs<ExtArgs>
    Dump?: boolean | Chain$DumpArgs<ExtArgs>
    _count?: boolean | ChainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chain"
    objects: {
      Explorer: Prisma.$ExplorerPayload<ExtArgs>[]
      Campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      Distribution: Prisma.$CampaignPayload<ExtArgs>[]
      Token: Prisma.$TokenPayload<ExtArgs>[]
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>[]
      MerklRoot: Prisma.$MerklRootPayload<ExtArgs>[]
      Blacklist: Prisma.$BlacklistPayload<ExtArgs>[]
      Dump: Prisma.$DumpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string
    }, ExtArgs["result"]["chain"]>
    composites: {}
  }

  type ChainGetPayload<S extends boolean | null | undefined | ChainDefaultArgs> = $Result.GetResult<Prisma.$ChainPayload, S>

  type ChainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ChainCountAggregateInputType | true
    }

  export interface ChainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chain'], meta: { name: 'Chain' } }
    /**
     * Find zero or one Chain that matches the filter.
     * @param {ChainFindUniqueArgs} args - Arguments to find a Chain
     * @example
     * // Get one Chain
     * const chain = await prisma.chain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChainFindUniqueArgs>(args: SelectSubset<T, ChainFindUniqueArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChainFindUniqueOrThrowArgs} args - Arguments to find a Chain
     * @example
     * // Get one Chain
     * const chain = await prisma.chain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChainFindUniqueOrThrowArgs>(args: SelectSubset<T, ChainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainFindFirstArgs} args - Arguments to find a Chain
     * @example
     * // Get one Chain
     * const chain = await prisma.chain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChainFindFirstArgs>(args?: SelectSubset<T, ChainFindFirstArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainFindFirstOrThrowArgs} args - Arguments to find a Chain
     * @example
     * // Get one Chain
     * const chain = await prisma.chain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChainFindFirstOrThrowArgs>(args?: SelectSubset<T, ChainFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chains
     * const chains = await prisma.chain.findMany()
     * 
     * // Get first 10 Chains
     * const chains = await prisma.chain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chainWithIdOnly = await prisma.chain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChainFindManyArgs>(args?: SelectSubset<T, ChainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chain.
     * @param {ChainCreateArgs} args - Arguments to create a Chain.
     * @example
     * // Create one Chain
     * const Chain = await prisma.chain.create({
     *   data: {
     *     // ... data to create a Chain
     *   }
     * })
     * 
     */
    create<T extends ChainCreateArgs>(args: SelectSubset<T, ChainCreateArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chains.
     * @param {ChainCreateManyArgs} args - Arguments to create many Chains.
     * @example
     * // Create many Chains
     * const chain = await prisma.chain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChainCreateManyArgs>(args?: SelectSubset<T, ChainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chains and returns the data saved in the database.
     * @param {ChainCreateManyAndReturnArgs} args - Arguments to create many Chains.
     * @example
     * // Create many Chains
     * const chain = await prisma.chain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chains and only return the `id`
     * const chainWithIdOnly = await prisma.chain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChainCreateManyAndReturnArgs>(args?: SelectSubset<T, ChainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chain.
     * @param {ChainDeleteArgs} args - Arguments to delete one Chain.
     * @example
     * // Delete one Chain
     * const Chain = await prisma.chain.delete({
     *   where: {
     *     // ... filter to delete one Chain
     *   }
     * })
     * 
     */
    delete<T extends ChainDeleteArgs>(args: SelectSubset<T, ChainDeleteArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chain.
     * @param {ChainUpdateArgs} args - Arguments to update one Chain.
     * @example
     * // Update one Chain
     * const chain = await prisma.chain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChainUpdateArgs>(args: SelectSubset<T, ChainUpdateArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chains.
     * @param {ChainDeleteManyArgs} args - Arguments to filter Chains to delete.
     * @example
     * // Delete a few Chains
     * const { count } = await prisma.chain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChainDeleteManyArgs>(args?: SelectSubset<T, ChainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chains
     * const chain = await prisma.chain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChainUpdateManyArgs>(args: SelectSubset<T, ChainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chains and returns the data updated in the database.
     * @param {ChainUpdateManyAndReturnArgs} args - Arguments to update many Chains.
     * @example
     * // Update many Chains
     * const chain = await prisma.chain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chains and only return the `id`
     * const chainWithIdOnly = await prisma.chain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChainUpdateManyAndReturnArgs>(args: SelectSubset<T, ChainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chain.
     * @param {ChainUpsertArgs} args - Arguments to update or create a Chain.
     * @example
     * // Update or create a Chain
     * const chain = await prisma.chain.upsert({
     *   create: {
     *     // ... data to create a Chain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chain we want to update
     *   }
     * })
     */
    upsert<T extends ChainUpsertArgs>(args: SelectSubset<T, ChainUpsertArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainCountArgs} args - Arguments to filter Chains to count.
     * @example
     * // Count the number of Chains
     * const count = await prisma.chain.count({
     *   where: {
     *     // ... the filter for the Chains we want to count
     *   }
     * })
    **/
    count<T extends ChainCountArgs>(
      args?: Subset<T, ChainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChainAggregateArgs>(args: Subset<T, ChainAggregateArgs>): Prisma.PrismaPromise<GetChainAggregateType<T>>

    /**
     * Group by Chain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChainGroupByArgs['orderBy'] }
        : { orderBy?: ChainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chain model
   */
  readonly fields: ChainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Explorer<T extends Chain$ExplorerArgs<ExtArgs> = {}>(args?: Subset<T, Chain$ExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Campaigns<T extends Chain$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Chain$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Distribution<T extends Chain$DistributionArgs<ExtArgs> = {}>(args?: Subset<T, Chain$DistributionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Token<T extends Chain$TokenArgs<ExtArgs> = {}>(args?: Subset<T, Chain$TokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Opportunity<T extends Chain$OpportunityArgs<ExtArgs> = {}>(args?: Subset<T, Chain$OpportunityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    MerklRoot<T extends Chain$MerklRootArgs<ExtArgs> = {}>(args?: Subset<T, Chain$MerklRootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Blacklist<T extends Chain$BlacklistArgs<ExtArgs> = {}>(args?: Subset<T, Chain$BlacklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Dump<T extends Chain$DumpArgs<ExtArgs> = {}>(args?: Subset<T, Chain$DumpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chain model
   */ 
  interface ChainFieldRefs {
    readonly id: FieldRef<"Chain", 'Int'>
    readonly name: FieldRef<"Chain", 'String'>
    readonly icon: FieldRef<"Chain", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chain findUnique
   */
  export type ChainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter, which Chain to fetch.
     */
    where: ChainWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain findUniqueOrThrow
   */
  export type ChainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter, which Chain to fetch.
     */
    where: ChainWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain findFirst
   */
  export type ChainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter, which Chain to fetch.
     */
    where?: ChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chains to fetch.
     */
    orderBy?: ChainOrderByWithRelationInput | ChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chains.
     */
    cursor?: ChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chains.
     */
    distinct?: ChainScalarFieldEnum | ChainScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain findFirstOrThrow
   */
  export type ChainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter, which Chain to fetch.
     */
    where?: ChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chains to fetch.
     */
    orderBy?: ChainOrderByWithRelationInput | ChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chains.
     */
    cursor?: ChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chains.
     */
    distinct?: ChainScalarFieldEnum | ChainScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain findMany
   */
  export type ChainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter, which Chains to fetch.
     */
    where?: ChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chains to fetch.
     */
    orderBy?: ChainOrderByWithRelationInput | ChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chains.
     */
    cursor?: ChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chains.
     */
    skip?: number
    distinct?: ChainScalarFieldEnum | ChainScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain create
   */
  export type ChainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * The data needed to create a Chain.
     */
    data: XOR<ChainCreateInput, ChainUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain createMany
   */
  export type ChainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chains.
     */
    data: ChainCreateManyInput | ChainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chain createManyAndReturn
   */
  export type ChainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * The data used to create many Chains.
     */
    data: ChainCreateManyInput | ChainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chain update
   */
  export type ChainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * The data needed to update a Chain.
     */
    data: XOR<ChainUpdateInput, ChainUncheckedUpdateInput>
    /**
     * Choose, which Chain to update.
     */
    where: ChainWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain updateMany
   */
  export type ChainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chains.
     */
    data: XOR<ChainUpdateManyMutationInput, ChainUncheckedUpdateManyInput>
    /**
     * Filter which Chains to update
     */
    where?: ChainWhereInput
    /**
     * Limit how many Chains to update.
     */
    limit?: number
  }

  /**
   * Chain updateManyAndReturn
   */
  export type ChainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * The data used to update Chains.
     */
    data: XOR<ChainUpdateManyMutationInput, ChainUncheckedUpdateManyInput>
    /**
     * Filter which Chains to update
     */
    where?: ChainWhereInput
    /**
     * Limit how many Chains to update.
     */
    limit?: number
  }

  /**
   * Chain upsert
   */
  export type ChainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * The filter to search for the Chain to update in case it exists.
     */
    where: ChainWhereUniqueInput
    /**
     * In case the Chain found by the `where` argument doesn't exist, create a new Chain with this data.
     */
    create: XOR<ChainCreateInput, ChainUncheckedCreateInput>
    /**
     * In case the Chain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChainUpdateInput, ChainUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain delete
   */
  export type ChainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
    /**
     * Filter which Chain to delete.
     */
    where: ChainWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chain deleteMany
   */
  export type ChainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chains to delete
     */
    where?: ChainWhereInput
    /**
     * Limit how many Chains to delete.
     */
    limit?: number
  }

  /**
   * Chain.Explorer
   */
  export type Chain$ExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    where?: ExplorerWhereInput
    orderBy?: ExplorerOrderByWithRelationInput | ExplorerOrderByWithRelationInput[]
    cursor?: ExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExplorerScalarFieldEnum | ExplorerScalarFieldEnum[]
  }

  /**
   * Chain.Campaigns
   */
  export type Chain$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Chain.Distribution
   */
  export type Chain$DistributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Chain.Token
   */
  export type Chain$TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Chain.Opportunity
   */
  export type Chain$OpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Chain.MerklRoot
   */
  export type Chain$MerklRootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    where?: MerklRootWhereInput
    orderBy?: MerklRootOrderByWithRelationInput | MerklRootOrderByWithRelationInput[]
    cursor?: MerklRootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerklRootScalarFieldEnum | MerklRootScalarFieldEnum[]
  }

  /**
   * Chain.Blacklist
   */
  export type Chain$BlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    cursor?: BlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * Chain.Dump
   */
  export type Chain$DumpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    where?: DumpWhereInput
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    cursor?: DumpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
  }

  /**
   * Chain without action
   */
  export type ChainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chain
     */
    select?: ChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chain
     */
    omit?: ChainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChainInclude<ExtArgs> | null
  }


  /**
   * Model Explorer
   */

  export type AggregateExplorer = {
    _count: ExplorerCountAggregateOutputType | null
    _avg: ExplorerAvgAggregateOutputType | null
    _sum: ExplorerSumAggregateOutputType | null
    _min: ExplorerMinAggregateOutputType | null
    _max: ExplorerMaxAggregateOutputType | null
  }

  export type ExplorerAvgAggregateOutputType = {
    chainId: number | null
  }

  export type ExplorerSumAggregateOutputType = {
    chainId: number | null
  }

  export type ExplorerMinAggregateOutputType = {
    id: string | null
    type: $Enums.ExplorerType | null
    url: string | null
    chainId: number | null
  }

  export type ExplorerMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ExplorerType | null
    url: string | null
    chainId: number | null
  }

  export type ExplorerCountAggregateOutputType = {
    id: number
    type: number
    url: number
    chainId: number
    _all: number
  }


  export type ExplorerAvgAggregateInputType = {
    chainId?: true
  }

  export type ExplorerSumAggregateInputType = {
    chainId?: true
  }

  export type ExplorerMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    chainId?: true
  }

  export type ExplorerMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    chainId?: true
  }

  export type ExplorerCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    chainId?: true
    _all?: true
  }

  export type ExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Explorer to aggregate.
     */
    where?: ExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Explorers to fetch.
     */
    orderBy?: ExplorerOrderByWithRelationInput | ExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Explorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Explorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Explorers
    **/
    _count?: true | ExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExplorerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExplorerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExplorerMaxAggregateInputType
  }

  export type GetExplorerAggregateType<T extends ExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExplorer[P]>
      : GetScalarType<T[P], AggregateExplorer[P]>
  }




  export type ExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExplorerWhereInput
    orderBy?: ExplorerOrderByWithAggregationInput | ExplorerOrderByWithAggregationInput[]
    by: ExplorerScalarFieldEnum[] | ExplorerScalarFieldEnum
    having?: ExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExplorerCountAggregateInputType | true
    _avg?: ExplorerAvgAggregateInputType
    _sum?: ExplorerSumAggregateInputType
    _min?: ExplorerMinAggregateInputType
    _max?: ExplorerMaxAggregateInputType
  }

  export type ExplorerGroupByOutputType = {
    id: string
    type: $Enums.ExplorerType
    url: string
    chainId: number
    _count: ExplorerCountAggregateOutputType | null
    _avg: ExplorerAvgAggregateOutputType | null
    _sum: ExplorerSumAggregateOutputType | null
    _min: ExplorerMinAggregateOutputType | null
    _max: ExplorerMaxAggregateOutputType | null
  }

  type GetExplorerGroupByPayload<T extends ExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], ExplorerGroupByOutputType[P]>
        }
      >
    >


  export type ExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    chainId?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["explorer"]>

  export type ExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    chainId?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["explorer"]>

  export type ExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    chainId?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["explorer"]>

  export type ExplorerSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    chainId?: boolean
  }

  export type ExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "url" | "chainId", ExtArgs["result"]["explorer"]>
  export type ExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }
  export type ExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }
  export type ExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }

  export type $ExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Explorer"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ExplorerType
      url: string
      chainId: number
    }, ExtArgs["result"]["explorer"]>
    composites: {}
  }

  type ExplorerGetPayload<S extends boolean | null | undefined | ExplorerDefaultArgs> = $Result.GetResult<Prisma.$ExplorerPayload, S>

  type ExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ExplorerCountAggregateInputType | true
    }

  export interface ExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Explorer'], meta: { name: 'Explorer' } }
    /**
     * Find zero or one Explorer that matches the filter.
     * @param {ExplorerFindUniqueArgs} args - Arguments to find a Explorer
     * @example
     * // Get one Explorer
     * const explorer = await prisma.explorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExplorerFindUniqueArgs>(args: SelectSubset<T, ExplorerFindUniqueArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Explorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExplorerFindUniqueOrThrowArgs} args - Arguments to find a Explorer
     * @example
     * // Get one Explorer
     * const explorer = await prisma.explorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, ExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Explorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerFindFirstArgs} args - Arguments to find a Explorer
     * @example
     * // Get one Explorer
     * const explorer = await prisma.explorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExplorerFindFirstArgs>(args?: SelectSubset<T, ExplorerFindFirstArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Explorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerFindFirstOrThrowArgs} args - Arguments to find a Explorer
     * @example
     * // Get one Explorer
     * const explorer = await prisma.explorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, ExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Explorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Explorers
     * const explorers = await prisma.explorer.findMany()
     * 
     * // Get first 10 Explorers
     * const explorers = await prisma.explorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const explorerWithIdOnly = await prisma.explorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExplorerFindManyArgs>(args?: SelectSubset<T, ExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Explorer.
     * @param {ExplorerCreateArgs} args - Arguments to create a Explorer.
     * @example
     * // Create one Explorer
     * const Explorer = await prisma.explorer.create({
     *   data: {
     *     // ... data to create a Explorer
     *   }
     * })
     * 
     */
    create<T extends ExplorerCreateArgs>(args: SelectSubset<T, ExplorerCreateArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Explorers.
     * @param {ExplorerCreateManyArgs} args - Arguments to create many Explorers.
     * @example
     * // Create many Explorers
     * const explorer = await prisma.explorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExplorerCreateManyArgs>(args?: SelectSubset<T, ExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Explorers and returns the data saved in the database.
     * @param {ExplorerCreateManyAndReturnArgs} args - Arguments to create many Explorers.
     * @example
     * // Create many Explorers
     * const explorer = await prisma.explorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Explorers and only return the `id`
     * const explorerWithIdOnly = await prisma.explorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, ExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Explorer.
     * @param {ExplorerDeleteArgs} args - Arguments to delete one Explorer.
     * @example
     * // Delete one Explorer
     * const Explorer = await prisma.explorer.delete({
     *   where: {
     *     // ... filter to delete one Explorer
     *   }
     * })
     * 
     */
    delete<T extends ExplorerDeleteArgs>(args: SelectSubset<T, ExplorerDeleteArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Explorer.
     * @param {ExplorerUpdateArgs} args - Arguments to update one Explorer.
     * @example
     * // Update one Explorer
     * const explorer = await prisma.explorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExplorerUpdateArgs>(args: SelectSubset<T, ExplorerUpdateArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Explorers.
     * @param {ExplorerDeleteManyArgs} args - Arguments to filter Explorers to delete.
     * @example
     * // Delete a few Explorers
     * const { count } = await prisma.explorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExplorerDeleteManyArgs>(args?: SelectSubset<T, ExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Explorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Explorers
     * const explorer = await prisma.explorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExplorerUpdateManyArgs>(args: SelectSubset<T, ExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Explorers and returns the data updated in the database.
     * @param {ExplorerUpdateManyAndReturnArgs} args - Arguments to update many Explorers.
     * @example
     * // Update many Explorers
     * const explorer = await prisma.explorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Explorers and only return the `id`
     * const explorerWithIdOnly = await prisma.explorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, ExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Explorer.
     * @param {ExplorerUpsertArgs} args - Arguments to update or create a Explorer.
     * @example
     * // Update or create a Explorer
     * const explorer = await prisma.explorer.upsert({
     *   create: {
     *     // ... data to create a Explorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Explorer we want to update
     *   }
     * })
     */
    upsert<T extends ExplorerUpsertArgs>(args: SelectSubset<T, ExplorerUpsertArgs<ExtArgs>>): Prisma__ExplorerClient<$Result.GetResult<Prisma.$ExplorerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Explorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerCountArgs} args - Arguments to filter Explorers to count.
     * @example
     * // Count the number of Explorers
     * const count = await prisma.explorer.count({
     *   where: {
     *     // ... the filter for the Explorers we want to count
     *   }
     * })
    **/
    count<T extends ExplorerCountArgs>(
      args?: Subset<T, ExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Explorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExplorerAggregateArgs>(args: Subset<T, ExplorerAggregateArgs>): Prisma.PrismaPromise<GetExplorerAggregateType<T>>

    /**
     * Group by Explorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExplorerGroupByArgs['orderBy'] }
        : { orderBy?: ExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Explorer model
   */
  readonly fields: ExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Explorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Explorer model
   */ 
  interface ExplorerFieldRefs {
    readonly id: FieldRef<"Explorer", 'String'>
    readonly type: FieldRef<"Explorer", 'ExplorerType'>
    readonly url: FieldRef<"Explorer", 'String'>
    readonly chainId: FieldRef<"Explorer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Explorer findUnique
   */
  export type ExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter, which Explorer to fetch.
     */
    where: ExplorerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer findUniqueOrThrow
   */
  export type ExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter, which Explorer to fetch.
     */
    where: ExplorerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer findFirst
   */
  export type ExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter, which Explorer to fetch.
     */
    where?: ExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Explorers to fetch.
     */
    orderBy?: ExplorerOrderByWithRelationInput | ExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Explorers.
     */
    cursor?: ExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Explorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Explorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Explorers.
     */
    distinct?: ExplorerScalarFieldEnum | ExplorerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer findFirstOrThrow
   */
  export type ExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter, which Explorer to fetch.
     */
    where?: ExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Explorers to fetch.
     */
    orderBy?: ExplorerOrderByWithRelationInput | ExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Explorers.
     */
    cursor?: ExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Explorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Explorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Explorers.
     */
    distinct?: ExplorerScalarFieldEnum | ExplorerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer findMany
   */
  export type ExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter, which Explorers to fetch.
     */
    where?: ExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Explorers to fetch.
     */
    orderBy?: ExplorerOrderByWithRelationInput | ExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Explorers.
     */
    cursor?: ExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Explorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Explorers.
     */
    skip?: number
    distinct?: ExplorerScalarFieldEnum | ExplorerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer create
   */
  export type ExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a Explorer.
     */
    data: XOR<ExplorerCreateInput, ExplorerUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer createMany
   */
  export type ExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Explorers.
     */
    data: ExplorerCreateManyInput | ExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Explorer createManyAndReturn
   */
  export type ExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many Explorers.
     */
    data: ExplorerCreateManyInput | ExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Explorer update
   */
  export type ExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a Explorer.
     */
    data: XOR<ExplorerUpdateInput, ExplorerUncheckedUpdateInput>
    /**
     * Choose, which Explorer to update.
     */
    where: ExplorerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer updateMany
   */
  export type ExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Explorers.
     */
    data: XOR<ExplorerUpdateManyMutationInput, ExplorerUncheckedUpdateManyInput>
    /**
     * Filter which Explorers to update
     */
    where?: ExplorerWhereInput
    /**
     * Limit how many Explorers to update.
     */
    limit?: number
  }

  /**
   * Explorer updateManyAndReturn
   */
  export type ExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * The data used to update Explorers.
     */
    data: XOR<ExplorerUpdateManyMutationInput, ExplorerUncheckedUpdateManyInput>
    /**
     * Filter which Explorers to update
     */
    where?: ExplorerWhereInput
    /**
     * Limit how many Explorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Explorer upsert
   */
  export type ExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the Explorer to update in case it exists.
     */
    where: ExplorerWhereUniqueInput
    /**
     * In case the Explorer found by the `where` argument doesn't exist, create a new Explorer with this data.
     */
    create: XOR<ExplorerCreateInput, ExplorerUncheckedCreateInput>
    /**
     * In case the Explorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExplorerUpdateInput, ExplorerUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer delete
   */
  export type ExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
    /**
     * Filter which Explorer to delete.
     */
    where: ExplorerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Explorer deleteMany
   */
  export type ExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Explorers to delete
     */
    where?: ExplorerWhereInput
    /**
     * Limit how many Explorers to delete.
     */
    limit?: number
  }

  /**
   * Explorer without action
   */
  export type ExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Explorer
     */
    select?: ExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Explorer
     */
    omit?: ExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExplorerInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    chainId: number | null
    tvl: number | null
    apr: number | null
    dailyRewards: number | null
  }

  export type OpportunitySumAggregateOutputType = {
    chainId: number | null
    tvl: number | null
    apr: number | null
    dailyRewards: number | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    chainId: number | null
    type: string | null
    identifier: string | null
    name: string | null
    description: string | null
    depositUrl: string | null
    explorerAddress: string | null
    status: $Enums.Status | null
    action: $Enums.OpportunityAction | null
    mainProtocolId: string | null
    tvl: number | null
    apr: number | null
    dailyRewards: number | null
    lastCampaignCreatedAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    chainId: number | null
    type: string | null
    identifier: string | null
    name: string | null
    description: string | null
    depositUrl: string | null
    explorerAddress: string | null
    status: $Enums.Status | null
    action: $Enums.OpportunityAction | null
    mainProtocolId: string | null
    tvl: number | null
    apr: number | null
    dailyRewards: number | null
    lastCampaignCreatedAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    chainId: number
    type: number
    identifier: number
    name: number
    description: number
    howToSteps: number
    depositUrl: number
    explorerAddress: number
    status: number
    action: number
    mainProtocolId: number
    tvl: number
    apr: number
    dailyRewards: number
    tags: number
    lastCampaignCreatedAt: number
    manualOverrides: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    chainId?: true
    tvl?: true
    apr?: true
    dailyRewards?: true
  }

  export type OpportunitySumAggregateInputType = {
    chainId?: true
    tvl?: true
    apr?: true
    dailyRewards?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    identifier?: true
    name?: true
    description?: true
    depositUrl?: true
    explorerAddress?: true
    status?: true
    action?: true
    mainProtocolId?: true
    tvl?: true
    apr?: true
    dailyRewards?: true
    lastCampaignCreatedAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    identifier?: true
    name?: true
    description?: true
    depositUrl?: true
    explorerAddress?: true
    status?: true
    action?: true
    mainProtocolId?: true
    tvl?: true
    apr?: true
    dailyRewards?: true
    lastCampaignCreatedAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    identifier?: true
    name?: true
    description?: true
    howToSteps?: true
    depositUrl?: true
    explorerAddress?: true
    status?: true
    action?: true
    mainProtocolId?: true
    tvl?: true
    apr?: true
    dailyRewards?: true
    tags?: true
    lastCampaignCreatedAt?: true
    manualOverrides?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description: string
    howToSteps: string[]
    depositUrl: string | null
    explorerAddress: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId: string | null
    tvl: number
    apr: number
    dailyRewards: number
    tags: string[]
    lastCampaignCreatedAt: Date
    manualOverrides: $Enums.OpportunityManualOverride[]
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    identifier?: boolean
    name?: boolean
    description?: boolean
    howToSteps?: boolean
    depositUrl?: boolean
    explorerAddress?: boolean
    status?: boolean
    action?: boolean
    mainProtocolId?: boolean
    tvl?: boolean
    apr?: boolean
    dailyRewards?: boolean
    tags?: boolean
    lastCampaignCreatedAt?: boolean
    manualOverrides?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Tokens?: boolean | Opportunity$TokensArgs<ExtArgs>
    Campaigns?: boolean | Opportunity$CampaignsArgs<ExtArgs>
    Protocols?: boolean | Opportunity$ProtocolsArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
    TvlRecords?: boolean | Opportunity$TvlRecordsArgs<ExtArgs>
    AprRecords?: boolean | Opportunity$AprRecordsArgs<ExtArgs>
    DailyRewardsRecords?: boolean | Opportunity$DailyRewardsRecordsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    identifier?: boolean
    name?: boolean
    description?: boolean
    howToSteps?: boolean
    depositUrl?: boolean
    explorerAddress?: boolean
    status?: boolean
    action?: boolean
    mainProtocolId?: boolean
    tvl?: boolean
    apr?: boolean
    dailyRewards?: boolean
    tags?: boolean
    lastCampaignCreatedAt?: boolean
    manualOverrides?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    identifier?: boolean
    name?: boolean
    description?: boolean
    howToSteps?: boolean
    depositUrl?: boolean
    explorerAddress?: boolean
    status?: boolean
    action?: boolean
    mainProtocolId?: boolean
    tvl?: boolean
    apr?: boolean
    dailyRewards?: boolean
    tags?: boolean
    lastCampaignCreatedAt?: boolean
    manualOverrides?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    chainId?: boolean
    type?: boolean
    identifier?: boolean
    name?: boolean
    description?: boolean
    howToSteps?: boolean
    depositUrl?: boolean
    explorerAddress?: boolean
    status?: boolean
    action?: boolean
    mainProtocolId?: boolean
    tvl?: boolean
    apr?: boolean
    dailyRewards?: boolean
    tags?: boolean
    lastCampaignCreatedAt?: boolean
    manualOverrides?: boolean
  }

  export type OpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chainId" | "type" | "identifier" | "name" | "description" | "howToSteps" | "depositUrl" | "explorerAddress" | "status" | "action" | "mainProtocolId" | "tvl" | "apr" | "dailyRewards" | "tags" | "lastCampaignCreatedAt" | "manualOverrides", ExtArgs["result"]["opportunity"]>
  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Tokens?: boolean | Opportunity$TokensArgs<ExtArgs>
    Campaigns?: boolean | Opportunity$CampaignsArgs<ExtArgs>
    Protocols?: boolean | Opportunity$ProtocolsArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
    TvlRecords?: boolean | Opportunity$TvlRecordsArgs<ExtArgs>
    AprRecords?: boolean | Opportunity$AprRecordsArgs<ExtArgs>
    DailyRewardsRecords?: boolean | Opportunity$DailyRewardsRecordsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
  }
  export type OpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    MainProtocol?: boolean | Opportunity$MainProtocolArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
      Tokens: Prisma.$TokenPayload<ExtArgs>[]
      Campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      Protocols: Prisma.$ProtocolPayload<ExtArgs>[]
      MainProtocol: Prisma.$ProtocolPayload<ExtArgs> | null
      TvlRecords: Prisma.$TVLRecordPayload<ExtArgs>[]
      AprRecords: Prisma.$AprRecordPayload<ExtArgs>[]
      DailyRewardsRecords: Prisma.$DailyRewardsRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chainId: number
      type: string
      identifier: string
      name: string
      description: string
      howToSteps: string[]
      depositUrl: string | null
      explorerAddress: string | null
      status: $Enums.Status
      action: $Enums.OpportunityAction
      mainProtocolId: string | null
      tvl: number
      apr: number
      dailyRewards: number
      tags: string[]
      lastCampaignCreatedAt: Date
      manualOverrides: $Enums.OpportunityManualOverride[]
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities and returns the data updated in the database.
     * @param {OpportunityUpdateManyAndReturnArgs} args - Arguments to update many Opportunities.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Tokens<T extends Opportunity$TokensArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$TokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Campaigns<T extends Opportunity$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Protocols<T extends Opportunity$ProtocolsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$ProtocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    MainProtocol<T extends Opportunity$MainProtocolArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$MainProtocolArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    TvlRecords<T extends Opportunity$TvlRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$TvlRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AprRecords<T extends Opportunity$AprRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$AprRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DailyRewardsRecords<T extends Opportunity$DailyRewardsRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$DailyRewardsRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */ 
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly chainId: FieldRef<"Opportunity", 'Int'>
    readonly type: FieldRef<"Opportunity", 'String'>
    readonly identifier: FieldRef<"Opportunity", 'String'>
    readonly name: FieldRef<"Opportunity", 'String'>
    readonly description: FieldRef<"Opportunity", 'String'>
    readonly howToSteps: FieldRef<"Opportunity", 'String[]'>
    readonly depositUrl: FieldRef<"Opportunity", 'String'>
    readonly explorerAddress: FieldRef<"Opportunity", 'String'>
    readonly status: FieldRef<"Opportunity", 'Status'>
    readonly action: FieldRef<"Opportunity", 'OpportunityAction'>
    readonly mainProtocolId: FieldRef<"Opportunity", 'String'>
    readonly tvl: FieldRef<"Opportunity", 'Float'>
    readonly apr: FieldRef<"Opportunity", 'Float'>
    readonly dailyRewards: FieldRef<"Opportunity", 'Float'>
    readonly tags: FieldRef<"Opportunity", 'String[]'>
    readonly lastCampaignCreatedAt: FieldRef<"Opportunity", 'DateTime'>
    readonly manualOverrides: FieldRef<"Opportunity", 'OpportunityManualOverride[]'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
  }

  /**
   * Opportunity updateManyAndReturn
   */
  export type OpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to delete.
     */
    limit?: number
  }

  /**
   * Opportunity.Tokens
   */
  export type Opportunity$TokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Opportunity.Campaigns
   */
  export type Opportunity$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Opportunity.Protocols
   */
  export type Opportunity$ProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    where?: ProtocolWhereInput
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    cursor?: ProtocolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * Opportunity.MainProtocol
   */
  export type Opportunity$MainProtocolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    where?: ProtocolWhereInput
  }

  /**
   * Opportunity.TvlRecords
   */
  export type Opportunity$TvlRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    where?: TVLRecordWhereInput
    orderBy?: TVLRecordOrderByWithRelationInput | TVLRecordOrderByWithRelationInput[]
    cursor?: TVLRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TVLRecordScalarFieldEnum | TVLRecordScalarFieldEnum[]
  }

  /**
   * Opportunity.AprRecords
   */
  export type Opportunity$AprRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    where?: AprRecordWhereInput
    orderBy?: AprRecordOrderByWithRelationInput | AprRecordOrderByWithRelationInput[]
    cursor?: AprRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AprRecordScalarFieldEnum | AprRecordScalarFieldEnum[]
  }

  /**
   * Opportunity.DailyRewardsRecords
   */
  export type Opportunity$DailyRewardsRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    where?: DailyRewardsRecordWhereInput
    orderBy?: DailyRewardsRecordOrderByWithRelationInput | DailyRewardsRecordOrderByWithRelationInput[]
    cursor?: DailyRewardsRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRewardsRecordScalarFieldEnum | DailyRewardsRecordScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model Protocol
   */

  export type AggregateProtocol = {
    _count: ProtocolCountAggregateOutputType | null
    _min: ProtocolMinAggregateOutputType | null
    _max: ProtocolMaxAggregateOutputType | null
  }

  export type ProtocolMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    icon: string | null
  }

  export type ProtocolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    icon: string | null
  }

  export type ProtocolCountAggregateOutputType = {
    id: number
    tags: number
    name: number
    description: number
    url: number
    icon: number
    _all: number
  }


  export type ProtocolMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    icon?: true
  }

  export type ProtocolMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    icon?: true
  }

  export type ProtocolCountAggregateInputType = {
    id?: true
    tags?: true
    name?: true
    description?: true
    url?: true
    icon?: true
    _all?: true
  }

  export type ProtocolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocol to aggregate.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Protocols
    **/
    _count?: true | ProtocolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolMaxAggregateInputType
  }

  export type GetProtocolAggregateType<T extends ProtocolAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocol[P]>
      : GetScalarType<T[P], AggregateProtocol[P]>
  }




  export type ProtocolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolWhereInput
    orderBy?: ProtocolOrderByWithAggregationInput | ProtocolOrderByWithAggregationInput[]
    by: ProtocolScalarFieldEnum[] | ProtocolScalarFieldEnum
    having?: ProtocolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolCountAggregateInputType | true
    _min?: ProtocolMinAggregateInputType
    _max?: ProtocolMaxAggregateInputType
  }

  export type ProtocolGroupByOutputType = {
    id: string
    tags: string[]
    name: string
    description: string
    url: string
    icon: string
    _count: ProtocolCountAggregateOutputType | null
    _min: ProtocolMinAggregateOutputType | null
    _max: ProtocolMaxAggregateOutputType | null
  }

  type GetProtocolGroupByPayload<T extends ProtocolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tags?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
    MainOpportunities?: boolean | Protocol$MainOpportunitiesArgs<ExtArgs>
    Opportunities?: boolean | Protocol$OpportunitiesArgs<ExtArgs>
    RewardBreakdown?: boolean | Protocol$RewardBreakdownArgs<ExtArgs>
    _count?: boolean | ProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocol"]>

  export type ProtocolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tags?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
  }, ExtArgs["result"]["protocol"]>

  export type ProtocolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tags?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
  }, ExtArgs["result"]["protocol"]>

  export type ProtocolSelectScalar = {
    id?: boolean
    tags?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
  }

  export type ProtocolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tags" | "name" | "description" | "url" | "icon", ExtArgs["result"]["protocol"]>
  export type ProtocolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MainOpportunities?: boolean | Protocol$MainOpportunitiesArgs<ExtArgs>
    Opportunities?: boolean | Protocol$OpportunitiesArgs<ExtArgs>
    RewardBreakdown?: boolean | Protocol$RewardBreakdownArgs<ExtArgs>
    _count?: boolean | ProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProtocolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProtocolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProtocolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Protocol"
    objects: {
      MainOpportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      Opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      RewardBreakdown: Prisma.$RewardBreakdownPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tags: string[]
      name: string
      description: string
      url: string
      icon: string
    }, ExtArgs["result"]["protocol"]>
    composites: {}
  }

  type ProtocolGetPayload<S extends boolean | null | undefined | ProtocolDefaultArgs> = $Result.GetResult<Prisma.$ProtocolPayload, S>

  type ProtocolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProtocolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProtocolCountAggregateInputType | true
    }

  export interface ProtocolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Protocol'], meta: { name: 'Protocol' } }
    /**
     * Find zero or one Protocol that matches the filter.
     * @param {ProtocolFindUniqueArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolFindUniqueArgs>(args: SelectSubset<T, ProtocolFindUniqueArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Protocol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProtocolFindUniqueOrThrowArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Protocol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindFirstArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolFindFirstArgs>(args?: SelectSubset<T, ProtocolFindFirstArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Protocol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindFirstOrThrowArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Protocols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Protocols
     * const protocols = await prisma.protocol.findMany()
     * 
     * // Get first 10 Protocols
     * const protocols = await prisma.protocol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolWithIdOnly = await prisma.protocol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolFindManyArgs>(args?: SelectSubset<T, ProtocolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Protocol.
     * @param {ProtocolCreateArgs} args - Arguments to create a Protocol.
     * @example
     * // Create one Protocol
     * const Protocol = await prisma.protocol.create({
     *   data: {
     *     // ... data to create a Protocol
     *   }
     * })
     * 
     */
    create<T extends ProtocolCreateArgs>(args: SelectSubset<T, ProtocolCreateArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Protocols.
     * @param {ProtocolCreateManyArgs} args - Arguments to create many Protocols.
     * @example
     * // Create many Protocols
     * const protocol = await prisma.protocol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolCreateManyArgs>(args?: SelectSubset<T, ProtocolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Protocols and returns the data saved in the database.
     * @param {ProtocolCreateManyAndReturnArgs} args - Arguments to create many Protocols.
     * @example
     * // Create many Protocols
     * const protocol = await prisma.protocol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Protocols and only return the `id`
     * const protocolWithIdOnly = await prisma.protocol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Protocol.
     * @param {ProtocolDeleteArgs} args - Arguments to delete one Protocol.
     * @example
     * // Delete one Protocol
     * const Protocol = await prisma.protocol.delete({
     *   where: {
     *     // ... filter to delete one Protocol
     *   }
     * })
     * 
     */
    delete<T extends ProtocolDeleteArgs>(args: SelectSubset<T, ProtocolDeleteArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Protocol.
     * @param {ProtocolUpdateArgs} args - Arguments to update one Protocol.
     * @example
     * // Update one Protocol
     * const protocol = await prisma.protocol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolUpdateArgs>(args: SelectSubset<T, ProtocolUpdateArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Protocols.
     * @param {ProtocolDeleteManyArgs} args - Arguments to filter Protocols to delete.
     * @example
     * // Delete a few Protocols
     * const { count } = await prisma.protocol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolDeleteManyArgs>(args?: SelectSubset<T, ProtocolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Protocols
     * const protocol = await prisma.protocol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolUpdateManyArgs>(args: SelectSubset<T, ProtocolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocols and returns the data updated in the database.
     * @param {ProtocolUpdateManyAndReturnArgs} args - Arguments to update many Protocols.
     * @example
     * // Update many Protocols
     * const protocol = await prisma.protocol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Protocols and only return the `id`
     * const protocolWithIdOnly = await prisma.protocol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProtocolUpdateManyAndReturnArgs>(args: SelectSubset<T, ProtocolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Protocol.
     * @param {ProtocolUpsertArgs} args - Arguments to update or create a Protocol.
     * @example
     * // Update or create a Protocol
     * const protocol = await prisma.protocol.upsert({
     *   create: {
     *     // ... data to create a Protocol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Protocol we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolUpsertArgs>(args: SelectSubset<T, ProtocolUpsertArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Protocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolCountArgs} args - Arguments to filter Protocols to count.
     * @example
     * // Count the number of Protocols
     * const count = await prisma.protocol.count({
     *   where: {
     *     // ... the filter for the Protocols we want to count
     *   }
     * })
    **/
    count<T extends ProtocolCountArgs>(
      args?: Subset<T, ProtocolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Protocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolAggregateArgs>(args: Subset<T, ProtocolAggregateArgs>): Prisma.PrismaPromise<GetProtocolAggregateType<T>>

    /**
     * Group by Protocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Protocol model
   */
  readonly fields: ProtocolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Protocol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MainOpportunities<T extends Protocol$MainOpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$MainOpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Opportunities<T extends Protocol$OpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$OpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RewardBreakdown<T extends Protocol$RewardBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$RewardBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Protocol model
   */ 
  interface ProtocolFieldRefs {
    readonly id: FieldRef<"Protocol", 'String'>
    readonly tags: FieldRef<"Protocol", 'String[]'>
    readonly name: FieldRef<"Protocol", 'String'>
    readonly description: FieldRef<"Protocol", 'String'>
    readonly url: FieldRef<"Protocol", 'String'>
    readonly icon: FieldRef<"Protocol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Protocol findUnique
   */
  export type ProtocolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where: ProtocolWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol findUniqueOrThrow
   */
  export type ProtocolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where: ProtocolWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol findFirst
   */
  export type ProtocolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocols.
     */
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol findFirstOrThrow
   */
  export type ProtocolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocols.
     */
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol findMany
   */
  export type ProtocolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocols to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol create
   */
  export type ProtocolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The data needed to create a Protocol.
     */
    data: XOR<ProtocolCreateInput, ProtocolUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol createMany
   */
  export type ProtocolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Protocols.
     */
    data: ProtocolCreateManyInput | ProtocolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Protocol createManyAndReturn
   */
  export type ProtocolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * The data used to create many Protocols.
     */
    data: ProtocolCreateManyInput | ProtocolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Protocol update
   */
  export type ProtocolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The data needed to update a Protocol.
     */
    data: XOR<ProtocolUpdateInput, ProtocolUncheckedUpdateInput>
    /**
     * Choose, which Protocol to update.
     */
    where: ProtocolWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol updateMany
   */
  export type ProtocolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Protocols.
     */
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyInput>
    /**
     * Filter which Protocols to update
     */
    where?: ProtocolWhereInput
    /**
     * Limit how many Protocols to update.
     */
    limit?: number
  }

  /**
   * Protocol updateManyAndReturn
   */
  export type ProtocolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * The data used to update Protocols.
     */
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyInput>
    /**
     * Filter which Protocols to update
     */
    where?: ProtocolWhereInput
    /**
     * Limit how many Protocols to update.
     */
    limit?: number
  }

  /**
   * Protocol upsert
   */
  export type ProtocolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The filter to search for the Protocol to update in case it exists.
     */
    where: ProtocolWhereUniqueInput
    /**
     * In case the Protocol found by the `where` argument doesn't exist, create a new Protocol with this data.
     */
    create: XOR<ProtocolCreateInput, ProtocolUncheckedCreateInput>
    /**
     * In case the Protocol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolUpdateInput, ProtocolUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol delete
   */
  export type ProtocolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter which Protocol to delete.
     */
    where: ProtocolWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Protocol deleteMany
   */
  export type ProtocolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocols to delete
     */
    where?: ProtocolWhereInput
    /**
     * Limit how many Protocols to delete.
     */
    limit?: number
  }

  /**
   * Protocol.MainOpportunities
   */
  export type Protocol$MainOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Protocol.Opportunities
   */
  export type Protocol$OpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Protocol.RewardBreakdown
   */
  export type Protocol$RewardBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    where?: RewardBreakdownWhereInput
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    cursor?: RewardBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
  }

  /**
   * Protocol without action
   */
  export type ProtocolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    chainId: number | null
    decimals: number | null
    price: number | null
  }

  export type TokenSumAggregateOutputType = {
    chainId: number | null
    decimals: number | null
    price: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    name: string | null
    chainId: number | null
    address: string | null
    decimals: number | null
    symbol: string | null
    displaySymbol: string | null
    icon: string | null
    verified: boolean | null
    isTest: boolean | null
    isPoint: boolean | null
    isPreTGE: boolean | null
    isNative: boolean | null
    price: number | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    chainId: number | null
    address: string | null
    decimals: number | null
    symbol: string | null
    displaySymbol: string | null
    icon: string | null
    verified: boolean | null
    isTest: boolean | null
    isPoint: boolean | null
    isPreTGE: boolean | null
    isNative: boolean | null
    price: number | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    name: number
    chainId: number
    address: number
    decimals: number
    symbol: number
    displaySymbol: number
    icon: number
    verified: number
    isTest: number
    isPoint: number
    isPreTGE: number
    isNative: number
    price: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    chainId?: true
    decimals?: true
    price?: true
  }

  export type TokenSumAggregateInputType = {
    chainId?: true
    decimals?: true
    price?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    name?: true
    chainId?: true
    address?: true
    decimals?: true
    symbol?: true
    displaySymbol?: true
    icon?: true
    verified?: true
    isTest?: true
    isPoint?: true
    isPreTGE?: true
    isNative?: true
    price?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    name?: true
    chainId?: true
    address?: true
    decimals?: true
    symbol?: true
    displaySymbol?: true
    icon?: true
    verified?: true
    isTest?: true
    isPoint?: true
    isPreTGE?: true
    isNative?: true
    price?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    name?: true
    chainId?: true
    address?: true
    decimals?: true
    symbol?: true
    displaySymbol?: true
    icon?: true
    verified?: true
    isTest?: true
    isPoint?: true
    isPreTGE?: true
    isNative?: true
    price?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    name: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol: string
    icon: string
    verified: boolean
    isTest: boolean
    isPoint: boolean
    isPreTGE: boolean
    isNative: boolean
    price: number | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    chainId?: boolean
    address?: boolean
    decimals?: boolean
    symbol?: boolean
    displaySymbol?: boolean
    icon?: boolean
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Opportunity?: boolean | Token$OpportunityArgs<ExtArgs>
    Campaigns?: boolean | Token$CampaignsArgs<ExtArgs>
    Reward?: boolean | Token$RewardArgs<ExtArgs>
    DumpTo?: boolean | Token$DumpToArgs<ExtArgs>
    DumpFrom?: boolean | Token$DumpFromArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    chainId?: boolean
    address?: boolean
    decimals?: boolean
    symbol?: boolean
    displaySymbol?: boolean
    icon?: boolean
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    chainId?: boolean
    address?: boolean
    decimals?: boolean
    symbol?: boolean
    displaySymbol?: boolean
    icon?: boolean
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    name?: boolean
    chainId?: boolean
    address?: boolean
    decimals?: boolean
    symbol?: boolean
    displaySymbol?: boolean
    icon?: boolean
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "chainId" | "address" | "decimals" | "symbol" | "displaySymbol" | "icon" | "verified" | "isTest" | "isPoint" | "isPreTGE" | "isNative" | "price", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Opportunity?: boolean | Token$OpportunityArgs<ExtArgs>
    Campaigns?: boolean | Token$CampaignsArgs<ExtArgs>
    Reward?: boolean | Token$RewardArgs<ExtArgs>
    DumpTo?: boolean | Token$DumpToArgs<ExtArgs>
    DumpFrom?: boolean | Token$DumpFromArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>[]
      Campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      Reward: Prisma.$RewardPayload<ExtArgs>[]
      DumpTo: Prisma.$DumpPayload<ExtArgs>[]
      DumpFrom: Prisma.$DumpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      chainId: number
      address: string
      decimals: number
      symbol: string
      displaySymbol: string
      icon: string
      verified: boolean
      isTest: boolean
      isPoint: boolean
      isPreTGE: boolean
      isNative: boolean
      price: number | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Opportunity<T extends Token$OpportunityArgs<ExtArgs> = {}>(args?: Subset<T, Token$OpportunityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Campaigns<T extends Token$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Token$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Reward<T extends Token$RewardArgs<ExtArgs> = {}>(args?: Subset<T, Token$RewardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DumpTo<T extends Token$DumpToArgs<ExtArgs> = {}>(args?: Subset<T, Token$DumpToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DumpFrom<T extends Token$DumpFromArgs<ExtArgs> = {}>(args?: Subset<T, Token$DumpFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly name: FieldRef<"Token", 'String'>
    readonly chainId: FieldRef<"Token", 'Int'>
    readonly address: FieldRef<"Token", 'String'>
    readonly decimals: FieldRef<"Token", 'Int'>
    readonly symbol: FieldRef<"Token", 'String'>
    readonly displaySymbol: FieldRef<"Token", 'String'>
    readonly icon: FieldRef<"Token", 'String'>
    readonly verified: FieldRef<"Token", 'Boolean'>
    readonly isTest: FieldRef<"Token", 'Boolean'>
    readonly isPoint: FieldRef<"Token", 'Boolean'>
    readonly isPreTGE: FieldRef<"Token", 'Boolean'>
    readonly isNative: FieldRef<"Token", 'Boolean'>
    readonly price: FieldRef<"Token", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token.Opportunity
   */
  export type Token$OpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Token.Campaigns
   */
  export type Token$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Token.Reward
   */
  export type Token$RewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Token.DumpTo
   */
  export type Token$DumpToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    where?: DumpWhereInput
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    cursor?: DumpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
  }

  /**
   * Token.DumpFrom
   */
  export type Token$DumpFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    where?: DumpWhereInput
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    cursor?: DumpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model AprRecord
   */

  export type AggregateAprRecord = {
    _count: AprRecordCountAggregateOutputType | null
    _avg: AprRecordAvgAggregateOutputType | null
    _sum: AprRecordSumAggregateOutputType | null
    _min: AprRecordMinAggregateOutputType | null
    _max: AprRecordMaxAggregateOutputType | null
  }

  export type AprRecordAvgAggregateOutputType = {
    timestamp: number | null
    cumulated: number | null
  }

  export type AprRecordSumAggregateOutputType = {
    timestamp: bigint | null
    cumulated: number | null
  }

  export type AprRecordMinAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    cumulated: number | null
    opportunityId: string | null
  }

  export type AprRecordMaxAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    cumulated: number | null
    opportunityId: string | null
  }

  export type AprRecordCountAggregateOutputType = {
    id: number
    timestamp: number
    cumulated: number
    opportunityId: number
    _all: number
  }


  export type AprRecordAvgAggregateInputType = {
    timestamp?: true
    cumulated?: true
  }

  export type AprRecordSumAggregateInputType = {
    timestamp?: true
    cumulated?: true
  }

  export type AprRecordMinAggregateInputType = {
    id?: true
    timestamp?: true
    cumulated?: true
    opportunityId?: true
  }

  export type AprRecordMaxAggregateInputType = {
    id?: true
    timestamp?: true
    cumulated?: true
    opportunityId?: true
  }

  export type AprRecordCountAggregateInputType = {
    id?: true
    timestamp?: true
    cumulated?: true
    opportunityId?: true
    _all?: true
  }

  export type AprRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AprRecord to aggregate.
     */
    where?: AprRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprRecords to fetch.
     */
    orderBy?: AprRecordOrderByWithRelationInput | AprRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AprRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AprRecords
    **/
    _count?: true | AprRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AprRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AprRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AprRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AprRecordMaxAggregateInputType
  }

  export type GetAprRecordAggregateType<T extends AprRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAprRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAprRecord[P]>
      : GetScalarType<T[P], AggregateAprRecord[P]>
  }




  export type AprRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AprRecordWhereInput
    orderBy?: AprRecordOrderByWithAggregationInput | AprRecordOrderByWithAggregationInput[]
    by: AprRecordScalarFieldEnum[] | AprRecordScalarFieldEnum
    having?: AprRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AprRecordCountAggregateInputType | true
    _avg?: AprRecordAvgAggregateInputType
    _sum?: AprRecordSumAggregateInputType
    _min?: AprRecordMinAggregateInputType
    _max?: AprRecordMaxAggregateInputType
  }

  export type AprRecordGroupByOutputType = {
    id: string
    timestamp: bigint
    cumulated: number
    opportunityId: string
    _count: AprRecordCountAggregateOutputType | null
    _avg: AprRecordAvgAggregateOutputType | null
    _sum: AprRecordSumAggregateOutputType | null
    _min: AprRecordMinAggregateOutputType | null
    _max: AprRecordMaxAggregateOutputType | null
  }

  type GetAprRecordGroupByPayload<T extends AprRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AprRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AprRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AprRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AprRecordGroupByOutputType[P]>
        }
      >
    >


  export type AprRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    cumulated?: boolean
    opportunityId?: boolean
    AprBreakdown?: boolean | AprRecord$AprBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | AprRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprRecord"]>

  export type AprRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    cumulated?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprRecord"]>

  export type AprRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    cumulated?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprRecord"]>

  export type AprRecordSelectScalar = {
    id?: boolean
    timestamp?: boolean
    cumulated?: boolean
    opportunityId?: boolean
  }

  export type AprRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "cumulated" | "opportunityId", ExtArgs["result"]["aprRecord"]>
  export type AprRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AprBreakdown?: boolean | AprRecord$AprBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | AprRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AprRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type AprRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $AprRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AprRecord"
    objects: {
      AprBreakdown: Prisma.$AprBreakdownPayload<ExtArgs>[]
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: bigint
      cumulated: number
      opportunityId: string
    }, ExtArgs["result"]["aprRecord"]>
    composites: {}
  }

  type AprRecordGetPayload<S extends boolean | null | undefined | AprRecordDefaultArgs> = $Result.GetResult<Prisma.$AprRecordPayload, S>

  type AprRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AprRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AprRecordCountAggregateInputType | true
    }

  export interface AprRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AprRecord'], meta: { name: 'AprRecord' } }
    /**
     * Find zero or one AprRecord that matches the filter.
     * @param {AprRecordFindUniqueArgs} args - Arguments to find a AprRecord
     * @example
     * // Get one AprRecord
     * const aprRecord = await prisma.aprRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AprRecordFindUniqueArgs>(args: SelectSubset<T, AprRecordFindUniqueArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AprRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AprRecordFindUniqueOrThrowArgs} args - Arguments to find a AprRecord
     * @example
     * // Get one AprRecord
     * const aprRecord = await prisma.aprRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AprRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AprRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AprRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordFindFirstArgs} args - Arguments to find a AprRecord
     * @example
     * // Get one AprRecord
     * const aprRecord = await prisma.aprRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AprRecordFindFirstArgs>(args?: SelectSubset<T, AprRecordFindFirstArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AprRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordFindFirstOrThrowArgs} args - Arguments to find a AprRecord
     * @example
     * // Get one AprRecord
     * const aprRecord = await prisma.aprRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AprRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AprRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AprRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AprRecords
     * const aprRecords = await prisma.aprRecord.findMany()
     * 
     * // Get first 10 AprRecords
     * const aprRecords = await prisma.aprRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aprRecordWithIdOnly = await prisma.aprRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AprRecordFindManyArgs>(args?: SelectSubset<T, AprRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AprRecord.
     * @param {AprRecordCreateArgs} args - Arguments to create a AprRecord.
     * @example
     * // Create one AprRecord
     * const AprRecord = await prisma.aprRecord.create({
     *   data: {
     *     // ... data to create a AprRecord
     *   }
     * })
     * 
     */
    create<T extends AprRecordCreateArgs>(args: SelectSubset<T, AprRecordCreateArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AprRecords.
     * @param {AprRecordCreateManyArgs} args - Arguments to create many AprRecords.
     * @example
     * // Create many AprRecords
     * const aprRecord = await prisma.aprRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AprRecordCreateManyArgs>(args?: SelectSubset<T, AprRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AprRecords and returns the data saved in the database.
     * @param {AprRecordCreateManyAndReturnArgs} args - Arguments to create many AprRecords.
     * @example
     * // Create many AprRecords
     * const aprRecord = await prisma.aprRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AprRecords and only return the `id`
     * const aprRecordWithIdOnly = await prisma.aprRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AprRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AprRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AprRecord.
     * @param {AprRecordDeleteArgs} args - Arguments to delete one AprRecord.
     * @example
     * // Delete one AprRecord
     * const AprRecord = await prisma.aprRecord.delete({
     *   where: {
     *     // ... filter to delete one AprRecord
     *   }
     * })
     * 
     */
    delete<T extends AprRecordDeleteArgs>(args: SelectSubset<T, AprRecordDeleteArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AprRecord.
     * @param {AprRecordUpdateArgs} args - Arguments to update one AprRecord.
     * @example
     * // Update one AprRecord
     * const aprRecord = await prisma.aprRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AprRecordUpdateArgs>(args: SelectSubset<T, AprRecordUpdateArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AprRecords.
     * @param {AprRecordDeleteManyArgs} args - Arguments to filter AprRecords to delete.
     * @example
     * // Delete a few AprRecords
     * const { count } = await prisma.aprRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AprRecordDeleteManyArgs>(args?: SelectSubset<T, AprRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AprRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AprRecords
     * const aprRecord = await prisma.aprRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AprRecordUpdateManyArgs>(args: SelectSubset<T, AprRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AprRecords and returns the data updated in the database.
     * @param {AprRecordUpdateManyAndReturnArgs} args - Arguments to update many AprRecords.
     * @example
     * // Update many AprRecords
     * const aprRecord = await prisma.aprRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AprRecords and only return the `id`
     * const aprRecordWithIdOnly = await prisma.aprRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AprRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AprRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AprRecord.
     * @param {AprRecordUpsertArgs} args - Arguments to update or create a AprRecord.
     * @example
     * // Update or create a AprRecord
     * const aprRecord = await prisma.aprRecord.upsert({
     *   create: {
     *     // ... data to create a AprRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AprRecord we want to update
     *   }
     * })
     */
    upsert<T extends AprRecordUpsertArgs>(args: SelectSubset<T, AprRecordUpsertArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AprRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordCountArgs} args - Arguments to filter AprRecords to count.
     * @example
     * // Count the number of AprRecords
     * const count = await prisma.aprRecord.count({
     *   where: {
     *     // ... the filter for the AprRecords we want to count
     *   }
     * })
    **/
    count<T extends AprRecordCountArgs>(
      args?: Subset<T, AprRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AprRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AprRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AprRecordAggregateArgs>(args: Subset<T, AprRecordAggregateArgs>): Prisma.PrismaPromise<GetAprRecordAggregateType<T>>

    /**
     * Group by AprRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AprRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AprRecordGroupByArgs['orderBy'] }
        : { orderBy?: AprRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AprRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAprRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AprRecord model
   */
  readonly fields: AprRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AprRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AprRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AprBreakdown<T extends AprRecord$AprBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, AprRecord$AprBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AprRecord model
   */ 
  interface AprRecordFieldRefs {
    readonly id: FieldRef<"AprRecord", 'String'>
    readonly timestamp: FieldRef<"AprRecord", 'BigInt'>
    readonly cumulated: FieldRef<"AprRecord", 'Float'>
    readonly opportunityId: FieldRef<"AprRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AprRecord findUnique
   */
  export type AprRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter, which AprRecord to fetch.
     */
    where: AprRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord findUniqueOrThrow
   */
  export type AprRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter, which AprRecord to fetch.
     */
    where: AprRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord findFirst
   */
  export type AprRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter, which AprRecord to fetch.
     */
    where?: AprRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprRecords to fetch.
     */
    orderBy?: AprRecordOrderByWithRelationInput | AprRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AprRecords.
     */
    cursor?: AprRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AprRecords.
     */
    distinct?: AprRecordScalarFieldEnum | AprRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord findFirstOrThrow
   */
  export type AprRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter, which AprRecord to fetch.
     */
    where?: AprRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprRecords to fetch.
     */
    orderBy?: AprRecordOrderByWithRelationInput | AprRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AprRecords.
     */
    cursor?: AprRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AprRecords.
     */
    distinct?: AprRecordScalarFieldEnum | AprRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord findMany
   */
  export type AprRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter, which AprRecords to fetch.
     */
    where?: AprRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprRecords to fetch.
     */
    orderBy?: AprRecordOrderByWithRelationInput | AprRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AprRecords.
     */
    cursor?: AprRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprRecords.
     */
    skip?: number
    distinct?: AprRecordScalarFieldEnum | AprRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord create
   */
  export type AprRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AprRecord.
     */
    data: XOR<AprRecordCreateInput, AprRecordUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord createMany
   */
  export type AprRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AprRecords.
     */
    data: AprRecordCreateManyInput | AprRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AprRecord createManyAndReturn
   */
  export type AprRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AprRecords.
     */
    data: AprRecordCreateManyInput | AprRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AprRecord update
   */
  export type AprRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AprRecord.
     */
    data: XOR<AprRecordUpdateInput, AprRecordUncheckedUpdateInput>
    /**
     * Choose, which AprRecord to update.
     */
    where: AprRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord updateMany
   */
  export type AprRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AprRecords.
     */
    data: XOR<AprRecordUpdateManyMutationInput, AprRecordUncheckedUpdateManyInput>
    /**
     * Filter which AprRecords to update
     */
    where?: AprRecordWhereInput
    /**
     * Limit how many AprRecords to update.
     */
    limit?: number
  }

  /**
   * AprRecord updateManyAndReturn
   */
  export type AprRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * The data used to update AprRecords.
     */
    data: XOR<AprRecordUpdateManyMutationInput, AprRecordUncheckedUpdateManyInput>
    /**
     * Filter which AprRecords to update
     */
    where?: AprRecordWhereInput
    /**
     * Limit how many AprRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AprRecord upsert
   */
  export type AprRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AprRecord to update in case it exists.
     */
    where: AprRecordWhereUniqueInput
    /**
     * In case the AprRecord found by the `where` argument doesn't exist, create a new AprRecord with this data.
     */
    create: XOR<AprRecordCreateInput, AprRecordUncheckedCreateInput>
    /**
     * In case the AprRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AprRecordUpdateInput, AprRecordUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord delete
   */
  export type AprRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
    /**
     * Filter which AprRecord to delete.
     */
    where: AprRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprRecord deleteMany
   */
  export type AprRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AprRecords to delete
     */
    where?: AprRecordWhereInput
    /**
     * Limit how many AprRecords to delete.
     */
    limit?: number
  }

  /**
   * AprRecord.AprBreakdown
   */
  export type AprRecord$AprBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    where?: AprBreakdownWhereInput
    orderBy?: AprBreakdownOrderByWithRelationInput | AprBreakdownOrderByWithRelationInput[]
    cursor?: AprBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AprBreakdownScalarFieldEnum | AprBreakdownScalarFieldEnum[]
  }

  /**
   * AprRecord without action
   */
  export type AprRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprRecord
     */
    select?: AprRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprRecord
     */
    omit?: AprRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprRecordInclude<ExtArgs> | null
  }


  /**
   * Model AprBreakdown
   */

  export type AggregateAprBreakdown = {
    _count: AprBreakdownCountAggregateOutputType | null
    _avg: AprBreakdownAvgAggregateOutputType | null
    _sum: AprBreakdownSumAggregateOutputType | null
    _min: AprBreakdownMinAggregateOutputType | null
    _max: AprBreakdownMaxAggregateOutputType | null
  }

  export type AprBreakdownAvgAggregateOutputType = {
    value: number | null
  }

  export type AprBreakdownSumAggregateOutputType = {
    value: number | null
  }

  export type AprBreakdownMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: $Enums.AprType | null
    value: number | null
    aprRecordId: string | null
  }

  export type AprBreakdownMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: $Enums.AprType | null
    value: number | null
    aprRecordId: string | null
  }

  export type AprBreakdownCountAggregateOutputType = {
    id: number
    identifier: number
    type: number
    value: number
    aprRecordId: number
    _all: number
  }


  export type AprBreakdownAvgAggregateInputType = {
    value?: true
  }

  export type AprBreakdownSumAggregateInputType = {
    value?: true
  }

  export type AprBreakdownMinAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    aprRecordId?: true
  }

  export type AprBreakdownMaxAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    aprRecordId?: true
  }

  export type AprBreakdownCountAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    aprRecordId?: true
    _all?: true
  }

  export type AprBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AprBreakdown to aggregate.
     */
    where?: AprBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprBreakdowns to fetch.
     */
    orderBy?: AprBreakdownOrderByWithRelationInput | AprBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AprBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AprBreakdowns
    **/
    _count?: true | AprBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AprBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AprBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AprBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AprBreakdownMaxAggregateInputType
  }

  export type GetAprBreakdownAggregateType<T extends AprBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateAprBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAprBreakdown[P]>
      : GetScalarType<T[P], AggregateAprBreakdown[P]>
  }




  export type AprBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AprBreakdownWhereInput
    orderBy?: AprBreakdownOrderByWithAggregationInput | AprBreakdownOrderByWithAggregationInput[]
    by: AprBreakdownScalarFieldEnum[] | AprBreakdownScalarFieldEnum
    having?: AprBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AprBreakdownCountAggregateInputType | true
    _avg?: AprBreakdownAvgAggregateInputType
    _sum?: AprBreakdownSumAggregateInputType
    _min?: AprBreakdownMinAggregateInputType
    _max?: AprBreakdownMaxAggregateInputType
  }

  export type AprBreakdownGroupByOutputType = {
    id: string
    identifier: string
    type: $Enums.AprType
    value: number
    aprRecordId: string
    _count: AprBreakdownCountAggregateOutputType | null
    _avg: AprBreakdownAvgAggregateOutputType | null
    _sum: AprBreakdownSumAggregateOutputType | null
    _min: AprBreakdownMinAggregateOutputType | null
    _max: AprBreakdownMaxAggregateOutputType | null
  }

  type GetAprBreakdownGroupByPayload<T extends AprBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AprBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AprBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AprBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], AprBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type AprBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    aprRecordId?: boolean
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprBreakdown"]>

  export type AprBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    aprRecordId?: boolean
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprBreakdown"]>

  export type AprBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    aprRecordId?: boolean
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aprBreakdown"]>

  export type AprBreakdownSelectScalar = {
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    aprRecordId?: boolean
  }

  export type AprBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "type" | "value" | "aprRecordId", ExtArgs["result"]["aprBreakdown"]>
  export type AprBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }
  export type AprBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }
  export type AprBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AprRecord?: boolean | AprRecordDefaultArgs<ExtArgs>
  }

  export type $AprBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AprBreakdown"
    objects: {
      AprRecord: Prisma.$AprRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      type: $Enums.AprType
      value: number
      aprRecordId: string
    }, ExtArgs["result"]["aprBreakdown"]>
    composites: {}
  }

  type AprBreakdownGetPayload<S extends boolean | null | undefined | AprBreakdownDefaultArgs> = $Result.GetResult<Prisma.$AprBreakdownPayload, S>

  type AprBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AprBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AprBreakdownCountAggregateInputType | true
    }

  export interface AprBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AprBreakdown'], meta: { name: 'AprBreakdown' } }
    /**
     * Find zero or one AprBreakdown that matches the filter.
     * @param {AprBreakdownFindUniqueArgs} args - Arguments to find a AprBreakdown
     * @example
     * // Get one AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AprBreakdownFindUniqueArgs>(args: SelectSubset<T, AprBreakdownFindUniqueArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AprBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AprBreakdownFindUniqueOrThrowArgs} args - Arguments to find a AprBreakdown
     * @example
     * // Get one AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AprBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, AprBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AprBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownFindFirstArgs} args - Arguments to find a AprBreakdown
     * @example
     * // Get one AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AprBreakdownFindFirstArgs>(args?: SelectSubset<T, AprBreakdownFindFirstArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AprBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownFindFirstOrThrowArgs} args - Arguments to find a AprBreakdown
     * @example
     * // Get one AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AprBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, AprBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AprBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AprBreakdowns
     * const aprBreakdowns = await prisma.aprBreakdown.findMany()
     * 
     * // Get first 10 AprBreakdowns
     * const aprBreakdowns = await prisma.aprBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aprBreakdownWithIdOnly = await prisma.aprBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AprBreakdownFindManyArgs>(args?: SelectSubset<T, AprBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AprBreakdown.
     * @param {AprBreakdownCreateArgs} args - Arguments to create a AprBreakdown.
     * @example
     * // Create one AprBreakdown
     * const AprBreakdown = await prisma.aprBreakdown.create({
     *   data: {
     *     // ... data to create a AprBreakdown
     *   }
     * })
     * 
     */
    create<T extends AprBreakdownCreateArgs>(args: SelectSubset<T, AprBreakdownCreateArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AprBreakdowns.
     * @param {AprBreakdownCreateManyArgs} args - Arguments to create many AprBreakdowns.
     * @example
     * // Create many AprBreakdowns
     * const aprBreakdown = await prisma.aprBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AprBreakdownCreateManyArgs>(args?: SelectSubset<T, AprBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AprBreakdowns and returns the data saved in the database.
     * @param {AprBreakdownCreateManyAndReturnArgs} args - Arguments to create many AprBreakdowns.
     * @example
     * // Create many AprBreakdowns
     * const aprBreakdown = await prisma.aprBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AprBreakdowns and only return the `id`
     * const aprBreakdownWithIdOnly = await prisma.aprBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AprBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, AprBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AprBreakdown.
     * @param {AprBreakdownDeleteArgs} args - Arguments to delete one AprBreakdown.
     * @example
     * // Delete one AprBreakdown
     * const AprBreakdown = await prisma.aprBreakdown.delete({
     *   where: {
     *     // ... filter to delete one AprBreakdown
     *   }
     * })
     * 
     */
    delete<T extends AprBreakdownDeleteArgs>(args: SelectSubset<T, AprBreakdownDeleteArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AprBreakdown.
     * @param {AprBreakdownUpdateArgs} args - Arguments to update one AprBreakdown.
     * @example
     * // Update one AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AprBreakdownUpdateArgs>(args: SelectSubset<T, AprBreakdownUpdateArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AprBreakdowns.
     * @param {AprBreakdownDeleteManyArgs} args - Arguments to filter AprBreakdowns to delete.
     * @example
     * // Delete a few AprBreakdowns
     * const { count } = await prisma.aprBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AprBreakdownDeleteManyArgs>(args?: SelectSubset<T, AprBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AprBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AprBreakdowns
     * const aprBreakdown = await prisma.aprBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AprBreakdownUpdateManyArgs>(args: SelectSubset<T, AprBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AprBreakdowns and returns the data updated in the database.
     * @param {AprBreakdownUpdateManyAndReturnArgs} args - Arguments to update many AprBreakdowns.
     * @example
     * // Update many AprBreakdowns
     * const aprBreakdown = await prisma.aprBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AprBreakdowns and only return the `id`
     * const aprBreakdownWithIdOnly = await prisma.aprBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AprBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, AprBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AprBreakdown.
     * @param {AprBreakdownUpsertArgs} args - Arguments to update or create a AprBreakdown.
     * @example
     * // Update or create a AprBreakdown
     * const aprBreakdown = await prisma.aprBreakdown.upsert({
     *   create: {
     *     // ... data to create a AprBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AprBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends AprBreakdownUpsertArgs>(args: SelectSubset<T, AprBreakdownUpsertArgs<ExtArgs>>): Prisma__AprBreakdownClient<$Result.GetResult<Prisma.$AprBreakdownPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AprBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownCountArgs} args - Arguments to filter AprBreakdowns to count.
     * @example
     * // Count the number of AprBreakdowns
     * const count = await prisma.aprBreakdown.count({
     *   where: {
     *     // ... the filter for the AprBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends AprBreakdownCountArgs>(
      args?: Subset<T, AprBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AprBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AprBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AprBreakdownAggregateArgs>(args: Subset<T, AprBreakdownAggregateArgs>): Prisma.PrismaPromise<GetAprBreakdownAggregateType<T>>

    /**
     * Group by AprBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AprBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AprBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AprBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: AprBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AprBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAprBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AprBreakdown model
   */
  readonly fields: AprBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AprBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AprBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AprRecord<T extends AprRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AprRecordDefaultArgs<ExtArgs>>): Prisma__AprRecordClient<$Result.GetResult<Prisma.$AprRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AprBreakdown model
   */ 
  interface AprBreakdownFieldRefs {
    readonly id: FieldRef<"AprBreakdown", 'String'>
    readonly identifier: FieldRef<"AprBreakdown", 'String'>
    readonly type: FieldRef<"AprBreakdown", 'AprType'>
    readonly value: FieldRef<"AprBreakdown", 'Float'>
    readonly aprRecordId: FieldRef<"AprBreakdown", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AprBreakdown findUnique
   */
  export type AprBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which AprBreakdown to fetch.
     */
    where: AprBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown findUniqueOrThrow
   */
  export type AprBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which AprBreakdown to fetch.
     */
    where: AprBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown findFirst
   */
  export type AprBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which AprBreakdown to fetch.
     */
    where?: AprBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprBreakdowns to fetch.
     */
    orderBy?: AprBreakdownOrderByWithRelationInput | AprBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AprBreakdowns.
     */
    cursor?: AprBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AprBreakdowns.
     */
    distinct?: AprBreakdownScalarFieldEnum | AprBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown findFirstOrThrow
   */
  export type AprBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which AprBreakdown to fetch.
     */
    where?: AprBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprBreakdowns to fetch.
     */
    orderBy?: AprBreakdownOrderByWithRelationInput | AprBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AprBreakdowns.
     */
    cursor?: AprBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AprBreakdowns.
     */
    distinct?: AprBreakdownScalarFieldEnum | AprBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown findMany
   */
  export type AprBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which AprBreakdowns to fetch.
     */
    where?: AprBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AprBreakdowns to fetch.
     */
    orderBy?: AprBreakdownOrderByWithRelationInput | AprBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AprBreakdowns.
     */
    cursor?: AprBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AprBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AprBreakdowns.
     */
    skip?: number
    distinct?: AprBreakdownScalarFieldEnum | AprBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown create
   */
  export type AprBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a AprBreakdown.
     */
    data: XOR<AprBreakdownCreateInput, AprBreakdownUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown createMany
   */
  export type AprBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AprBreakdowns.
     */
    data: AprBreakdownCreateManyInput | AprBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AprBreakdown createManyAndReturn
   */
  export type AprBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many AprBreakdowns.
     */
    data: AprBreakdownCreateManyInput | AprBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AprBreakdown update
   */
  export type AprBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a AprBreakdown.
     */
    data: XOR<AprBreakdownUpdateInput, AprBreakdownUncheckedUpdateInput>
    /**
     * Choose, which AprBreakdown to update.
     */
    where: AprBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown updateMany
   */
  export type AprBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AprBreakdowns.
     */
    data: XOR<AprBreakdownUpdateManyMutationInput, AprBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which AprBreakdowns to update
     */
    where?: AprBreakdownWhereInput
    /**
     * Limit how many AprBreakdowns to update.
     */
    limit?: number
  }

  /**
   * AprBreakdown updateManyAndReturn
   */
  export type AprBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update AprBreakdowns.
     */
    data: XOR<AprBreakdownUpdateManyMutationInput, AprBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which AprBreakdowns to update
     */
    where?: AprBreakdownWhereInput
    /**
     * Limit how many AprBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AprBreakdown upsert
   */
  export type AprBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the AprBreakdown to update in case it exists.
     */
    where: AprBreakdownWhereUniqueInput
    /**
     * In case the AprBreakdown found by the `where` argument doesn't exist, create a new AprBreakdown with this data.
     */
    create: XOR<AprBreakdownCreateInput, AprBreakdownUncheckedCreateInput>
    /**
     * In case the AprBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AprBreakdownUpdateInput, AprBreakdownUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown delete
   */
  export type AprBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
    /**
     * Filter which AprBreakdown to delete.
     */
    where: AprBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AprBreakdown deleteMany
   */
  export type AprBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AprBreakdowns to delete
     */
    where?: AprBreakdownWhereInput
    /**
     * Limit how many AprBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * AprBreakdown without action
   */
  export type AprBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AprBreakdown
     */
    select?: AprBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AprBreakdown
     */
    omit?: AprBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AprBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model TVLRecord
   */

  export type AggregateTVLRecord = {
    _count: TVLRecordCountAggregateOutputType | null
    _avg: TVLRecordAvgAggregateOutputType | null
    _sum: TVLRecordSumAggregateOutputType | null
    _min: TVLRecordMinAggregateOutputType | null
    _max: TVLRecordMaxAggregateOutputType | null
  }

  export type TVLRecordAvgAggregateOutputType = {
    timestamp: number | null
    total: number | null
  }

  export type TVLRecordSumAggregateOutputType = {
    timestamp: bigint | null
    total: number | null
  }

  export type TVLRecordMinAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    total: number | null
    opportunityId: string | null
  }

  export type TVLRecordMaxAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    total: number | null
    opportunityId: string | null
  }

  export type TVLRecordCountAggregateOutputType = {
    id: number
    timestamp: number
    total: number
    opportunityId: number
    _all: number
  }


  export type TVLRecordAvgAggregateInputType = {
    timestamp?: true
    total?: true
  }

  export type TVLRecordSumAggregateInputType = {
    timestamp?: true
    total?: true
  }

  export type TVLRecordMinAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
  }

  export type TVLRecordMaxAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
  }

  export type TVLRecordCountAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
    _all?: true
  }

  export type TVLRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVLRecord to aggregate.
     */
    where?: TVLRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLRecords to fetch.
     */
    orderBy?: TVLRecordOrderByWithRelationInput | TVLRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TVLRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TVLRecords
    **/
    _count?: true | TVLRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TVLRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TVLRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TVLRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TVLRecordMaxAggregateInputType
  }

  export type GetTVLRecordAggregateType<T extends TVLRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTVLRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTVLRecord[P]>
      : GetScalarType<T[P], AggregateTVLRecord[P]>
  }




  export type TVLRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVLRecordWhereInput
    orderBy?: TVLRecordOrderByWithAggregationInput | TVLRecordOrderByWithAggregationInput[]
    by: TVLRecordScalarFieldEnum[] | TVLRecordScalarFieldEnum
    having?: TVLRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TVLRecordCountAggregateInputType | true
    _avg?: TVLRecordAvgAggregateInputType
    _sum?: TVLRecordSumAggregateInputType
    _min?: TVLRecordMinAggregateInputType
    _max?: TVLRecordMaxAggregateInputType
  }

  export type TVLRecordGroupByOutputType = {
    id: string
    timestamp: bigint
    total: number
    opportunityId: string
    _count: TVLRecordCountAggregateOutputType | null
    _avg: TVLRecordAvgAggregateOutputType | null
    _sum: TVLRecordSumAggregateOutputType | null
    _min: TVLRecordMinAggregateOutputType | null
    _max: TVLRecordMaxAggregateOutputType | null
  }

  type GetTVLRecordGroupByPayload<T extends TVLRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TVLRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TVLRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TVLRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TVLRecordGroupByOutputType[P]>
        }
      >
    >


  export type TVLRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    TvlBreakdown?: boolean | TVLRecord$TvlBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | TVLRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLRecord"]>

  export type TVLRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLRecord"]>

  export type TVLRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLRecord"]>

  export type TVLRecordSelectScalar = {
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
  }

  export type TVLRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "total" | "opportunityId", ExtArgs["result"]["tVLRecord"]>
  export type TVLRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TvlBreakdown?: boolean | TVLRecord$TvlBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | TVLRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TVLRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type TVLRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $TVLRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TVLRecord"
    objects: {
      TvlBreakdown: Prisma.$TVLBreakdownPayload<ExtArgs>[]
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: bigint
      total: number
      opportunityId: string
    }, ExtArgs["result"]["tVLRecord"]>
    composites: {}
  }

  type TVLRecordGetPayload<S extends boolean | null | undefined | TVLRecordDefaultArgs> = $Result.GetResult<Prisma.$TVLRecordPayload, S>

  type TVLRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TVLRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TVLRecordCountAggregateInputType | true
    }

  export interface TVLRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TVLRecord'], meta: { name: 'TVLRecord' } }
    /**
     * Find zero or one TVLRecord that matches the filter.
     * @param {TVLRecordFindUniqueArgs} args - Arguments to find a TVLRecord
     * @example
     * // Get one TVLRecord
     * const tVLRecord = await prisma.tVLRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TVLRecordFindUniqueArgs>(args: SelectSubset<T, TVLRecordFindUniqueArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TVLRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TVLRecordFindUniqueOrThrowArgs} args - Arguments to find a TVLRecord
     * @example
     * // Get one TVLRecord
     * const tVLRecord = await prisma.tVLRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TVLRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TVLRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TVLRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordFindFirstArgs} args - Arguments to find a TVLRecord
     * @example
     * // Get one TVLRecord
     * const tVLRecord = await prisma.tVLRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TVLRecordFindFirstArgs>(args?: SelectSubset<T, TVLRecordFindFirstArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TVLRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordFindFirstOrThrowArgs} args - Arguments to find a TVLRecord
     * @example
     * // Get one TVLRecord
     * const tVLRecord = await prisma.tVLRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TVLRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TVLRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TVLRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TVLRecords
     * const tVLRecords = await prisma.tVLRecord.findMany()
     * 
     * // Get first 10 TVLRecords
     * const tVLRecords = await prisma.tVLRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tVLRecordWithIdOnly = await prisma.tVLRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TVLRecordFindManyArgs>(args?: SelectSubset<T, TVLRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TVLRecord.
     * @param {TVLRecordCreateArgs} args - Arguments to create a TVLRecord.
     * @example
     * // Create one TVLRecord
     * const TVLRecord = await prisma.tVLRecord.create({
     *   data: {
     *     // ... data to create a TVLRecord
     *   }
     * })
     * 
     */
    create<T extends TVLRecordCreateArgs>(args: SelectSubset<T, TVLRecordCreateArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TVLRecords.
     * @param {TVLRecordCreateManyArgs} args - Arguments to create many TVLRecords.
     * @example
     * // Create many TVLRecords
     * const tVLRecord = await prisma.tVLRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TVLRecordCreateManyArgs>(args?: SelectSubset<T, TVLRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TVLRecords and returns the data saved in the database.
     * @param {TVLRecordCreateManyAndReturnArgs} args - Arguments to create many TVLRecords.
     * @example
     * // Create many TVLRecords
     * const tVLRecord = await prisma.tVLRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TVLRecords and only return the `id`
     * const tVLRecordWithIdOnly = await prisma.tVLRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TVLRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TVLRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TVLRecord.
     * @param {TVLRecordDeleteArgs} args - Arguments to delete one TVLRecord.
     * @example
     * // Delete one TVLRecord
     * const TVLRecord = await prisma.tVLRecord.delete({
     *   where: {
     *     // ... filter to delete one TVLRecord
     *   }
     * })
     * 
     */
    delete<T extends TVLRecordDeleteArgs>(args: SelectSubset<T, TVLRecordDeleteArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TVLRecord.
     * @param {TVLRecordUpdateArgs} args - Arguments to update one TVLRecord.
     * @example
     * // Update one TVLRecord
     * const tVLRecord = await prisma.tVLRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TVLRecordUpdateArgs>(args: SelectSubset<T, TVLRecordUpdateArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TVLRecords.
     * @param {TVLRecordDeleteManyArgs} args - Arguments to filter TVLRecords to delete.
     * @example
     * // Delete a few TVLRecords
     * const { count } = await prisma.tVLRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TVLRecordDeleteManyArgs>(args?: SelectSubset<T, TVLRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVLRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TVLRecords
     * const tVLRecord = await prisma.tVLRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TVLRecordUpdateManyArgs>(args: SelectSubset<T, TVLRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVLRecords and returns the data updated in the database.
     * @param {TVLRecordUpdateManyAndReturnArgs} args - Arguments to update many TVLRecords.
     * @example
     * // Update many TVLRecords
     * const tVLRecord = await prisma.tVLRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TVLRecords and only return the `id`
     * const tVLRecordWithIdOnly = await prisma.tVLRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TVLRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TVLRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TVLRecord.
     * @param {TVLRecordUpsertArgs} args - Arguments to update or create a TVLRecord.
     * @example
     * // Update or create a TVLRecord
     * const tVLRecord = await prisma.tVLRecord.upsert({
     *   create: {
     *     // ... data to create a TVLRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TVLRecord we want to update
     *   }
     * })
     */
    upsert<T extends TVLRecordUpsertArgs>(args: SelectSubset<T, TVLRecordUpsertArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TVLRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordCountArgs} args - Arguments to filter TVLRecords to count.
     * @example
     * // Count the number of TVLRecords
     * const count = await prisma.tVLRecord.count({
     *   where: {
     *     // ... the filter for the TVLRecords we want to count
     *   }
     * })
    **/
    count<T extends TVLRecordCountArgs>(
      args?: Subset<T, TVLRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TVLRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TVLRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TVLRecordAggregateArgs>(args: Subset<T, TVLRecordAggregateArgs>): Prisma.PrismaPromise<GetTVLRecordAggregateType<T>>

    /**
     * Group by TVLRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TVLRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TVLRecordGroupByArgs['orderBy'] }
        : { orderBy?: TVLRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TVLRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTVLRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TVLRecord model
   */
  readonly fields: TVLRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TVLRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TVLRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TvlBreakdown<T extends TVLRecord$TvlBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, TVLRecord$TvlBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TVLRecord model
   */ 
  interface TVLRecordFieldRefs {
    readonly id: FieldRef<"TVLRecord", 'String'>
    readonly timestamp: FieldRef<"TVLRecord", 'BigInt'>
    readonly total: FieldRef<"TVLRecord", 'Float'>
    readonly opportunityId: FieldRef<"TVLRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TVLRecord findUnique
   */
  export type TVLRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter, which TVLRecord to fetch.
     */
    where: TVLRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord findUniqueOrThrow
   */
  export type TVLRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter, which TVLRecord to fetch.
     */
    where: TVLRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord findFirst
   */
  export type TVLRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter, which TVLRecord to fetch.
     */
    where?: TVLRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLRecords to fetch.
     */
    orderBy?: TVLRecordOrderByWithRelationInput | TVLRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVLRecords.
     */
    cursor?: TVLRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVLRecords.
     */
    distinct?: TVLRecordScalarFieldEnum | TVLRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord findFirstOrThrow
   */
  export type TVLRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter, which TVLRecord to fetch.
     */
    where?: TVLRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLRecords to fetch.
     */
    orderBy?: TVLRecordOrderByWithRelationInput | TVLRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVLRecords.
     */
    cursor?: TVLRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVLRecords.
     */
    distinct?: TVLRecordScalarFieldEnum | TVLRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord findMany
   */
  export type TVLRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter, which TVLRecords to fetch.
     */
    where?: TVLRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLRecords to fetch.
     */
    orderBy?: TVLRecordOrderByWithRelationInput | TVLRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TVLRecords.
     */
    cursor?: TVLRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLRecords.
     */
    skip?: number
    distinct?: TVLRecordScalarFieldEnum | TVLRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord create
   */
  export type TVLRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TVLRecord.
     */
    data: XOR<TVLRecordCreateInput, TVLRecordUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord createMany
   */
  export type TVLRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TVLRecords.
     */
    data: TVLRecordCreateManyInput | TVLRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TVLRecord createManyAndReturn
   */
  export type TVLRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TVLRecords.
     */
    data: TVLRecordCreateManyInput | TVLRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVLRecord update
   */
  export type TVLRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TVLRecord.
     */
    data: XOR<TVLRecordUpdateInput, TVLRecordUncheckedUpdateInput>
    /**
     * Choose, which TVLRecord to update.
     */
    where: TVLRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord updateMany
   */
  export type TVLRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TVLRecords.
     */
    data: XOR<TVLRecordUpdateManyMutationInput, TVLRecordUncheckedUpdateManyInput>
    /**
     * Filter which TVLRecords to update
     */
    where?: TVLRecordWhereInput
    /**
     * Limit how many TVLRecords to update.
     */
    limit?: number
  }

  /**
   * TVLRecord updateManyAndReturn
   */
  export type TVLRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * The data used to update TVLRecords.
     */
    data: XOR<TVLRecordUpdateManyMutationInput, TVLRecordUncheckedUpdateManyInput>
    /**
     * Filter which TVLRecords to update
     */
    where?: TVLRecordWhereInput
    /**
     * Limit how many TVLRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVLRecord upsert
   */
  export type TVLRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TVLRecord to update in case it exists.
     */
    where: TVLRecordWhereUniqueInput
    /**
     * In case the TVLRecord found by the `where` argument doesn't exist, create a new TVLRecord with this data.
     */
    create: XOR<TVLRecordCreateInput, TVLRecordUncheckedCreateInput>
    /**
     * In case the TVLRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TVLRecordUpdateInput, TVLRecordUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord delete
   */
  export type TVLRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
    /**
     * Filter which TVLRecord to delete.
     */
    where: TVLRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLRecord deleteMany
   */
  export type TVLRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVLRecords to delete
     */
    where?: TVLRecordWhereInput
    /**
     * Limit how many TVLRecords to delete.
     */
    limit?: number
  }

  /**
   * TVLRecord.TvlBreakdown
   */
  export type TVLRecord$TvlBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    where?: TVLBreakdownWhereInput
    orderBy?: TVLBreakdownOrderByWithRelationInput | TVLBreakdownOrderByWithRelationInput[]
    cursor?: TVLBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TVLBreakdownScalarFieldEnum | TVLBreakdownScalarFieldEnum[]
  }

  /**
   * TVLRecord without action
   */
  export type TVLRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLRecord
     */
    select?: TVLRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLRecord
     */
    omit?: TVLRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLRecordInclude<ExtArgs> | null
  }


  /**
   * Model TVLBreakdown
   */

  export type AggregateTVLBreakdown = {
    _count: TVLBreakdownCountAggregateOutputType | null
    _avg: TVLBreakdownAvgAggregateOutputType | null
    _sum: TVLBreakdownSumAggregateOutputType | null
    _min: TVLBreakdownMinAggregateOutputType | null
    _max: TVLBreakdownMaxAggregateOutputType | null
  }

  export type TVLBreakdownAvgAggregateOutputType = {
    value: number | null
  }

  export type TVLBreakdownSumAggregateOutputType = {
    value: number | null
  }

  export type TVLBreakdownMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: $Enums.TvlType | null
    value: number | null
    tvlRecordId: string | null
  }

  export type TVLBreakdownMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: $Enums.TvlType | null
    value: number | null
    tvlRecordId: string | null
  }

  export type TVLBreakdownCountAggregateOutputType = {
    id: number
    identifier: number
    type: number
    value: number
    tvlRecordId: number
    _all: number
  }


  export type TVLBreakdownAvgAggregateInputType = {
    value?: true
  }

  export type TVLBreakdownSumAggregateInputType = {
    value?: true
  }

  export type TVLBreakdownMinAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    tvlRecordId?: true
  }

  export type TVLBreakdownMaxAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    tvlRecordId?: true
  }

  export type TVLBreakdownCountAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    value?: true
    tvlRecordId?: true
    _all?: true
  }

  export type TVLBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVLBreakdown to aggregate.
     */
    where?: TVLBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLBreakdowns to fetch.
     */
    orderBy?: TVLBreakdownOrderByWithRelationInput | TVLBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TVLBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TVLBreakdowns
    **/
    _count?: true | TVLBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TVLBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TVLBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TVLBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TVLBreakdownMaxAggregateInputType
  }

  export type GetTVLBreakdownAggregateType<T extends TVLBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateTVLBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTVLBreakdown[P]>
      : GetScalarType<T[P], AggregateTVLBreakdown[P]>
  }




  export type TVLBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVLBreakdownWhereInput
    orderBy?: TVLBreakdownOrderByWithAggregationInput | TVLBreakdownOrderByWithAggregationInput[]
    by: TVLBreakdownScalarFieldEnum[] | TVLBreakdownScalarFieldEnum
    having?: TVLBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TVLBreakdownCountAggregateInputType | true
    _avg?: TVLBreakdownAvgAggregateInputType
    _sum?: TVLBreakdownSumAggregateInputType
    _min?: TVLBreakdownMinAggregateInputType
    _max?: TVLBreakdownMaxAggregateInputType
  }

  export type TVLBreakdownGroupByOutputType = {
    id: string
    identifier: string
    type: $Enums.TvlType
    value: number
    tvlRecordId: string
    _count: TVLBreakdownCountAggregateOutputType | null
    _avg: TVLBreakdownAvgAggregateOutputType | null
    _sum: TVLBreakdownSumAggregateOutputType | null
    _min: TVLBreakdownMinAggregateOutputType | null
    _max: TVLBreakdownMaxAggregateOutputType | null
  }

  type GetTVLBreakdownGroupByPayload<T extends TVLBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TVLBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TVLBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TVLBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], TVLBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type TVLBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    tvlRecordId?: boolean
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLBreakdown"]>

  export type TVLBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    tvlRecordId?: boolean
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLBreakdown"]>

  export type TVLBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    tvlRecordId?: boolean
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tVLBreakdown"]>

  export type TVLBreakdownSelectScalar = {
    id?: boolean
    identifier?: boolean
    type?: boolean
    value?: boolean
    tvlRecordId?: boolean
  }

  export type TVLBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "type" | "value" | "tvlRecordId", ExtArgs["result"]["tVLBreakdown"]>
  export type TVLBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }
  export type TVLBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }
  export type TVLBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TvlRecord?: boolean | TVLRecordDefaultArgs<ExtArgs>
  }

  export type $TVLBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TVLBreakdown"
    objects: {
      TvlRecord: Prisma.$TVLRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      type: $Enums.TvlType
      value: number
      tvlRecordId: string
    }, ExtArgs["result"]["tVLBreakdown"]>
    composites: {}
  }

  type TVLBreakdownGetPayload<S extends boolean | null | undefined | TVLBreakdownDefaultArgs> = $Result.GetResult<Prisma.$TVLBreakdownPayload, S>

  type TVLBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TVLBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TVLBreakdownCountAggregateInputType | true
    }

  export interface TVLBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TVLBreakdown'], meta: { name: 'TVLBreakdown' } }
    /**
     * Find zero or one TVLBreakdown that matches the filter.
     * @param {TVLBreakdownFindUniqueArgs} args - Arguments to find a TVLBreakdown
     * @example
     * // Get one TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TVLBreakdownFindUniqueArgs>(args: SelectSubset<T, TVLBreakdownFindUniqueArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TVLBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TVLBreakdownFindUniqueOrThrowArgs} args - Arguments to find a TVLBreakdown
     * @example
     * // Get one TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TVLBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, TVLBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TVLBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownFindFirstArgs} args - Arguments to find a TVLBreakdown
     * @example
     * // Get one TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TVLBreakdownFindFirstArgs>(args?: SelectSubset<T, TVLBreakdownFindFirstArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TVLBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownFindFirstOrThrowArgs} args - Arguments to find a TVLBreakdown
     * @example
     * // Get one TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TVLBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, TVLBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TVLBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TVLBreakdowns
     * const tVLBreakdowns = await prisma.tVLBreakdown.findMany()
     * 
     * // Get first 10 TVLBreakdowns
     * const tVLBreakdowns = await prisma.tVLBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tVLBreakdownWithIdOnly = await prisma.tVLBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TVLBreakdownFindManyArgs>(args?: SelectSubset<T, TVLBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TVLBreakdown.
     * @param {TVLBreakdownCreateArgs} args - Arguments to create a TVLBreakdown.
     * @example
     * // Create one TVLBreakdown
     * const TVLBreakdown = await prisma.tVLBreakdown.create({
     *   data: {
     *     // ... data to create a TVLBreakdown
     *   }
     * })
     * 
     */
    create<T extends TVLBreakdownCreateArgs>(args: SelectSubset<T, TVLBreakdownCreateArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TVLBreakdowns.
     * @param {TVLBreakdownCreateManyArgs} args - Arguments to create many TVLBreakdowns.
     * @example
     * // Create many TVLBreakdowns
     * const tVLBreakdown = await prisma.tVLBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TVLBreakdownCreateManyArgs>(args?: SelectSubset<T, TVLBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TVLBreakdowns and returns the data saved in the database.
     * @param {TVLBreakdownCreateManyAndReturnArgs} args - Arguments to create many TVLBreakdowns.
     * @example
     * // Create many TVLBreakdowns
     * const tVLBreakdown = await prisma.tVLBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TVLBreakdowns and only return the `id`
     * const tVLBreakdownWithIdOnly = await prisma.tVLBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TVLBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, TVLBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TVLBreakdown.
     * @param {TVLBreakdownDeleteArgs} args - Arguments to delete one TVLBreakdown.
     * @example
     * // Delete one TVLBreakdown
     * const TVLBreakdown = await prisma.tVLBreakdown.delete({
     *   where: {
     *     // ... filter to delete one TVLBreakdown
     *   }
     * })
     * 
     */
    delete<T extends TVLBreakdownDeleteArgs>(args: SelectSubset<T, TVLBreakdownDeleteArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TVLBreakdown.
     * @param {TVLBreakdownUpdateArgs} args - Arguments to update one TVLBreakdown.
     * @example
     * // Update one TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TVLBreakdownUpdateArgs>(args: SelectSubset<T, TVLBreakdownUpdateArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TVLBreakdowns.
     * @param {TVLBreakdownDeleteManyArgs} args - Arguments to filter TVLBreakdowns to delete.
     * @example
     * // Delete a few TVLBreakdowns
     * const { count } = await prisma.tVLBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TVLBreakdownDeleteManyArgs>(args?: SelectSubset<T, TVLBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVLBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TVLBreakdowns
     * const tVLBreakdown = await prisma.tVLBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TVLBreakdownUpdateManyArgs>(args: SelectSubset<T, TVLBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVLBreakdowns and returns the data updated in the database.
     * @param {TVLBreakdownUpdateManyAndReturnArgs} args - Arguments to update many TVLBreakdowns.
     * @example
     * // Update many TVLBreakdowns
     * const tVLBreakdown = await prisma.tVLBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TVLBreakdowns and only return the `id`
     * const tVLBreakdownWithIdOnly = await prisma.tVLBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TVLBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, TVLBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TVLBreakdown.
     * @param {TVLBreakdownUpsertArgs} args - Arguments to update or create a TVLBreakdown.
     * @example
     * // Update or create a TVLBreakdown
     * const tVLBreakdown = await prisma.tVLBreakdown.upsert({
     *   create: {
     *     // ... data to create a TVLBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TVLBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends TVLBreakdownUpsertArgs>(args: SelectSubset<T, TVLBreakdownUpsertArgs<ExtArgs>>): Prisma__TVLBreakdownClient<$Result.GetResult<Prisma.$TVLBreakdownPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TVLBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownCountArgs} args - Arguments to filter TVLBreakdowns to count.
     * @example
     * // Count the number of TVLBreakdowns
     * const count = await prisma.tVLBreakdown.count({
     *   where: {
     *     // ... the filter for the TVLBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends TVLBreakdownCountArgs>(
      args?: Subset<T, TVLBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TVLBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TVLBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TVLBreakdownAggregateArgs>(args: Subset<T, TVLBreakdownAggregateArgs>): Prisma.PrismaPromise<GetTVLBreakdownAggregateType<T>>

    /**
     * Group by TVLBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVLBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TVLBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TVLBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: TVLBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TVLBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTVLBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TVLBreakdown model
   */
  readonly fields: TVLBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TVLBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TVLBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TvlRecord<T extends TVLRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TVLRecordDefaultArgs<ExtArgs>>): Prisma__TVLRecordClient<$Result.GetResult<Prisma.$TVLRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TVLBreakdown model
   */ 
  interface TVLBreakdownFieldRefs {
    readonly id: FieldRef<"TVLBreakdown", 'String'>
    readonly identifier: FieldRef<"TVLBreakdown", 'String'>
    readonly type: FieldRef<"TVLBreakdown", 'TvlType'>
    readonly value: FieldRef<"TVLBreakdown", 'Float'>
    readonly tvlRecordId: FieldRef<"TVLBreakdown", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TVLBreakdown findUnique
   */
  export type TVLBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which TVLBreakdown to fetch.
     */
    where: TVLBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown findUniqueOrThrow
   */
  export type TVLBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which TVLBreakdown to fetch.
     */
    where: TVLBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown findFirst
   */
  export type TVLBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which TVLBreakdown to fetch.
     */
    where?: TVLBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLBreakdowns to fetch.
     */
    orderBy?: TVLBreakdownOrderByWithRelationInput | TVLBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVLBreakdowns.
     */
    cursor?: TVLBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVLBreakdowns.
     */
    distinct?: TVLBreakdownScalarFieldEnum | TVLBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown findFirstOrThrow
   */
  export type TVLBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which TVLBreakdown to fetch.
     */
    where?: TVLBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLBreakdowns to fetch.
     */
    orderBy?: TVLBreakdownOrderByWithRelationInput | TVLBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVLBreakdowns.
     */
    cursor?: TVLBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVLBreakdowns.
     */
    distinct?: TVLBreakdownScalarFieldEnum | TVLBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown findMany
   */
  export type TVLBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which TVLBreakdowns to fetch.
     */
    where?: TVLBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVLBreakdowns to fetch.
     */
    orderBy?: TVLBreakdownOrderByWithRelationInput | TVLBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TVLBreakdowns.
     */
    cursor?: TVLBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVLBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVLBreakdowns.
     */
    skip?: number
    distinct?: TVLBreakdownScalarFieldEnum | TVLBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown create
   */
  export type TVLBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a TVLBreakdown.
     */
    data: XOR<TVLBreakdownCreateInput, TVLBreakdownUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown createMany
   */
  export type TVLBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TVLBreakdowns.
     */
    data: TVLBreakdownCreateManyInput | TVLBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TVLBreakdown createManyAndReturn
   */
  export type TVLBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many TVLBreakdowns.
     */
    data: TVLBreakdownCreateManyInput | TVLBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVLBreakdown update
   */
  export type TVLBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a TVLBreakdown.
     */
    data: XOR<TVLBreakdownUpdateInput, TVLBreakdownUncheckedUpdateInput>
    /**
     * Choose, which TVLBreakdown to update.
     */
    where: TVLBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown updateMany
   */
  export type TVLBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TVLBreakdowns.
     */
    data: XOR<TVLBreakdownUpdateManyMutationInput, TVLBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which TVLBreakdowns to update
     */
    where?: TVLBreakdownWhereInput
    /**
     * Limit how many TVLBreakdowns to update.
     */
    limit?: number
  }

  /**
   * TVLBreakdown updateManyAndReturn
   */
  export type TVLBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update TVLBreakdowns.
     */
    data: XOR<TVLBreakdownUpdateManyMutationInput, TVLBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which TVLBreakdowns to update
     */
    where?: TVLBreakdownWhereInput
    /**
     * Limit how many TVLBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVLBreakdown upsert
   */
  export type TVLBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the TVLBreakdown to update in case it exists.
     */
    where: TVLBreakdownWhereUniqueInput
    /**
     * In case the TVLBreakdown found by the `where` argument doesn't exist, create a new TVLBreakdown with this data.
     */
    create: XOR<TVLBreakdownCreateInput, TVLBreakdownUncheckedCreateInput>
    /**
     * In case the TVLBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TVLBreakdownUpdateInput, TVLBreakdownUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown delete
   */
  export type TVLBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
    /**
     * Filter which TVLBreakdown to delete.
     */
    where: TVLBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVLBreakdown deleteMany
   */
  export type TVLBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVLBreakdowns to delete
     */
    where?: TVLBreakdownWhereInput
    /**
     * Limit how many TVLBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * TVLBreakdown without action
   */
  export type TVLBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVLBreakdown
     */
    select?: TVLBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVLBreakdown
     */
    omit?: TVLBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVLBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model DailyRewardsRecord
   */

  export type AggregateDailyRewardsRecord = {
    _count: DailyRewardsRecordCountAggregateOutputType | null
    _avg: DailyRewardsRecordAvgAggregateOutputType | null
    _sum: DailyRewardsRecordSumAggregateOutputType | null
    _min: DailyRewardsRecordMinAggregateOutputType | null
    _max: DailyRewardsRecordMaxAggregateOutputType | null
  }

  export type DailyRewardsRecordAvgAggregateOutputType = {
    timestamp: number | null
    total: number | null
  }

  export type DailyRewardsRecordSumAggregateOutputType = {
    timestamp: bigint | null
    total: number | null
  }

  export type DailyRewardsRecordMinAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    total: number | null
    opportunityId: string | null
  }

  export type DailyRewardsRecordMaxAggregateOutputType = {
    id: string | null
    timestamp: bigint | null
    total: number | null
    opportunityId: string | null
  }

  export type DailyRewardsRecordCountAggregateOutputType = {
    id: number
    timestamp: number
    total: number
    opportunityId: number
    _all: number
  }


  export type DailyRewardsRecordAvgAggregateInputType = {
    timestamp?: true
    total?: true
  }

  export type DailyRewardsRecordSumAggregateInputType = {
    timestamp?: true
    total?: true
  }

  export type DailyRewardsRecordMinAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
  }

  export type DailyRewardsRecordMaxAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
  }

  export type DailyRewardsRecordCountAggregateInputType = {
    id?: true
    timestamp?: true
    total?: true
    opportunityId?: true
    _all?: true
  }

  export type DailyRewardsRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRewardsRecord to aggregate.
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsRecords to fetch.
     */
    orderBy?: DailyRewardsRecordOrderByWithRelationInput | DailyRewardsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRewardsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRewardsRecords
    **/
    _count?: true | DailyRewardsRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRewardsRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRewardsRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRewardsRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRewardsRecordMaxAggregateInputType
  }

  export type GetDailyRewardsRecordAggregateType<T extends DailyRewardsRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRewardsRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRewardsRecord[P]>
      : GetScalarType<T[P], AggregateDailyRewardsRecord[P]>
  }




  export type DailyRewardsRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardsRecordWhereInput
    orderBy?: DailyRewardsRecordOrderByWithAggregationInput | DailyRewardsRecordOrderByWithAggregationInput[]
    by: DailyRewardsRecordScalarFieldEnum[] | DailyRewardsRecordScalarFieldEnum
    having?: DailyRewardsRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRewardsRecordCountAggregateInputType | true
    _avg?: DailyRewardsRecordAvgAggregateInputType
    _sum?: DailyRewardsRecordSumAggregateInputType
    _min?: DailyRewardsRecordMinAggregateInputType
    _max?: DailyRewardsRecordMaxAggregateInputType
  }

  export type DailyRewardsRecordGroupByOutputType = {
    id: string
    timestamp: bigint
    total: number
    opportunityId: string
    _count: DailyRewardsRecordCountAggregateOutputType | null
    _avg: DailyRewardsRecordAvgAggregateOutputType | null
    _sum: DailyRewardsRecordSumAggregateOutputType | null
    _min: DailyRewardsRecordMinAggregateOutputType | null
    _max: DailyRewardsRecordMaxAggregateOutputType | null
  }

  type GetDailyRewardsRecordGroupByPayload<T extends DailyRewardsRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRewardsRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRewardsRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRewardsRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRewardsRecordGroupByOutputType[P]>
        }
      >
    >


  export type DailyRewardsRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    DailyRewardsBreakdown?: boolean | DailyRewardsRecord$DailyRewardsBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | DailyRewardsRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsRecord"]>

  export type DailyRewardsRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsRecord"]>

  export type DailyRewardsRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsRecord"]>

  export type DailyRewardsRecordSelectScalar = {
    id?: boolean
    timestamp?: boolean
    total?: boolean
    opportunityId?: boolean
  }

  export type DailyRewardsRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "total" | "opportunityId", ExtArgs["result"]["dailyRewardsRecord"]>
  export type DailyRewardsRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DailyRewardsBreakdown?: boolean | DailyRewardsRecord$DailyRewardsBreakdownArgs<ExtArgs>
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    _count?: boolean | DailyRewardsRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyRewardsRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type DailyRewardsRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $DailyRewardsRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRewardsRecord"
    objects: {
      DailyRewardsBreakdown: Prisma.$DailyRewardsBreakdownPayload<ExtArgs>[]
      Opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: bigint
      total: number
      opportunityId: string
    }, ExtArgs["result"]["dailyRewardsRecord"]>
    composites: {}
  }

  type DailyRewardsRecordGetPayload<S extends boolean | null | undefined | DailyRewardsRecordDefaultArgs> = $Result.GetResult<Prisma.$DailyRewardsRecordPayload, S>

  type DailyRewardsRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyRewardsRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DailyRewardsRecordCountAggregateInputType | true
    }

  export interface DailyRewardsRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRewardsRecord'], meta: { name: 'DailyRewardsRecord' } }
    /**
     * Find zero or one DailyRewardsRecord that matches the filter.
     * @param {DailyRewardsRecordFindUniqueArgs} args - Arguments to find a DailyRewardsRecord
     * @example
     * // Get one DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRewardsRecordFindUniqueArgs>(args: SelectSubset<T, DailyRewardsRecordFindUniqueArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DailyRewardsRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyRewardsRecordFindUniqueOrThrowArgs} args - Arguments to find a DailyRewardsRecord
     * @example
     * // Get one DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRewardsRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRewardsRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DailyRewardsRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordFindFirstArgs} args - Arguments to find a DailyRewardsRecord
     * @example
     * // Get one DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRewardsRecordFindFirstArgs>(args?: SelectSubset<T, DailyRewardsRecordFindFirstArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DailyRewardsRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordFindFirstOrThrowArgs} args - Arguments to find a DailyRewardsRecord
     * @example
     * // Get one DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRewardsRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRewardsRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DailyRewardsRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRewardsRecords
     * const dailyRewardsRecords = await prisma.dailyRewardsRecord.findMany()
     * 
     * // Get first 10 DailyRewardsRecords
     * const dailyRewardsRecords = await prisma.dailyRewardsRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRewardsRecordWithIdOnly = await prisma.dailyRewardsRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRewardsRecordFindManyArgs>(args?: SelectSubset<T, DailyRewardsRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DailyRewardsRecord.
     * @param {DailyRewardsRecordCreateArgs} args - Arguments to create a DailyRewardsRecord.
     * @example
     * // Create one DailyRewardsRecord
     * const DailyRewardsRecord = await prisma.dailyRewardsRecord.create({
     *   data: {
     *     // ... data to create a DailyRewardsRecord
     *   }
     * })
     * 
     */
    create<T extends DailyRewardsRecordCreateArgs>(args: SelectSubset<T, DailyRewardsRecordCreateArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DailyRewardsRecords.
     * @param {DailyRewardsRecordCreateManyArgs} args - Arguments to create many DailyRewardsRecords.
     * @example
     * // Create many DailyRewardsRecords
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRewardsRecordCreateManyArgs>(args?: SelectSubset<T, DailyRewardsRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRewardsRecords and returns the data saved in the database.
     * @param {DailyRewardsRecordCreateManyAndReturnArgs} args - Arguments to create many DailyRewardsRecords.
     * @example
     * // Create many DailyRewardsRecords
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRewardsRecords and only return the `id`
     * const dailyRewardsRecordWithIdOnly = await prisma.dailyRewardsRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRewardsRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRewardsRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DailyRewardsRecord.
     * @param {DailyRewardsRecordDeleteArgs} args - Arguments to delete one DailyRewardsRecord.
     * @example
     * // Delete one DailyRewardsRecord
     * const DailyRewardsRecord = await prisma.dailyRewardsRecord.delete({
     *   where: {
     *     // ... filter to delete one DailyRewardsRecord
     *   }
     * })
     * 
     */
    delete<T extends DailyRewardsRecordDeleteArgs>(args: SelectSubset<T, DailyRewardsRecordDeleteArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DailyRewardsRecord.
     * @param {DailyRewardsRecordUpdateArgs} args - Arguments to update one DailyRewardsRecord.
     * @example
     * // Update one DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRewardsRecordUpdateArgs>(args: SelectSubset<T, DailyRewardsRecordUpdateArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DailyRewardsRecords.
     * @param {DailyRewardsRecordDeleteManyArgs} args - Arguments to filter DailyRewardsRecords to delete.
     * @example
     * // Delete a few DailyRewardsRecords
     * const { count } = await prisma.dailyRewardsRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRewardsRecordDeleteManyArgs>(args?: SelectSubset<T, DailyRewardsRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewardsRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRewardsRecords
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRewardsRecordUpdateManyArgs>(args: SelectSubset<T, DailyRewardsRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewardsRecords and returns the data updated in the database.
     * @param {DailyRewardsRecordUpdateManyAndReturnArgs} args - Arguments to update many DailyRewardsRecords.
     * @example
     * // Update many DailyRewardsRecords
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyRewardsRecords and only return the `id`
     * const dailyRewardsRecordWithIdOnly = await prisma.dailyRewardsRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyRewardsRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyRewardsRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DailyRewardsRecord.
     * @param {DailyRewardsRecordUpsertArgs} args - Arguments to update or create a DailyRewardsRecord.
     * @example
     * // Update or create a DailyRewardsRecord
     * const dailyRewardsRecord = await prisma.dailyRewardsRecord.upsert({
     *   create: {
     *     // ... data to create a DailyRewardsRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRewardsRecord we want to update
     *   }
     * })
     */
    upsert<T extends DailyRewardsRecordUpsertArgs>(args: SelectSubset<T, DailyRewardsRecordUpsertArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DailyRewardsRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordCountArgs} args - Arguments to filter DailyRewardsRecords to count.
     * @example
     * // Count the number of DailyRewardsRecords
     * const count = await prisma.dailyRewardsRecord.count({
     *   where: {
     *     // ... the filter for the DailyRewardsRecords we want to count
     *   }
     * })
    **/
    count<T extends DailyRewardsRecordCountArgs>(
      args?: Subset<T, DailyRewardsRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRewardsRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRewardsRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRewardsRecordAggregateArgs>(args: Subset<T, DailyRewardsRecordAggregateArgs>): Prisma.PrismaPromise<GetDailyRewardsRecordAggregateType<T>>

    /**
     * Group by DailyRewardsRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRewardsRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRewardsRecordGroupByArgs['orderBy'] }
        : { orderBy?: DailyRewardsRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRewardsRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRewardsRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRewardsRecord model
   */
  readonly fields: DailyRewardsRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRewardsRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRewardsRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DailyRewardsBreakdown<T extends DailyRewardsRecord$DailyRewardsBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, DailyRewardsRecord$DailyRewardsBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRewardsRecord model
   */ 
  interface DailyRewardsRecordFieldRefs {
    readonly id: FieldRef<"DailyRewardsRecord", 'String'>
    readonly timestamp: FieldRef<"DailyRewardsRecord", 'BigInt'>
    readonly total: FieldRef<"DailyRewardsRecord", 'Float'>
    readonly opportunityId: FieldRef<"DailyRewardsRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyRewardsRecord findUnique
   */
  export type DailyRewardsRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsRecord to fetch.
     */
    where: DailyRewardsRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord findUniqueOrThrow
   */
  export type DailyRewardsRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsRecord to fetch.
     */
    where: DailyRewardsRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord findFirst
   */
  export type DailyRewardsRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsRecord to fetch.
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsRecords to fetch.
     */
    orderBy?: DailyRewardsRecordOrderByWithRelationInput | DailyRewardsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewardsRecords.
     */
    cursor?: DailyRewardsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewardsRecords.
     */
    distinct?: DailyRewardsRecordScalarFieldEnum | DailyRewardsRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord findFirstOrThrow
   */
  export type DailyRewardsRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsRecord to fetch.
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsRecords to fetch.
     */
    orderBy?: DailyRewardsRecordOrderByWithRelationInput | DailyRewardsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewardsRecords.
     */
    cursor?: DailyRewardsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewardsRecords.
     */
    distinct?: DailyRewardsRecordScalarFieldEnum | DailyRewardsRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord findMany
   */
  export type DailyRewardsRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsRecords to fetch.
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsRecords to fetch.
     */
    orderBy?: DailyRewardsRecordOrderByWithRelationInput | DailyRewardsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRewardsRecords.
     */
    cursor?: DailyRewardsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsRecords.
     */
    skip?: number
    distinct?: DailyRewardsRecordScalarFieldEnum | DailyRewardsRecordScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord create
   */
  export type DailyRewardsRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRewardsRecord.
     */
    data: XOR<DailyRewardsRecordCreateInput, DailyRewardsRecordUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord createMany
   */
  export type DailyRewardsRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRewardsRecords.
     */
    data: DailyRewardsRecordCreateManyInput | DailyRewardsRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRewardsRecord createManyAndReturn
   */
  export type DailyRewardsRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * The data used to create many DailyRewardsRecords.
     */
    data: DailyRewardsRecordCreateManyInput | DailyRewardsRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRewardsRecord update
   */
  export type DailyRewardsRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRewardsRecord.
     */
    data: XOR<DailyRewardsRecordUpdateInput, DailyRewardsRecordUncheckedUpdateInput>
    /**
     * Choose, which DailyRewardsRecord to update.
     */
    where: DailyRewardsRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord updateMany
   */
  export type DailyRewardsRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRewardsRecords.
     */
    data: XOR<DailyRewardsRecordUpdateManyMutationInput, DailyRewardsRecordUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewardsRecords to update
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * Limit how many DailyRewardsRecords to update.
     */
    limit?: number
  }

  /**
   * DailyRewardsRecord updateManyAndReturn
   */
  export type DailyRewardsRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * The data used to update DailyRewardsRecords.
     */
    data: XOR<DailyRewardsRecordUpdateManyMutationInput, DailyRewardsRecordUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewardsRecords to update
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * Limit how many DailyRewardsRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRewardsRecord upsert
   */
  export type DailyRewardsRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRewardsRecord to update in case it exists.
     */
    where: DailyRewardsRecordWhereUniqueInput
    /**
     * In case the DailyRewardsRecord found by the `where` argument doesn't exist, create a new DailyRewardsRecord with this data.
     */
    create: XOR<DailyRewardsRecordCreateInput, DailyRewardsRecordUncheckedCreateInput>
    /**
     * In case the DailyRewardsRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRewardsRecordUpdateInput, DailyRewardsRecordUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord delete
   */
  export type DailyRewardsRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
    /**
     * Filter which DailyRewardsRecord to delete.
     */
    where: DailyRewardsRecordWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsRecord deleteMany
   */
  export type DailyRewardsRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRewardsRecords to delete
     */
    where?: DailyRewardsRecordWhereInput
    /**
     * Limit how many DailyRewardsRecords to delete.
     */
    limit?: number
  }

  /**
   * DailyRewardsRecord.DailyRewardsBreakdown
   */
  export type DailyRewardsRecord$DailyRewardsBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    where?: DailyRewardsBreakdownWhereInput
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRewardsBreakdownScalarFieldEnum | DailyRewardsBreakdownScalarFieldEnum[]
  }

  /**
   * DailyRewardsRecord without action
   */
  export type DailyRewardsRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsRecord
     */
    select?: DailyRewardsRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsRecord
     */
    omit?: DailyRewardsRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsRecordInclude<ExtArgs> | null
  }


  /**
   * Model DailyRewardsBreakdown
   */

  export type AggregateDailyRewardsBreakdown = {
    _count: DailyRewardsBreakdownCountAggregateOutputType | null
    _avg: DailyRewardsBreakdownAvgAggregateOutputType | null
    _sum: DailyRewardsBreakdownSumAggregateOutputType | null
    _min: DailyRewardsBreakdownMinAggregateOutputType | null
    _max: DailyRewardsBreakdownMaxAggregateOutputType | null
  }

  export type DailyRewardsBreakdownAvgAggregateOutputType = {
    value: number | null
  }

  export type DailyRewardsBreakdownSumAggregateOutputType = {
    value: number | null
  }

  export type DailyRewardsBreakdownMinAggregateOutputType = {
    id: string | null
    value: number | null
    campaignId: string | null
    dailyRewardsRecordId: string | null
  }

  export type DailyRewardsBreakdownMaxAggregateOutputType = {
    id: string | null
    value: number | null
    campaignId: string | null
    dailyRewardsRecordId: string | null
  }

  export type DailyRewardsBreakdownCountAggregateOutputType = {
    id: number
    value: number
    campaignId: number
    dailyRewardsRecordId: number
    _all: number
  }


  export type DailyRewardsBreakdownAvgAggregateInputType = {
    value?: true
  }

  export type DailyRewardsBreakdownSumAggregateInputType = {
    value?: true
  }

  export type DailyRewardsBreakdownMinAggregateInputType = {
    id?: true
    value?: true
    campaignId?: true
    dailyRewardsRecordId?: true
  }

  export type DailyRewardsBreakdownMaxAggregateInputType = {
    id?: true
    value?: true
    campaignId?: true
    dailyRewardsRecordId?: true
  }

  export type DailyRewardsBreakdownCountAggregateInputType = {
    id?: true
    value?: true
    campaignId?: true
    dailyRewardsRecordId?: true
    _all?: true
  }

  export type DailyRewardsBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRewardsBreakdown to aggregate.
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsBreakdowns to fetch.
     */
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRewardsBreakdowns
    **/
    _count?: true | DailyRewardsBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRewardsBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRewardsBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRewardsBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRewardsBreakdownMaxAggregateInputType
  }

  export type GetDailyRewardsBreakdownAggregateType<T extends DailyRewardsBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRewardsBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRewardsBreakdown[P]>
      : GetScalarType<T[P], AggregateDailyRewardsBreakdown[P]>
  }




  export type DailyRewardsBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRewardsBreakdownWhereInput
    orderBy?: DailyRewardsBreakdownOrderByWithAggregationInput | DailyRewardsBreakdownOrderByWithAggregationInput[]
    by: DailyRewardsBreakdownScalarFieldEnum[] | DailyRewardsBreakdownScalarFieldEnum
    having?: DailyRewardsBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRewardsBreakdownCountAggregateInputType | true
    _avg?: DailyRewardsBreakdownAvgAggregateInputType
    _sum?: DailyRewardsBreakdownSumAggregateInputType
    _min?: DailyRewardsBreakdownMinAggregateInputType
    _max?: DailyRewardsBreakdownMaxAggregateInputType
  }

  export type DailyRewardsBreakdownGroupByOutputType = {
    id: string
    value: number
    campaignId: string
    dailyRewardsRecordId: string
    _count: DailyRewardsBreakdownCountAggregateOutputType | null
    _avg: DailyRewardsBreakdownAvgAggregateOutputType | null
    _sum: DailyRewardsBreakdownSumAggregateOutputType | null
    _min: DailyRewardsBreakdownMinAggregateOutputType | null
    _max: DailyRewardsBreakdownMaxAggregateOutputType | null
  }

  type GetDailyRewardsBreakdownGroupByPayload<T extends DailyRewardsBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRewardsBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRewardsBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRewardsBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRewardsBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type DailyRewardsBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    campaignId?: boolean
    dailyRewardsRecordId?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsBreakdown"]>

  export type DailyRewardsBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    campaignId?: boolean
    dailyRewardsRecordId?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsBreakdown"]>

  export type DailyRewardsBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    campaignId?: boolean
    dailyRewardsRecordId?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRewardsBreakdown"]>

  export type DailyRewardsBreakdownSelectScalar = {
    id?: boolean
    value?: boolean
    campaignId?: boolean
    dailyRewardsRecordId?: boolean
  }

  export type DailyRewardsBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "campaignId" | "dailyRewardsRecordId", ExtArgs["result"]["dailyRewardsBreakdown"]>
  export type DailyRewardsBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }
  export type DailyRewardsBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }
  export type DailyRewardsBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    DailyRewardsRecord?: boolean | DailyRewardsRecordDefaultArgs<ExtArgs>
  }

  export type $DailyRewardsBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRewardsBreakdown"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
      DailyRewardsRecord: Prisma.$DailyRewardsRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number
      campaignId: string
      dailyRewardsRecordId: string
    }, ExtArgs["result"]["dailyRewardsBreakdown"]>
    composites: {}
  }

  type DailyRewardsBreakdownGetPayload<S extends boolean | null | undefined | DailyRewardsBreakdownDefaultArgs> = $Result.GetResult<Prisma.$DailyRewardsBreakdownPayload, S>

  type DailyRewardsBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyRewardsBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DailyRewardsBreakdownCountAggregateInputType | true
    }

  export interface DailyRewardsBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRewardsBreakdown'], meta: { name: 'DailyRewardsBreakdown' } }
    /**
     * Find zero or one DailyRewardsBreakdown that matches the filter.
     * @param {DailyRewardsBreakdownFindUniqueArgs} args - Arguments to find a DailyRewardsBreakdown
     * @example
     * // Get one DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRewardsBreakdownFindUniqueArgs>(args: SelectSubset<T, DailyRewardsBreakdownFindUniqueArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DailyRewardsBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyRewardsBreakdownFindUniqueOrThrowArgs} args - Arguments to find a DailyRewardsBreakdown
     * @example
     * // Get one DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRewardsBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRewardsBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DailyRewardsBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownFindFirstArgs} args - Arguments to find a DailyRewardsBreakdown
     * @example
     * // Get one DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRewardsBreakdownFindFirstArgs>(args?: SelectSubset<T, DailyRewardsBreakdownFindFirstArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DailyRewardsBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownFindFirstOrThrowArgs} args - Arguments to find a DailyRewardsBreakdown
     * @example
     * // Get one DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRewardsBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRewardsBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DailyRewardsBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRewardsBreakdowns
     * const dailyRewardsBreakdowns = await prisma.dailyRewardsBreakdown.findMany()
     * 
     * // Get first 10 DailyRewardsBreakdowns
     * const dailyRewardsBreakdowns = await prisma.dailyRewardsBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRewardsBreakdownWithIdOnly = await prisma.dailyRewardsBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRewardsBreakdownFindManyArgs>(args?: SelectSubset<T, DailyRewardsBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DailyRewardsBreakdown.
     * @param {DailyRewardsBreakdownCreateArgs} args - Arguments to create a DailyRewardsBreakdown.
     * @example
     * // Create one DailyRewardsBreakdown
     * const DailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.create({
     *   data: {
     *     // ... data to create a DailyRewardsBreakdown
     *   }
     * })
     * 
     */
    create<T extends DailyRewardsBreakdownCreateArgs>(args: SelectSubset<T, DailyRewardsBreakdownCreateArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DailyRewardsBreakdowns.
     * @param {DailyRewardsBreakdownCreateManyArgs} args - Arguments to create many DailyRewardsBreakdowns.
     * @example
     * // Create many DailyRewardsBreakdowns
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRewardsBreakdownCreateManyArgs>(args?: SelectSubset<T, DailyRewardsBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRewardsBreakdowns and returns the data saved in the database.
     * @param {DailyRewardsBreakdownCreateManyAndReturnArgs} args - Arguments to create many DailyRewardsBreakdowns.
     * @example
     * // Create many DailyRewardsBreakdowns
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRewardsBreakdowns and only return the `id`
     * const dailyRewardsBreakdownWithIdOnly = await prisma.dailyRewardsBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRewardsBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRewardsBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DailyRewardsBreakdown.
     * @param {DailyRewardsBreakdownDeleteArgs} args - Arguments to delete one DailyRewardsBreakdown.
     * @example
     * // Delete one DailyRewardsBreakdown
     * const DailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.delete({
     *   where: {
     *     // ... filter to delete one DailyRewardsBreakdown
     *   }
     * })
     * 
     */
    delete<T extends DailyRewardsBreakdownDeleteArgs>(args: SelectSubset<T, DailyRewardsBreakdownDeleteArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DailyRewardsBreakdown.
     * @param {DailyRewardsBreakdownUpdateArgs} args - Arguments to update one DailyRewardsBreakdown.
     * @example
     * // Update one DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRewardsBreakdownUpdateArgs>(args: SelectSubset<T, DailyRewardsBreakdownUpdateArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DailyRewardsBreakdowns.
     * @param {DailyRewardsBreakdownDeleteManyArgs} args - Arguments to filter DailyRewardsBreakdowns to delete.
     * @example
     * // Delete a few DailyRewardsBreakdowns
     * const { count } = await prisma.dailyRewardsBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRewardsBreakdownDeleteManyArgs>(args?: SelectSubset<T, DailyRewardsBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewardsBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRewardsBreakdowns
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRewardsBreakdownUpdateManyArgs>(args: SelectSubset<T, DailyRewardsBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewardsBreakdowns and returns the data updated in the database.
     * @param {DailyRewardsBreakdownUpdateManyAndReturnArgs} args - Arguments to update many DailyRewardsBreakdowns.
     * @example
     * // Update many DailyRewardsBreakdowns
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyRewardsBreakdowns and only return the `id`
     * const dailyRewardsBreakdownWithIdOnly = await prisma.dailyRewardsBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyRewardsBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyRewardsBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DailyRewardsBreakdown.
     * @param {DailyRewardsBreakdownUpsertArgs} args - Arguments to update or create a DailyRewardsBreakdown.
     * @example
     * // Update or create a DailyRewardsBreakdown
     * const dailyRewardsBreakdown = await prisma.dailyRewardsBreakdown.upsert({
     *   create: {
     *     // ... data to create a DailyRewardsBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRewardsBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends DailyRewardsBreakdownUpsertArgs>(args: SelectSubset<T, DailyRewardsBreakdownUpsertArgs<ExtArgs>>): Prisma__DailyRewardsBreakdownClient<$Result.GetResult<Prisma.$DailyRewardsBreakdownPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DailyRewardsBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownCountArgs} args - Arguments to filter DailyRewardsBreakdowns to count.
     * @example
     * // Count the number of DailyRewardsBreakdowns
     * const count = await prisma.dailyRewardsBreakdown.count({
     *   where: {
     *     // ... the filter for the DailyRewardsBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends DailyRewardsBreakdownCountArgs>(
      args?: Subset<T, DailyRewardsBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRewardsBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRewardsBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRewardsBreakdownAggregateArgs>(args: Subset<T, DailyRewardsBreakdownAggregateArgs>): Prisma.PrismaPromise<GetDailyRewardsBreakdownAggregateType<T>>

    /**
     * Group by DailyRewardsBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardsBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRewardsBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRewardsBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: DailyRewardsBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRewardsBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRewardsBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRewardsBreakdown model
   */
  readonly fields: DailyRewardsBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRewardsBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRewardsBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DailyRewardsRecord<T extends DailyRewardsRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyRewardsRecordDefaultArgs<ExtArgs>>): Prisma__DailyRewardsRecordClient<$Result.GetResult<Prisma.$DailyRewardsRecordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRewardsBreakdown model
   */ 
  interface DailyRewardsBreakdownFieldRefs {
    readonly id: FieldRef<"DailyRewardsBreakdown", 'String'>
    readonly value: FieldRef<"DailyRewardsBreakdown", 'Float'>
    readonly campaignId: FieldRef<"DailyRewardsBreakdown", 'String'>
    readonly dailyRewardsRecordId: FieldRef<"DailyRewardsBreakdown", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyRewardsBreakdown findUnique
   */
  export type DailyRewardsBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsBreakdown to fetch.
     */
    where: DailyRewardsBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown findUniqueOrThrow
   */
  export type DailyRewardsBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsBreakdown to fetch.
     */
    where: DailyRewardsBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown findFirst
   */
  export type DailyRewardsBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsBreakdown to fetch.
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsBreakdowns to fetch.
     */
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewardsBreakdowns.
     */
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewardsBreakdowns.
     */
    distinct?: DailyRewardsBreakdownScalarFieldEnum | DailyRewardsBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown findFirstOrThrow
   */
  export type DailyRewardsBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsBreakdown to fetch.
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsBreakdowns to fetch.
     */
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewardsBreakdowns.
     */
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewardsBreakdowns.
     */
    distinct?: DailyRewardsBreakdownScalarFieldEnum | DailyRewardsBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown findMany
   */
  export type DailyRewardsBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which DailyRewardsBreakdowns to fetch.
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewardsBreakdowns to fetch.
     */
    orderBy?: DailyRewardsBreakdownOrderByWithRelationInput | DailyRewardsBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRewardsBreakdowns.
     */
    cursor?: DailyRewardsBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewardsBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewardsBreakdowns.
     */
    skip?: number
    distinct?: DailyRewardsBreakdownScalarFieldEnum | DailyRewardsBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown create
   */
  export type DailyRewardsBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRewardsBreakdown.
     */
    data: XOR<DailyRewardsBreakdownCreateInput, DailyRewardsBreakdownUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown createMany
   */
  export type DailyRewardsBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRewardsBreakdowns.
     */
    data: DailyRewardsBreakdownCreateManyInput | DailyRewardsBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRewardsBreakdown createManyAndReturn
   */
  export type DailyRewardsBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many DailyRewardsBreakdowns.
     */
    data: DailyRewardsBreakdownCreateManyInput | DailyRewardsBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRewardsBreakdown update
   */
  export type DailyRewardsBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRewardsBreakdown.
     */
    data: XOR<DailyRewardsBreakdownUpdateInput, DailyRewardsBreakdownUncheckedUpdateInput>
    /**
     * Choose, which DailyRewardsBreakdown to update.
     */
    where: DailyRewardsBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown updateMany
   */
  export type DailyRewardsBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRewardsBreakdowns.
     */
    data: XOR<DailyRewardsBreakdownUpdateManyMutationInput, DailyRewardsBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewardsBreakdowns to update
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * Limit how many DailyRewardsBreakdowns to update.
     */
    limit?: number
  }

  /**
   * DailyRewardsBreakdown updateManyAndReturn
   */
  export type DailyRewardsBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update DailyRewardsBreakdowns.
     */
    data: XOR<DailyRewardsBreakdownUpdateManyMutationInput, DailyRewardsBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewardsBreakdowns to update
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * Limit how many DailyRewardsBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRewardsBreakdown upsert
   */
  export type DailyRewardsBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRewardsBreakdown to update in case it exists.
     */
    where: DailyRewardsBreakdownWhereUniqueInput
    /**
     * In case the DailyRewardsBreakdown found by the `where` argument doesn't exist, create a new DailyRewardsBreakdown with this data.
     */
    create: XOR<DailyRewardsBreakdownCreateInput, DailyRewardsBreakdownUncheckedCreateInput>
    /**
     * In case the DailyRewardsBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRewardsBreakdownUpdateInput, DailyRewardsBreakdownUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown delete
   */
  export type DailyRewardsBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
    /**
     * Filter which DailyRewardsBreakdown to delete.
     */
    where: DailyRewardsBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DailyRewardsBreakdown deleteMany
   */
  export type DailyRewardsBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRewardsBreakdowns to delete
     */
    where?: DailyRewardsBreakdownWhereInput
    /**
     * Limit how many DailyRewardsBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * DailyRewardsBreakdown without action
   */
  export type DailyRewardsBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRewardsBreakdown
     */
    select?: DailyRewardsBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRewardsBreakdown
     */
    omit?: DailyRewardsBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRewardsBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    address: string | null
    creatorId: string | null
  }

  export type UserMaxAggregateOutputType = {
    address: string | null
    creatorId: string | null
  }

  export type UserCountAggregateOutputType = {
    address: number
    tags: number
    creatorId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    address?: true
    creatorId?: true
  }

  export type UserMaxAggregateInputType = {
    address?: true
    creatorId?: true
  }

  export type UserCountAggregateInputType = {
    address?: true
    tags?: true
    creatorId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    address: string
    tags: string[]
    creatorId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    tags?: boolean
    creatorId?: boolean
    Rewards?: boolean | User$RewardsArgs<ExtArgs>
    Blacklist?: boolean | User$BlacklistArgs<ExtArgs>
    CampaignsCreated?: boolean | User$CampaignsCreatedArgs<ExtArgs>
    UserComputedValue?: boolean | User$UserComputedValueArgs<ExtArgs>
    Creator?: boolean | User$CreatorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    tags?: boolean
    creatorId?: boolean
    Creator?: boolean | User$CreatorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    address?: boolean
    tags?: boolean
    creatorId?: boolean
    Creator?: boolean | User$CreatorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    address?: boolean
    tags?: boolean
    creatorId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"address" | "tags" | "creatorId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Rewards?: boolean | User$RewardsArgs<ExtArgs>
    Blacklist?: boolean | User$BlacklistArgs<ExtArgs>
    CampaignsCreated?: boolean | User$CampaignsCreatedArgs<ExtArgs>
    UserComputedValue?: boolean | User$UserComputedValueArgs<ExtArgs>
    Creator?: boolean | User$CreatorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Creator?: boolean | User$CreatorArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Creator?: boolean | User$CreatorArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Rewards: Prisma.$RewardPayload<ExtArgs>[]
      Blacklist: Prisma.$BlacklistPayload<ExtArgs>[]
      CampaignsCreated: Prisma.$CampaignPayload<ExtArgs>[]
      UserComputedValue: Prisma.$UserComputedValuePayload<ExtArgs>[]
      Creator: Prisma.$CreatorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      address: string
      tags: string[]
      creatorId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `address`
     * const userWithAddressOnly = await prisma.user.findMany({ select: { address: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `address`
     * const userWithAddressOnly = await prisma.user.createManyAndReturn({
     *   select: { address: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `address`
     * const userWithAddressOnly = await prisma.user.updateManyAndReturn({
     *   select: { address: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Rewards<T extends User$RewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$RewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Blacklist<T extends User$BlacklistArgs<ExtArgs> = {}>(args?: Subset<T, User$BlacklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    CampaignsCreated<T extends User$CampaignsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$CampaignsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserComputedValue<T extends User$UserComputedValueArgs<ExtArgs> = {}>(args?: Subset<T, User$UserComputedValueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserComputedValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Creator<T extends User$CreatorArgs<ExtArgs> = {}>(args?: Subset<T, User$CreatorArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly address: FieldRef<"User", 'String'>
    readonly tags: FieldRef<"User", 'String[]'>
    readonly creatorId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Rewards
   */
  export type User$RewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * User.Blacklist
   */
  export type User$BlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    cursor?: BlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * User.CampaignsCreated
   */
  export type User$CampaignsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.UserComputedValue
   */
  export type User$UserComputedValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComputedValue
     */
    select?: UserComputedValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComputedValue
     */
    omit?: UserComputedValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserComputedValueInclude<ExtArgs> | null
    where?: UserComputedValueWhereInput
    orderBy?: UserComputedValueOrderByWithRelationInput | UserComputedValueOrderByWithRelationInput[]
    cursor?: UserComputedValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserComputedValueScalarFieldEnum | UserComputedValueScalarFieldEnum[]
  }

  /**
   * User.Creator
   */
  export type User$CreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    where?: CreatorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Creator
   */

  export type AggregateCreator = {
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  export type CreatorAvgAggregateOutputType = {
    rebateFee: number | null
  }

  export type CreatorSumAggregateOutputType = {
    rebateFee: number | null
  }

  export type CreatorMinAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    rebateFee: number | null
  }

  export type CreatorMaxAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    rebateFee: number | null
  }

  export type CreatorCountAggregateOutputType = {
    id: number
    icon: number
    name: number
    rebateFee: number
    _all: number
  }


  export type CreatorAvgAggregateInputType = {
    rebateFee?: true
  }

  export type CreatorSumAggregateInputType = {
    rebateFee?: true
  }

  export type CreatorMinAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    rebateFee?: true
  }

  export type CreatorMaxAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    rebateFee?: true
  }

  export type CreatorCountAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    rebateFee?: true
    _all?: true
  }

  export type CreatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creator to aggregate.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creators
    **/
    _count?: true | CreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorMaxAggregateInputType
  }

  export type GetCreatorAggregateType<T extends CreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreator[P]>
      : GetScalarType<T[P], AggregateCreator[P]>
  }




  export type CreatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatorWhereInput
    orderBy?: CreatorOrderByWithAggregationInput | CreatorOrderByWithAggregationInput[]
    by: CreatorScalarFieldEnum[] | CreatorScalarFieldEnum
    having?: CreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorCountAggregateInputType | true
    _avg?: CreatorAvgAggregateInputType
    _sum?: CreatorSumAggregateInputType
    _min?: CreatorMinAggregateInputType
    _max?: CreatorMaxAggregateInputType
  }

  export type CreatorGroupByOutputType = {
    id: string
    icon: string | null
    name: string
    rebateFee: number
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  type GetCreatorGroupByPayload<T extends CreatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    name?: boolean
    rebateFee?: boolean
    Users?: boolean | Creator$UsersArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    name?: boolean
    rebateFee?: boolean
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    name?: boolean
    rebateFee?: boolean
  }, ExtArgs["result"]["creator"]>

  export type CreatorSelectScalar = {
    id?: boolean
    icon?: boolean
    name?: boolean
    rebateFee?: boolean
  }

  export type CreatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "icon" | "name" | "rebateFee", ExtArgs["result"]["creator"]>
  export type CreatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Creator$UsersArgs<ExtArgs>
    _count?: boolean | CreatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CreatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creator"
    objects: {
      Users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      icon: string | null
      name: string
      rebateFee: number
    }, ExtArgs["result"]["creator"]>
    composites: {}
  }

  type CreatorGetPayload<S extends boolean | null | undefined | CreatorDefaultArgs> = $Result.GetResult<Prisma.$CreatorPayload, S>

  type CreatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CreatorCountAggregateInputType | true
    }

  export interface CreatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creator'], meta: { name: 'Creator' } }
    /**
     * Find zero or one Creator that matches the filter.
     * @param {CreatorFindUniqueArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatorFindUniqueArgs>(args: SelectSubset<T, CreatorFindUniqueArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Creator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatorFindUniqueOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Creator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatorFindFirstArgs>(args?: SelectSubset<T, CreatorFindFirstArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Creator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Creators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creators
     * const creators = await prisma.creator.findMany()
     * 
     * // Get first 10 Creators
     * const creators = await prisma.creator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorWithIdOnly = await prisma.creator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatorFindManyArgs>(args?: SelectSubset<T, CreatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Creator.
     * @param {CreatorCreateArgs} args - Arguments to create a Creator.
     * @example
     * // Create one Creator
     * const Creator = await prisma.creator.create({
     *   data: {
     *     // ... data to create a Creator
     *   }
     * })
     * 
     */
    create<T extends CreatorCreateArgs>(args: SelectSubset<T, CreatorCreateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Creators.
     * @param {CreatorCreateManyArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatorCreateManyArgs>(args?: SelectSubset<T, CreatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creators and returns the data saved in the database.
     * @param {CreatorCreateManyAndReturnArgs} args - Arguments to create many Creators.
     * @example
     * // Create many Creators
     * const creator = await prisma.creator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creators and only return the `id`
     * const creatorWithIdOnly = await prisma.creator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatorCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Creator.
     * @param {CreatorDeleteArgs} args - Arguments to delete one Creator.
     * @example
     * // Delete one Creator
     * const Creator = await prisma.creator.delete({
     *   where: {
     *     // ... filter to delete one Creator
     *   }
     * })
     * 
     */
    delete<T extends CreatorDeleteArgs>(args: SelectSubset<T, CreatorDeleteArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Creator.
     * @param {CreatorUpdateArgs} args - Arguments to update one Creator.
     * @example
     * // Update one Creator
     * const creator = await prisma.creator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatorUpdateArgs>(args: SelectSubset<T, CreatorUpdateArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Creators.
     * @param {CreatorDeleteManyArgs} args - Arguments to filter Creators to delete.
     * @example
     * // Delete a few Creators
     * const { count } = await prisma.creator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatorDeleteManyArgs>(args?: SelectSubset<T, CreatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatorUpdateManyArgs>(args: SelectSubset<T, CreatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators and returns the data updated in the database.
     * @param {CreatorUpdateManyAndReturnArgs} args - Arguments to update many Creators.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Creators and only return the `id`
     * const creatorWithIdOnly = await prisma.creator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatorUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Creator.
     * @param {CreatorUpsertArgs} args - Arguments to update or create a Creator.
     * @example
     * // Update or create a Creator
     * const creator = await prisma.creator.upsert({
     *   create: {
     *     // ... data to create a Creator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creator we want to update
     *   }
     * })
     */
    upsert<T extends CreatorUpsertArgs>(args: SelectSubset<T, CreatorUpsertArgs<ExtArgs>>): Prisma__CreatorClient<$Result.GetResult<Prisma.$CreatorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorCountArgs} args - Arguments to filter Creators to count.
     * @example
     * // Count the number of Creators
     * const count = await prisma.creator.count({
     *   where: {
     *     // ... the filter for the Creators we want to count
     *   }
     * })
    **/
    count<T extends CreatorCountArgs>(
      args?: Subset<T, CreatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAggregateArgs>(args: Subset<T, CreatorAggregateArgs>): Prisma.PrismaPromise<GetCreatorAggregateType<T>>

    /**
     * Group by Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorGroupByArgs['orderBy'] }
        : { orderBy?: CreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creator model
   */
  readonly fields: CreatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Creator$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Creator$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creator model
   */ 
  interface CreatorFieldRefs {
    readonly id: FieldRef<"Creator", 'String'>
    readonly icon: FieldRef<"Creator", 'String'>
    readonly name: FieldRef<"Creator", 'String'>
    readonly rebateFee: FieldRef<"Creator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Creator findUnique
   */
  export type CreatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator findUniqueOrThrow
   */
  export type CreatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where: CreatorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator findFirst
   */
  export type CreatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator findFirstOrThrow
   */
  export type CreatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creator to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     */
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator findMany
   */
  export type CreatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter, which Creators to fetch.
     */
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     */
    orderBy?: CreatorOrderByWithRelationInput | CreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creators.
     */
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     */
    skip?: number
    distinct?: CreatorScalarFieldEnum | CreatorScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator create
   */
  export type CreatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Creator.
     */
    data: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator createMany
   */
  export type CreatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator createManyAndReturn
   */
  export type CreatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * The data used to create many Creators.
     */
    data: CreatorCreateManyInput | CreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creator update
   */
  export type CreatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Creator.
     */
    data: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    /**
     * Choose, which Creator to update.
     */
    where: CreatorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator updateMany
   */
  export type CreatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creators.
     */
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     */
    where?: CreatorWhereInput
    /**
     * Limit how many Creators to update.
     */
    limit?: number
  }

  /**
   * Creator updateManyAndReturn
   */
  export type CreatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * The data used to update Creators.
     */
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     */
    where?: CreatorWhereInput
    /**
     * Limit how many Creators to update.
     */
    limit?: number
  }

  /**
   * Creator upsert
   */
  export type CreatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Creator to update in case it exists.
     */
    where: CreatorWhereUniqueInput
    /**
     * In case the Creator found by the `where` argument doesn't exist, create a new Creator with this data.
     */
    create: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    /**
     * In case the Creator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator delete
   */
  export type CreatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
    /**
     * Filter which Creator to delete.
     */
    where: CreatorWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Creator deleteMany
   */
  export type CreatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creators to delete
     */
    where?: CreatorWhereInput
    /**
     * Limit how many Creators to delete.
     */
    limit?: number
  }

  /**
   * Creator.Users
   */
  export type Creator$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Creator without action
   */
  export type CreatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creator
     */
    select?: CreatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creator
     */
    omit?: CreatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatorInclude<ExtArgs> | null
  }


  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    root: string | null
    recipient: string | null
    rewardTokenId: string | null
    amount: string | null
    claimed: string | null
    pending: string | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    root: string | null
    recipient: string | null
    rewardTokenId: string | null
    amount: string | null
    claimed: string | null
    pending: string | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    root: number
    recipient: number
    rewardTokenId: number
    amount: number
    claimed: number
    pending: number
    proofs: number
    _all: number
  }


  export type RewardMinAggregateInputType = {
    id?: true
    root?: true
    recipient?: true
    rewardTokenId?: true
    amount?: true
    claimed?: true
    pending?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    root?: true
    recipient?: true
    rewardTokenId?: true
    amount?: true
    claimed?: true
    pending?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    root?: true
    recipient?: true
    rewardTokenId?: true
    amount?: true
    claimed?: true
    pending?: true
    proofs?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithAggregationInput | RewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: string
    root: string
    recipient: string
    rewardTokenId: string
    amount: string
    claimed: string
    pending: string
    proofs: string[]
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    root?: boolean
    recipient?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    proofs?: boolean
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Breakdown?: boolean | Reward$BreakdownArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    root?: boolean
    recipient?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    proofs?: boolean
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    root?: boolean
    recipient?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    proofs?: boolean
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    root?: boolean
    recipient?: boolean
    rewardTokenId?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    proofs?: boolean
  }

  export type RewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "root" | "recipient" | "rewardTokenId" | "amount" | "claimed" | "pending" | "proofs", ExtArgs["result"]["reward"]>
  export type RewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
    Breakdown?: boolean | Reward$BreakdownArgs<ExtArgs>
    _count?: boolean | RewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type RewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MerklRoot?: boolean | MerklRootDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    RewardToken?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reward"
    objects: {
      MerklRoot: Prisma.$MerklRootPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      RewardToken: Prisma.$TokenPayload<ExtArgs>
      Breakdown: Prisma.$RewardBreakdownPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      root: string
      recipient: string
      rewardTokenId: string
      amount: string
      claimed: string
      pending: string
      proofs: string[]
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type RewardGetPayload<S extends boolean | null | undefined | RewardDefaultArgs> = $Result.GetResult<Prisma.$RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardFindManyArgs>(args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends RewardCreateArgs>(args: SelectSubset<T, RewardCreateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardCreateManyArgs>(args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends RewardDeleteArgs>(args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardUpdateArgs>(args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDeleteManyArgs>(args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardUpdateManyArgs>(args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {RewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reward model
   */
  readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MerklRoot<T extends MerklRootDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerklRootDefaultArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    RewardToken<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Breakdown<T extends Reward$BreakdownArgs<ExtArgs> = {}>(args?: Subset<T, Reward$BreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reward model
   */ 
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", 'String'>
    readonly root: FieldRef<"Reward", 'String'>
    readonly recipient: FieldRef<"Reward", 'String'>
    readonly rewardTokenId: FieldRef<"Reward", 'String'>
    readonly amount: FieldRef<"Reward", 'String'>
    readonly claimed: FieldRef<"Reward", 'String'>
    readonly pending: FieldRef<"Reward", 'String'>
    readonly proofs: FieldRef<"Reward", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
  }

  /**
   * Reward updateManyAndReturn
   */
  export type RewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to delete.
     */
    limit?: number
  }

  /**
   * Reward.Breakdown
   */
  export type Reward$BreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    where?: RewardBreakdownWhereInput
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    cursor?: RewardBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
  }

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
  }


  /**
   * Model RewardBreakdown
   */

  export type AggregateRewardBreakdown = {
    _count: RewardBreakdownCountAggregateOutputType | null
    _min: RewardBreakdownMinAggregateOutputType | null
    _max: RewardBreakdownMaxAggregateOutputType | null
  }

  export type RewardBreakdownMinAggregateOutputType = {
    id: string | null
    protocolId: string | null
    reason: string | null
    amount: string | null
    claimed: string | null
    pending: string | null
    rewardId: string | null
    campaignId: string | null
    subCampaignId: string | null
  }

  export type RewardBreakdownMaxAggregateOutputType = {
    id: string | null
    protocolId: string | null
    reason: string | null
    amount: string | null
    claimed: string | null
    pending: string | null
    rewardId: string | null
    campaignId: string | null
    subCampaignId: string | null
  }

  export type RewardBreakdownCountAggregateOutputType = {
    id: number
    protocolId: number
    reason: number
    amount: number
    claimed: number
    pending: number
    rewardId: number
    campaignId: number
    subCampaignId: number
    _all: number
  }


  export type RewardBreakdownMinAggregateInputType = {
    id?: true
    protocolId?: true
    reason?: true
    amount?: true
    claimed?: true
    pending?: true
    rewardId?: true
    campaignId?: true
    subCampaignId?: true
  }

  export type RewardBreakdownMaxAggregateInputType = {
    id?: true
    protocolId?: true
    reason?: true
    amount?: true
    claimed?: true
    pending?: true
    rewardId?: true
    campaignId?: true
    subCampaignId?: true
  }

  export type RewardBreakdownCountAggregateInputType = {
    id?: true
    protocolId?: true
    reason?: true
    amount?: true
    claimed?: true
    pending?: true
    rewardId?: true
    campaignId?: true
    subCampaignId?: true
    _all?: true
  }

  export type RewardBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardBreakdown to aggregate.
     */
    where?: RewardBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardBreakdowns to fetch.
     */
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardBreakdowns
    **/
    _count?: true | RewardBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardBreakdownMaxAggregateInputType
  }

  export type GetRewardBreakdownAggregateType<T extends RewardBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardBreakdown[P]>
      : GetScalarType<T[P], AggregateRewardBreakdown[P]>
  }




  export type RewardBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardBreakdownWhereInput
    orderBy?: RewardBreakdownOrderByWithAggregationInput | RewardBreakdownOrderByWithAggregationInput[]
    by: RewardBreakdownScalarFieldEnum[] | RewardBreakdownScalarFieldEnum
    having?: RewardBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardBreakdownCountAggregateInputType | true
    _min?: RewardBreakdownMinAggregateInputType
    _max?: RewardBreakdownMaxAggregateInputType
  }

  export type RewardBreakdownGroupByOutputType = {
    id: string
    protocolId: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
    subCampaignId: string | null
    _count: RewardBreakdownCountAggregateOutputType | null
    _min: RewardBreakdownMinAggregateOutputType | null
    _max: RewardBreakdownMaxAggregateOutputType | null
  }

  type GetRewardBreakdownGroupByPayload<T extends RewardBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], RewardBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type RewardBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    protocolId?: boolean
    reason?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    rewardId?: boolean
    campaignId?: boolean
    subCampaignId?: boolean
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["rewardBreakdown"]>

  export type RewardBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    protocolId?: boolean
    reason?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    rewardId?: boolean
    campaignId?: boolean
    subCampaignId?: boolean
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["rewardBreakdown"]>

  export type RewardBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    protocolId?: boolean
    reason?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    rewardId?: boolean
    campaignId?: boolean
    subCampaignId?: boolean
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["rewardBreakdown"]>

  export type RewardBreakdownSelectScalar = {
    id?: boolean
    protocolId?: boolean
    reason?: boolean
    amount?: boolean
    claimed?: boolean
    pending?: boolean
    rewardId?: boolean
    campaignId?: boolean
    subCampaignId?: boolean
  }

  export type RewardBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "protocolId" | "reason" | "amount" | "claimed" | "pending" | "rewardId" | "campaignId" | "subCampaignId", ExtArgs["result"]["rewardBreakdown"]>
  export type RewardBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }
  export type RewardBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }
  export type RewardBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Protocol?: boolean | RewardBreakdown$ProtocolArgs<ExtArgs>
    Reward?: boolean | RewardDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    SubCampaign?: boolean | RewardBreakdown$SubCampaignArgs<ExtArgs>
  }

  export type $RewardBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardBreakdown"
    objects: {
      Protocol: Prisma.$ProtocolPayload<ExtArgs> | null
      Reward: Prisma.$RewardPayload<ExtArgs>
      Campaign: Prisma.$CampaignPayload<ExtArgs>
      SubCampaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      protocolId: string | null
      reason: string
      amount: string
      claimed: string
      pending: string
      rewardId: string
      campaignId: string
      subCampaignId: string | null
    }, ExtArgs["result"]["rewardBreakdown"]>
    composites: {}
  }

  type RewardBreakdownGetPayload<S extends boolean | null | undefined | RewardBreakdownDefaultArgs> = $Result.GetResult<Prisma.$RewardBreakdownPayload, S>

  type RewardBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: RewardBreakdownCountAggregateInputType | true
    }

  export interface RewardBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardBreakdown'], meta: { name: 'RewardBreakdown' } }
    /**
     * Find zero or one RewardBreakdown that matches the filter.
     * @param {RewardBreakdownFindUniqueArgs} args - Arguments to find a RewardBreakdown
     * @example
     * // Get one RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardBreakdownFindUniqueArgs>(args: SelectSubset<T, RewardBreakdownFindUniqueArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RewardBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardBreakdownFindUniqueOrThrowArgs} args - Arguments to find a RewardBreakdown
     * @example
     * // Get one RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RewardBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownFindFirstArgs} args - Arguments to find a RewardBreakdown
     * @example
     * // Get one RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardBreakdownFindFirstArgs>(args?: SelectSubset<T, RewardBreakdownFindFirstArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RewardBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownFindFirstOrThrowArgs} args - Arguments to find a RewardBreakdown
     * @example
     * // Get one RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RewardBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardBreakdowns
     * const rewardBreakdowns = await prisma.rewardBreakdown.findMany()
     * 
     * // Get first 10 RewardBreakdowns
     * const rewardBreakdowns = await prisma.rewardBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardBreakdownWithIdOnly = await prisma.rewardBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardBreakdownFindManyArgs>(args?: SelectSubset<T, RewardBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RewardBreakdown.
     * @param {RewardBreakdownCreateArgs} args - Arguments to create a RewardBreakdown.
     * @example
     * // Create one RewardBreakdown
     * const RewardBreakdown = await prisma.rewardBreakdown.create({
     *   data: {
     *     // ... data to create a RewardBreakdown
     *   }
     * })
     * 
     */
    create<T extends RewardBreakdownCreateArgs>(args: SelectSubset<T, RewardBreakdownCreateArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RewardBreakdowns.
     * @param {RewardBreakdownCreateManyArgs} args - Arguments to create many RewardBreakdowns.
     * @example
     * // Create many RewardBreakdowns
     * const rewardBreakdown = await prisma.rewardBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardBreakdownCreateManyArgs>(args?: SelectSubset<T, RewardBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardBreakdowns and returns the data saved in the database.
     * @param {RewardBreakdownCreateManyAndReturnArgs} args - Arguments to create many RewardBreakdowns.
     * @example
     * // Create many RewardBreakdowns
     * const rewardBreakdown = await prisma.rewardBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardBreakdowns and only return the `id`
     * const rewardBreakdownWithIdOnly = await prisma.rewardBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RewardBreakdown.
     * @param {RewardBreakdownDeleteArgs} args - Arguments to delete one RewardBreakdown.
     * @example
     * // Delete one RewardBreakdown
     * const RewardBreakdown = await prisma.rewardBreakdown.delete({
     *   where: {
     *     // ... filter to delete one RewardBreakdown
     *   }
     * })
     * 
     */
    delete<T extends RewardBreakdownDeleteArgs>(args: SelectSubset<T, RewardBreakdownDeleteArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RewardBreakdown.
     * @param {RewardBreakdownUpdateArgs} args - Arguments to update one RewardBreakdown.
     * @example
     * // Update one RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardBreakdownUpdateArgs>(args: SelectSubset<T, RewardBreakdownUpdateArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RewardBreakdowns.
     * @param {RewardBreakdownDeleteManyArgs} args - Arguments to filter RewardBreakdowns to delete.
     * @example
     * // Delete a few RewardBreakdowns
     * const { count } = await prisma.rewardBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardBreakdownDeleteManyArgs>(args?: SelectSubset<T, RewardBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardBreakdowns
     * const rewardBreakdown = await prisma.rewardBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardBreakdownUpdateManyArgs>(args: SelectSubset<T, RewardBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardBreakdowns and returns the data updated in the database.
     * @param {RewardBreakdownUpdateManyAndReturnArgs} args - Arguments to update many RewardBreakdowns.
     * @example
     * // Update many RewardBreakdowns
     * const rewardBreakdown = await prisma.rewardBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardBreakdowns and only return the `id`
     * const rewardBreakdownWithIdOnly = await prisma.rewardBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RewardBreakdown.
     * @param {RewardBreakdownUpsertArgs} args - Arguments to update or create a RewardBreakdown.
     * @example
     * // Update or create a RewardBreakdown
     * const rewardBreakdown = await prisma.rewardBreakdown.upsert({
     *   create: {
     *     // ... data to create a RewardBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends RewardBreakdownUpsertArgs>(args: SelectSubset<T, RewardBreakdownUpsertArgs<ExtArgs>>): Prisma__RewardBreakdownClient<$Result.GetResult<Prisma.$RewardBreakdownPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RewardBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownCountArgs} args - Arguments to filter RewardBreakdowns to count.
     * @example
     * // Count the number of RewardBreakdowns
     * const count = await prisma.rewardBreakdown.count({
     *   where: {
     *     // ... the filter for the RewardBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends RewardBreakdownCountArgs>(
      args?: Subset<T, RewardBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardBreakdownAggregateArgs>(args: Subset<T, RewardBreakdownAggregateArgs>): Prisma.PrismaPromise<GetRewardBreakdownAggregateType<T>>

    /**
     * Group by RewardBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: RewardBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardBreakdown model
   */
  readonly fields: RewardBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Protocol<T extends RewardBreakdown$ProtocolArgs<ExtArgs> = {}>(args?: Subset<T, RewardBreakdown$ProtocolArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Reward<T extends RewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefaultArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    SubCampaign<T extends RewardBreakdown$SubCampaignArgs<ExtArgs> = {}>(args?: Subset<T, RewardBreakdown$SubCampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardBreakdown model
   */ 
  interface RewardBreakdownFieldRefs {
    readonly id: FieldRef<"RewardBreakdown", 'String'>
    readonly protocolId: FieldRef<"RewardBreakdown", 'String'>
    readonly reason: FieldRef<"RewardBreakdown", 'String'>
    readonly amount: FieldRef<"RewardBreakdown", 'String'>
    readonly claimed: FieldRef<"RewardBreakdown", 'String'>
    readonly pending: FieldRef<"RewardBreakdown", 'String'>
    readonly rewardId: FieldRef<"RewardBreakdown", 'String'>
    readonly campaignId: FieldRef<"RewardBreakdown", 'String'>
    readonly subCampaignId: FieldRef<"RewardBreakdown", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RewardBreakdown findUnique
   */
  export type RewardBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which RewardBreakdown to fetch.
     */
    where: RewardBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown findUniqueOrThrow
   */
  export type RewardBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which RewardBreakdown to fetch.
     */
    where: RewardBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown findFirst
   */
  export type RewardBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which RewardBreakdown to fetch.
     */
    where?: RewardBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardBreakdowns to fetch.
     */
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardBreakdowns.
     */
    cursor?: RewardBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardBreakdowns.
     */
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown findFirstOrThrow
   */
  export type RewardBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which RewardBreakdown to fetch.
     */
    where?: RewardBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardBreakdowns to fetch.
     */
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardBreakdowns.
     */
    cursor?: RewardBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardBreakdowns.
     */
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown findMany
   */
  export type RewardBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which RewardBreakdowns to fetch.
     */
    where?: RewardBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardBreakdowns to fetch.
     */
    orderBy?: RewardBreakdownOrderByWithRelationInput | RewardBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardBreakdowns.
     */
    cursor?: RewardBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardBreakdowns.
     */
    skip?: number
    distinct?: RewardBreakdownScalarFieldEnum | RewardBreakdownScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown create
   */
  export type RewardBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardBreakdown.
     */
    data: XOR<RewardBreakdownCreateInput, RewardBreakdownUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown createMany
   */
  export type RewardBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardBreakdowns.
     */
    data: RewardBreakdownCreateManyInput | RewardBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardBreakdown createManyAndReturn
   */
  export type RewardBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many RewardBreakdowns.
     */
    data: RewardBreakdownCreateManyInput | RewardBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardBreakdown update
   */
  export type RewardBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardBreakdown.
     */
    data: XOR<RewardBreakdownUpdateInput, RewardBreakdownUncheckedUpdateInput>
    /**
     * Choose, which RewardBreakdown to update.
     */
    where: RewardBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown updateMany
   */
  export type RewardBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardBreakdowns.
     */
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which RewardBreakdowns to update
     */
    where?: RewardBreakdownWhereInput
    /**
     * Limit how many RewardBreakdowns to update.
     */
    limit?: number
  }

  /**
   * RewardBreakdown updateManyAndReturn
   */
  export type RewardBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update RewardBreakdowns.
     */
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which RewardBreakdowns to update
     */
    where?: RewardBreakdownWhereInput
    /**
     * Limit how many RewardBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardBreakdown upsert
   */
  export type RewardBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardBreakdown to update in case it exists.
     */
    where: RewardBreakdownWhereUniqueInput
    /**
     * In case the RewardBreakdown found by the `where` argument doesn't exist, create a new RewardBreakdown with this data.
     */
    create: XOR<RewardBreakdownCreateInput, RewardBreakdownUncheckedCreateInput>
    /**
     * In case the RewardBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardBreakdownUpdateInput, RewardBreakdownUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown delete
   */
  export type RewardBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
    /**
     * Filter which RewardBreakdown to delete.
     */
    where: RewardBreakdownWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * RewardBreakdown deleteMany
   */
  export type RewardBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardBreakdowns to delete
     */
    where?: RewardBreakdownWhereInput
    /**
     * Limit how many RewardBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * RewardBreakdown.Protocol
   */
  export type RewardBreakdown$ProtocolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Protocol
     */
    omit?: ProtocolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    where?: ProtocolWhereInput
  }

  /**
   * RewardBreakdown.SubCampaign
   */
  export type RewardBreakdown$SubCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * RewardBreakdown without action
   */
  export type RewardBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardBreakdown
     */
    select?: RewardBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardBreakdown
     */
    omit?: RewardBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model MerklRoot
   */

  export type AggregateMerklRoot = {
    _count: MerklRootCountAggregateOutputType | null
    _avg: MerklRootAvgAggregateOutputType | null
    _sum: MerklRootSumAggregateOutputType | null
    _min: MerklRootMinAggregateOutputType | null
    _max: MerklRootMaxAggregateOutputType | null
  }

  export type MerklRootAvgAggregateOutputType = {
    chainId: number | null
    epoch: number | null
    timestamp: number | null
  }

  export type MerklRootSumAggregateOutputType = {
    chainId: number | null
    epoch: number | null
    timestamp: bigint | null
  }

  export type MerklRootMinAggregateOutputType = {
    root: string | null
    chainId: number | null
    epoch: number | null
    timestamp: bigint | null
  }

  export type MerklRootMaxAggregateOutputType = {
    root: string | null
    chainId: number | null
    epoch: number | null
    timestamp: bigint | null
  }

  export type MerklRootCountAggregateOutputType = {
    root: number
    chainId: number
    epoch: number
    timestamp: number
    _all: number
  }


  export type MerklRootAvgAggregateInputType = {
    chainId?: true
    epoch?: true
    timestamp?: true
  }

  export type MerklRootSumAggregateInputType = {
    chainId?: true
    epoch?: true
    timestamp?: true
  }

  export type MerklRootMinAggregateInputType = {
    root?: true
    chainId?: true
    epoch?: true
    timestamp?: true
  }

  export type MerklRootMaxAggregateInputType = {
    root?: true
    chainId?: true
    epoch?: true
    timestamp?: true
  }

  export type MerklRootCountAggregateInputType = {
    root?: true
    chainId?: true
    epoch?: true
    timestamp?: true
    _all?: true
  }

  export type MerklRootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerklRoot to aggregate.
     */
    where?: MerklRootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerklRoots to fetch.
     */
    orderBy?: MerklRootOrderByWithRelationInput | MerklRootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerklRootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerklRoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerklRoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerklRoots
    **/
    _count?: true | MerklRootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerklRootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerklRootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerklRootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerklRootMaxAggregateInputType
  }

  export type GetMerklRootAggregateType<T extends MerklRootAggregateArgs> = {
        [P in keyof T & keyof AggregateMerklRoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerklRoot[P]>
      : GetScalarType<T[P], AggregateMerklRoot[P]>
  }




  export type MerklRootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerklRootWhereInput
    orderBy?: MerklRootOrderByWithAggregationInput | MerklRootOrderByWithAggregationInput[]
    by: MerklRootScalarFieldEnum[] | MerklRootScalarFieldEnum
    having?: MerklRootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerklRootCountAggregateInputType | true
    _avg?: MerklRootAvgAggregateInputType
    _sum?: MerklRootSumAggregateInputType
    _min?: MerklRootMinAggregateInputType
    _max?: MerklRootMaxAggregateInputType
  }

  export type MerklRootGroupByOutputType = {
    root: string
    chainId: number
    epoch: number
    timestamp: bigint
    _count: MerklRootCountAggregateOutputType | null
    _avg: MerklRootAvgAggregateOutputType | null
    _sum: MerklRootSumAggregateOutputType | null
    _min: MerklRootMinAggregateOutputType | null
    _max: MerklRootMaxAggregateOutputType | null
  }

  type GetMerklRootGroupByPayload<T extends MerklRootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerklRootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerklRootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerklRootGroupByOutputType[P]>
            : GetScalarType<T[P], MerklRootGroupByOutputType[P]>
        }
      >
    >


  export type MerklRootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    root?: boolean
    chainId?: boolean
    epoch?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Rewards?: boolean | MerklRoot$RewardsArgs<ExtArgs>
    _count?: boolean | MerklRootCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merklRoot"]>

  export type MerklRootSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    root?: boolean
    chainId?: boolean
    epoch?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merklRoot"]>

  export type MerklRootSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    root?: boolean
    chainId?: boolean
    epoch?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merklRoot"]>

  export type MerklRootSelectScalar = {
    root?: boolean
    chainId?: boolean
    epoch?: boolean
    timestamp?: boolean
  }

  export type MerklRootOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"root" | "chainId" | "epoch" | "timestamp", ExtArgs["result"]["merklRoot"]>
  export type MerklRootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    Rewards?: boolean | MerklRoot$RewardsArgs<ExtArgs>
    _count?: boolean | MerklRootCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerklRootIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }
  export type MerklRootIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
  }

  export type $MerklRootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerklRoot"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
      Rewards: Prisma.$RewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      root: string
      chainId: number
      epoch: number
      timestamp: bigint
    }, ExtArgs["result"]["merklRoot"]>
    composites: {}
  }

  type MerklRootGetPayload<S extends boolean | null | undefined | MerklRootDefaultArgs> = $Result.GetResult<Prisma.$MerklRootPayload, S>

  type MerklRootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerklRootFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MerklRootCountAggregateInputType | true
    }

  export interface MerklRootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerklRoot'], meta: { name: 'MerklRoot' } }
    /**
     * Find zero or one MerklRoot that matches the filter.
     * @param {MerklRootFindUniqueArgs} args - Arguments to find a MerklRoot
     * @example
     * // Get one MerklRoot
     * const merklRoot = await prisma.merklRoot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerklRootFindUniqueArgs>(args: SelectSubset<T, MerklRootFindUniqueArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MerklRoot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerklRootFindUniqueOrThrowArgs} args - Arguments to find a MerklRoot
     * @example
     * // Get one MerklRoot
     * const merklRoot = await prisma.merklRoot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerklRootFindUniqueOrThrowArgs>(args: SelectSubset<T, MerklRootFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MerklRoot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootFindFirstArgs} args - Arguments to find a MerklRoot
     * @example
     * // Get one MerklRoot
     * const merklRoot = await prisma.merklRoot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerklRootFindFirstArgs>(args?: SelectSubset<T, MerklRootFindFirstArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MerklRoot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootFindFirstOrThrowArgs} args - Arguments to find a MerklRoot
     * @example
     * // Get one MerklRoot
     * const merklRoot = await prisma.merklRoot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerklRootFindFirstOrThrowArgs>(args?: SelectSubset<T, MerklRootFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MerklRoots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerklRoots
     * const merklRoots = await prisma.merklRoot.findMany()
     * 
     * // Get first 10 MerklRoots
     * const merklRoots = await prisma.merklRoot.findMany({ take: 10 })
     * 
     * // Only select the `root`
     * const merklRootWithRootOnly = await prisma.merklRoot.findMany({ select: { root: true } })
     * 
     */
    findMany<T extends MerklRootFindManyArgs>(args?: SelectSubset<T, MerklRootFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MerklRoot.
     * @param {MerklRootCreateArgs} args - Arguments to create a MerklRoot.
     * @example
     * // Create one MerklRoot
     * const MerklRoot = await prisma.merklRoot.create({
     *   data: {
     *     // ... data to create a MerklRoot
     *   }
     * })
     * 
     */
    create<T extends MerklRootCreateArgs>(args: SelectSubset<T, MerklRootCreateArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MerklRoots.
     * @param {MerklRootCreateManyArgs} args - Arguments to create many MerklRoots.
     * @example
     * // Create many MerklRoots
     * const merklRoot = await prisma.merklRoot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerklRootCreateManyArgs>(args?: SelectSubset<T, MerklRootCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerklRoots and returns the data saved in the database.
     * @param {MerklRootCreateManyAndReturnArgs} args - Arguments to create many MerklRoots.
     * @example
     * // Create many MerklRoots
     * const merklRoot = await prisma.merklRoot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerklRoots and only return the `root`
     * const merklRootWithRootOnly = await prisma.merklRoot.createManyAndReturn({
     *   select: { root: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerklRootCreateManyAndReturnArgs>(args?: SelectSubset<T, MerklRootCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MerklRoot.
     * @param {MerklRootDeleteArgs} args - Arguments to delete one MerklRoot.
     * @example
     * // Delete one MerklRoot
     * const MerklRoot = await prisma.merklRoot.delete({
     *   where: {
     *     // ... filter to delete one MerklRoot
     *   }
     * })
     * 
     */
    delete<T extends MerklRootDeleteArgs>(args: SelectSubset<T, MerklRootDeleteArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MerklRoot.
     * @param {MerklRootUpdateArgs} args - Arguments to update one MerklRoot.
     * @example
     * // Update one MerklRoot
     * const merklRoot = await prisma.merklRoot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerklRootUpdateArgs>(args: SelectSubset<T, MerklRootUpdateArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MerklRoots.
     * @param {MerklRootDeleteManyArgs} args - Arguments to filter MerklRoots to delete.
     * @example
     * // Delete a few MerklRoots
     * const { count } = await prisma.merklRoot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerklRootDeleteManyArgs>(args?: SelectSubset<T, MerklRootDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerklRoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerklRoots
     * const merklRoot = await prisma.merklRoot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerklRootUpdateManyArgs>(args: SelectSubset<T, MerklRootUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerklRoots and returns the data updated in the database.
     * @param {MerklRootUpdateManyAndReturnArgs} args - Arguments to update many MerklRoots.
     * @example
     * // Update many MerklRoots
     * const merklRoot = await prisma.merklRoot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerklRoots and only return the `root`
     * const merklRootWithRootOnly = await prisma.merklRoot.updateManyAndReturn({
     *   select: { root: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerklRootUpdateManyAndReturnArgs>(args: SelectSubset<T, MerklRootUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MerklRoot.
     * @param {MerklRootUpsertArgs} args - Arguments to update or create a MerklRoot.
     * @example
     * // Update or create a MerklRoot
     * const merklRoot = await prisma.merklRoot.upsert({
     *   create: {
     *     // ... data to create a MerklRoot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerklRoot we want to update
     *   }
     * })
     */
    upsert<T extends MerklRootUpsertArgs>(args: SelectSubset<T, MerklRootUpsertArgs<ExtArgs>>): Prisma__MerklRootClient<$Result.GetResult<Prisma.$MerklRootPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MerklRoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootCountArgs} args - Arguments to filter MerklRoots to count.
     * @example
     * // Count the number of MerklRoots
     * const count = await prisma.merklRoot.count({
     *   where: {
     *     // ... the filter for the MerklRoots we want to count
     *   }
     * })
    **/
    count<T extends MerklRootCountArgs>(
      args?: Subset<T, MerklRootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerklRootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerklRoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerklRootAggregateArgs>(args: Subset<T, MerklRootAggregateArgs>): Prisma.PrismaPromise<GetMerklRootAggregateType<T>>

    /**
     * Group by MerklRoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerklRootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerklRootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerklRootGroupByArgs['orderBy'] }
        : { orderBy?: MerklRootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerklRootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerklRootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerklRoot model
   */
  readonly fields: MerklRootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerklRoot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerklRootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Rewards<T extends MerklRoot$RewardsArgs<ExtArgs> = {}>(args?: Subset<T, MerklRoot$RewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerklRoot model
   */ 
  interface MerklRootFieldRefs {
    readonly root: FieldRef<"MerklRoot", 'String'>
    readonly chainId: FieldRef<"MerklRoot", 'Int'>
    readonly epoch: FieldRef<"MerklRoot", 'Int'>
    readonly timestamp: FieldRef<"MerklRoot", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * MerklRoot findUnique
   */
  export type MerklRootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter, which MerklRoot to fetch.
     */
    where: MerklRootWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot findUniqueOrThrow
   */
  export type MerklRootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter, which MerklRoot to fetch.
     */
    where: MerklRootWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot findFirst
   */
  export type MerklRootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter, which MerklRoot to fetch.
     */
    where?: MerklRootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerklRoots to fetch.
     */
    orderBy?: MerklRootOrderByWithRelationInput | MerklRootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerklRoots.
     */
    cursor?: MerklRootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerklRoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerklRoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerklRoots.
     */
    distinct?: MerklRootScalarFieldEnum | MerklRootScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot findFirstOrThrow
   */
  export type MerklRootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter, which MerklRoot to fetch.
     */
    where?: MerklRootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerklRoots to fetch.
     */
    orderBy?: MerklRootOrderByWithRelationInput | MerklRootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerklRoots.
     */
    cursor?: MerklRootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerklRoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerklRoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerklRoots.
     */
    distinct?: MerklRootScalarFieldEnum | MerklRootScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot findMany
   */
  export type MerklRootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter, which MerklRoots to fetch.
     */
    where?: MerklRootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerklRoots to fetch.
     */
    orderBy?: MerklRootOrderByWithRelationInput | MerklRootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerklRoots.
     */
    cursor?: MerklRootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerklRoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerklRoots.
     */
    skip?: number
    distinct?: MerklRootScalarFieldEnum | MerklRootScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot create
   */
  export type MerklRootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * The data needed to create a MerklRoot.
     */
    data: XOR<MerklRootCreateInput, MerklRootUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot createMany
   */
  export type MerklRootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerklRoots.
     */
    data: MerklRootCreateManyInput | MerklRootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MerklRoot createManyAndReturn
   */
  export type MerklRootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * The data used to create many MerklRoots.
     */
    data: MerklRootCreateManyInput | MerklRootCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerklRoot update
   */
  export type MerklRootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * The data needed to update a MerklRoot.
     */
    data: XOR<MerklRootUpdateInput, MerklRootUncheckedUpdateInput>
    /**
     * Choose, which MerklRoot to update.
     */
    where: MerklRootWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot updateMany
   */
  export type MerklRootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerklRoots.
     */
    data: XOR<MerklRootUpdateManyMutationInput, MerklRootUncheckedUpdateManyInput>
    /**
     * Filter which MerklRoots to update
     */
    where?: MerklRootWhereInput
    /**
     * Limit how many MerklRoots to update.
     */
    limit?: number
  }

  /**
   * MerklRoot updateManyAndReturn
   */
  export type MerklRootUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * The data used to update MerklRoots.
     */
    data: XOR<MerklRootUpdateManyMutationInput, MerklRootUncheckedUpdateManyInput>
    /**
     * Filter which MerklRoots to update
     */
    where?: MerklRootWhereInput
    /**
     * Limit how many MerklRoots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerklRoot upsert
   */
  export type MerklRootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * The filter to search for the MerklRoot to update in case it exists.
     */
    where: MerklRootWhereUniqueInput
    /**
     * In case the MerklRoot found by the `where` argument doesn't exist, create a new MerklRoot with this data.
     */
    create: XOR<MerklRootCreateInput, MerklRootUncheckedCreateInput>
    /**
     * In case the MerklRoot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerklRootUpdateInput, MerklRootUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot delete
   */
  export type MerklRootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
    /**
     * Filter which MerklRoot to delete.
     */
    where: MerklRootWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * MerklRoot deleteMany
   */
  export type MerklRootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerklRoots to delete
     */
    where?: MerklRootWhereInput
    /**
     * Limit how many MerklRoots to delete.
     */
    limit?: number
  }

  /**
   * MerklRoot.Rewards
   */
  export type MerklRoot$RewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * MerklRoot without action
   */
  export type MerklRootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerklRoot
     */
    select?: MerklRootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerklRoot
     */
    omit?: MerklRootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerklRootInclude<ExtArgs> | null
  }


  /**
   * Model PriceSource
   */

  export type AggregatePriceSource = {
    _count: PriceSourceCountAggregateOutputType | null
    _avg: PriceSourceAvgAggregateOutputType | null
    _sum: PriceSourceSumAggregateOutputType | null
    _min: PriceSourceMinAggregateOutputType | null
    _max: PriceSourceMaxAggregateOutputType | null
  }

  export type PriceSourceAvgAggregateOutputType = {
    id: number | null
  }

  export type PriceSourceSumAggregateOutputType = {
    id: number | null
  }

  export type PriceSourceMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    method: $Enums.PriceSourceMethod | null
  }

  export type PriceSourceMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    method: $Enums.PriceSourceMethod | null
  }

  export type PriceSourceCountAggregateOutputType = {
    id: number
    symbol: number
    method: number
    args: number
    _all: number
  }


  export type PriceSourceAvgAggregateInputType = {
    id?: true
  }

  export type PriceSourceSumAggregateInputType = {
    id?: true
  }

  export type PriceSourceMinAggregateInputType = {
    id?: true
    symbol?: true
    method?: true
  }

  export type PriceSourceMaxAggregateInputType = {
    id?: true
    symbol?: true
    method?: true
  }

  export type PriceSourceCountAggregateInputType = {
    id?: true
    symbol?: true
    method?: true
    args?: true
    _all?: true
  }

  export type PriceSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceSource to aggregate.
     */
    where?: PriceSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceSources to fetch.
     */
    orderBy?: PriceSourceOrderByWithRelationInput | PriceSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceSources
    **/
    _count?: true | PriceSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceSourceMaxAggregateInputType
  }

  export type GetPriceSourceAggregateType<T extends PriceSourceAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceSource[P]>
      : GetScalarType<T[P], AggregatePriceSource[P]>
  }




  export type PriceSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceSourceWhereInput
    orderBy?: PriceSourceOrderByWithAggregationInput | PriceSourceOrderByWithAggregationInput[]
    by: PriceSourceScalarFieldEnum[] | PriceSourceScalarFieldEnum
    having?: PriceSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceSourceCountAggregateInputType | true
    _avg?: PriceSourceAvgAggregateInputType
    _sum?: PriceSourceSumAggregateInputType
    _min?: PriceSourceMinAggregateInputType
    _max?: PriceSourceMaxAggregateInputType
  }

  export type PriceSourceGroupByOutputType = {
    id: number
    symbol: string
    method: $Enums.PriceSourceMethod
    args: JsonValue | null
    _count: PriceSourceCountAggregateOutputType | null
    _avg: PriceSourceAvgAggregateOutputType | null
    _sum: PriceSourceSumAggregateOutputType | null
    _min: PriceSourceMinAggregateOutputType | null
    _max: PriceSourceMaxAggregateOutputType | null
  }

  type GetPriceSourceGroupByPayload<T extends PriceSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceSourceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceSourceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    method?: boolean
    args?: boolean
  }, ExtArgs["result"]["priceSource"]>

  export type PriceSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    method?: boolean
    args?: boolean
  }, ExtArgs["result"]["priceSource"]>

  export type PriceSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    method?: boolean
    args?: boolean
  }, ExtArgs["result"]["priceSource"]>

  export type PriceSourceSelectScalar = {
    id?: boolean
    symbol?: boolean
    method?: boolean
    args?: boolean
  }

  export type PriceSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "method" | "args", ExtArgs["result"]["priceSource"]>

  export type $PriceSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceSource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      method: $Enums.PriceSourceMethod
      args: Prisma.JsonValue | null
    }, ExtArgs["result"]["priceSource"]>
    composites: {}
  }

  type PriceSourceGetPayload<S extends boolean | null | undefined | PriceSourceDefaultArgs> = $Result.GetResult<Prisma.$PriceSourcePayload, S>

  type PriceSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: PriceSourceCountAggregateInputType | true
    }

  export interface PriceSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceSource'], meta: { name: 'PriceSource' } }
    /**
     * Find zero or one PriceSource that matches the filter.
     * @param {PriceSourceFindUniqueArgs} args - Arguments to find a PriceSource
     * @example
     * // Get one PriceSource
     * const priceSource = await prisma.priceSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceSourceFindUniqueArgs>(args: SelectSubset<T, PriceSourceFindUniqueArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PriceSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceSourceFindUniqueOrThrowArgs} args - Arguments to find a PriceSource
     * @example
     * // Get one PriceSource
     * const priceSource = await prisma.priceSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PriceSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceFindFirstArgs} args - Arguments to find a PriceSource
     * @example
     * // Get one PriceSource
     * const priceSource = await prisma.priceSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceSourceFindFirstArgs>(args?: SelectSubset<T, PriceSourceFindFirstArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PriceSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceFindFirstOrThrowArgs} args - Arguments to find a PriceSource
     * @example
     * // Get one PriceSource
     * const priceSource = await prisma.priceSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PriceSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceSources
     * const priceSources = await prisma.priceSource.findMany()
     * 
     * // Get first 10 PriceSources
     * const priceSources = await prisma.priceSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceSourceWithIdOnly = await prisma.priceSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceSourceFindManyArgs>(args?: SelectSubset<T, PriceSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PriceSource.
     * @param {PriceSourceCreateArgs} args - Arguments to create a PriceSource.
     * @example
     * // Create one PriceSource
     * const PriceSource = await prisma.priceSource.create({
     *   data: {
     *     // ... data to create a PriceSource
     *   }
     * })
     * 
     */
    create<T extends PriceSourceCreateArgs>(args: SelectSubset<T, PriceSourceCreateArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PriceSources.
     * @param {PriceSourceCreateManyArgs} args - Arguments to create many PriceSources.
     * @example
     * // Create many PriceSources
     * const priceSource = await prisma.priceSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceSourceCreateManyArgs>(args?: SelectSubset<T, PriceSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceSources and returns the data saved in the database.
     * @param {PriceSourceCreateManyAndReturnArgs} args - Arguments to create many PriceSources.
     * @example
     * // Create many PriceSources
     * const priceSource = await prisma.priceSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceSources and only return the `id`
     * const priceSourceWithIdOnly = await prisma.priceSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PriceSource.
     * @param {PriceSourceDeleteArgs} args - Arguments to delete one PriceSource.
     * @example
     * // Delete one PriceSource
     * const PriceSource = await prisma.priceSource.delete({
     *   where: {
     *     // ... filter to delete one PriceSource
     *   }
     * })
     * 
     */
    delete<T extends PriceSourceDeleteArgs>(args: SelectSubset<T, PriceSourceDeleteArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PriceSource.
     * @param {PriceSourceUpdateArgs} args - Arguments to update one PriceSource.
     * @example
     * // Update one PriceSource
     * const priceSource = await prisma.priceSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceSourceUpdateArgs>(args: SelectSubset<T, PriceSourceUpdateArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PriceSources.
     * @param {PriceSourceDeleteManyArgs} args - Arguments to filter PriceSources to delete.
     * @example
     * // Delete a few PriceSources
     * const { count } = await prisma.priceSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceSourceDeleteManyArgs>(args?: SelectSubset<T, PriceSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceSources
     * const priceSource = await prisma.priceSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceSourceUpdateManyArgs>(args: SelectSubset<T, PriceSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceSources and returns the data updated in the database.
     * @param {PriceSourceUpdateManyAndReturnArgs} args - Arguments to update many PriceSources.
     * @example
     * // Update many PriceSources
     * const priceSource = await prisma.priceSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceSources and only return the `id`
     * const priceSourceWithIdOnly = await prisma.priceSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PriceSource.
     * @param {PriceSourceUpsertArgs} args - Arguments to update or create a PriceSource.
     * @example
     * // Update or create a PriceSource
     * const priceSource = await prisma.priceSource.upsert({
     *   create: {
     *     // ... data to create a PriceSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceSource we want to update
     *   }
     * })
     */
    upsert<T extends PriceSourceUpsertArgs>(args: SelectSubset<T, PriceSourceUpsertArgs<ExtArgs>>): Prisma__PriceSourceClient<$Result.GetResult<Prisma.$PriceSourcePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PriceSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceCountArgs} args - Arguments to filter PriceSources to count.
     * @example
     * // Count the number of PriceSources
     * const count = await prisma.priceSource.count({
     *   where: {
     *     // ... the filter for the PriceSources we want to count
     *   }
     * })
    **/
    count<T extends PriceSourceCountArgs>(
      args?: Subset<T, PriceSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceSourceAggregateArgs>(args: Subset<T, PriceSourceAggregateArgs>): Prisma.PrismaPromise<GetPriceSourceAggregateType<T>>

    /**
     * Group by PriceSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceSourceGroupByArgs['orderBy'] }
        : { orderBy?: PriceSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceSource model
   */
  readonly fields: PriceSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceSource model
   */ 
  interface PriceSourceFieldRefs {
    readonly id: FieldRef<"PriceSource", 'Int'>
    readonly symbol: FieldRef<"PriceSource", 'String'>
    readonly method: FieldRef<"PriceSource", 'PriceSourceMethod'>
    readonly args: FieldRef<"PriceSource", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PriceSource findUnique
   */
  export type PriceSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter, which PriceSource to fetch.
     */
    where: PriceSourceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource findUniqueOrThrow
   */
  export type PriceSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter, which PriceSource to fetch.
     */
    where: PriceSourceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource findFirst
   */
  export type PriceSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter, which PriceSource to fetch.
     */
    where?: PriceSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceSources to fetch.
     */
    orderBy?: PriceSourceOrderByWithRelationInput | PriceSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceSources.
     */
    cursor?: PriceSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceSources.
     */
    distinct?: PriceSourceScalarFieldEnum | PriceSourceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource findFirstOrThrow
   */
  export type PriceSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter, which PriceSource to fetch.
     */
    where?: PriceSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceSources to fetch.
     */
    orderBy?: PriceSourceOrderByWithRelationInput | PriceSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceSources.
     */
    cursor?: PriceSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceSources.
     */
    distinct?: PriceSourceScalarFieldEnum | PriceSourceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource findMany
   */
  export type PriceSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter, which PriceSources to fetch.
     */
    where?: PriceSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceSources to fetch.
     */
    orderBy?: PriceSourceOrderByWithRelationInput | PriceSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceSources.
     */
    cursor?: PriceSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceSources.
     */
    skip?: number
    distinct?: PriceSourceScalarFieldEnum | PriceSourceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource create
   */
  export type PriceSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * The data needed to create a PriceSource.
     */
    data: XOR<PriceSourceCreateInput, PriceSourceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource createMany
   */
  export type PriceSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceSources.
     */
    data: PriceSourceCreateManyInput | PriceSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceSource createManyAndReturn
   */
  export type PriceSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * The data used to create many PriceSources.
     */
    data: PriceSourceCreateManyInput | PriceSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceSource update
   */
  export type PriceSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * The data needed to update a PriceSource.
     */
    data: XOR<PriceSourceUpdateInput, PriceSourceUncheckedUpdateInput>
    /**
     * Choose, which PriceSource to update.
     */
    where: PriceSourceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource updateMany
   */
  export type PriceSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceSources.
     */
    data: XOR<PriceSourceUpdateManyMutationInput, PriceSourceUncheckedUpdateManyInput>
    /**
     * Filter which PriceSources to update
     */
    where?: PriceSourceWhereInput
    /**
     * Limit how many PriceSources to update.
     */
    limit?: number
  }

  /**
   * PriceSource updateManyAndReturn
   */
  export type PriceSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * The data used to update PriceSources.
     */
    data: XOR<PriceSourceUpdateManyMutationInput, PriceSourceUncheckedUpdateManyInput>
    /**
     * Filter which PriceSources to update
     */
    where?: PriceSourceWhereInput
    /**
     * Limit how many PriceSources to update.
     */
    limit?: number
  }

  /**
   * PriceSource upsert
   */
  export type PriceSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * The filter to search for the PriceSource to update in case it exists.
     */
    where: PriceSourceWhereUniqueInput
    /**
     * In case the PriceSource found by the `where` argument doesn't exist, create a new PriceSource with this data.
     */
    create: XOR<PriceSourceCreateInput, PriceSourceUncheckedCreateInput>
    /**
     * In case the PriceSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceSourceUpdateInput, PriceSourceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource delete
   */
  export type PriceSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
    /**
     * Filter which PriceSource to delete.
     */
    where: PriceSourceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * PriceSource deleteMany
   */
  export type PriceSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceSources to delete
     */
    where?: PriceSourceWhereInput
    /**
     * Limit how many PriceSources to delete.
     */
    limit?: number
  }

  /**
   * PriceSource without action
   */
  export type PriceSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceSource
     */
    select?: PriceSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceSource
     */
    omit?: PriceSourceOmit<ExtArgs> | null
  }


  /**
   * Model Blacklist
   */

  export type AggregateBlacklist = {
    _count: BlacklistCountAggregateOutputType | null
    _avg: BlacklistAvgAggregateOutputType | null
    _sum: BlacklistSumAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  export type BlacklistAvgAggregateOutputType = {
    chainId: number | null
    arrestTimestamp: number | null
  }

  export type BlacklistSumAggregateOutputType = {
    chainId: number | null
    arrestTimestamp: bigint | null
  }

  export type BlacklistMinAggregateOutputType = {
    id: string | null
    chainId: number | null
    poolAddress: string | null
    userAddress: string | null
    arrestTimestamp: bigint | null
  }

  export type BlacklistMaxAggregateOutputType = {
    id: string | null
    chainId: number | null
    poolAddress: string | null
    userAddress: string | null
    arrestTimestamp: bigint | null
  }

  export type BlacklistCountAggregateOutputType = {
    id: number
    chainId: number
    poolAddress: number
    userAddress: number
    arrestTimestamp: number
    arrestDetails: number
    _all: number
  }


  export type BlacklistAvgAggregateInputType = {
    chainId?: true
    arrestTimestamp?: true
  }

  export type BlacklistSumAggregateInputType = {
    chainId?: true
    arrestTimestamp?: true
  }

  export type BlacklistMinAggregateInputType = {
    id?: true
    chainId?: true
    poolAddress?: true
    userAddress?: true
    arrestTimestamp?: true
  }

  export type BlacklistMaxAggregateInputType = {
    id?: true
    chainId?: true
    poolAddress?: true
    userAddress?: true
    arrestTimestamp?: true
  }

  export type BlacklistCountAggregateInputType = {
    id?: true
    chainId?: true
    poolAddress?: true
    userAddress?: true
    arrestTimestamp?: true
    arrestDetails?: true
    _all?: true
  }

  export type BlacklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blacklist to aggregate.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blacklists
    **/
    _count?: true | BlacklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistMaxAggregateInputType
  }

  export type GetBlacklistAggregateType<T extends BlacklistAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklist[P]>
      : GetScalarType<T[P], AggregateBlacklist[P]>
  }




  export type BlacklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithAggregationInput | BlacklistOrderByWithAggregationInput[]
    by: BlacklistScalarFieldEnum[] | BlacklistScalarFieldEnum
    having?: BlacklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistCountAggregateInputType | true
    _avg?: BlacklistAvgAggregateInputType
    _sum?: BlacklistSumAggregateInputType
    _min?: BlacklistMinAggregateInputType
    _max?: BlacklistMaxAggregateInputType
  }

  export type BlacklistGroupByOutputType = {
    id: string
    chainId: number
    poolAddress: string
    userAddress: string
    arrestTimestamp: bigint
    arrestDetails: JsonValue
    _count: BlacklistCountAggregateOutputType | null
    _avg: BlacklistAvgAggregateOutputType | null
    _sum: BlacklistSumAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  type GetBlacklistGroupByPayload<T extends BlacklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    poolAddress?: boolean
    userAddress?: boolean
    arrestTimestamp?: boolean
    arrestDetails?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    poolAddress?: boolean
    userAddress?: boolean
    arrestTimestamp?: boolean
    arrestDetails?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    poolAddress?: boolean
    userAddress?: boolean
    arrestTimestamp?: boolean
    arrestDetails?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectScalar = {
    id?: boolean
    chainId?: boolean
    poolAddress?: boolean
    userAddress?: boolean
    arrestTimestamp?: boolean
    arrestDetails?: boolean
  }

  export type BlacklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chainId" | "poolAddress" | "userAddress" | "arrestTimestamp" | "arrestDetails", ExtArgs["result"]["blacklist"]>
  export type BlacklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlacklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlacklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlacklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blacklist"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chainId: number
      poolAddress: string
      userAddress: string
      arrestTimestamp: bigint
      arrestDetails: Prisma.JsonValue
    }, ExtArgs["result"]["blacklist"]>
    composites: {}
  }

  type BlacklistGetPayload<S extends boolean | null | undefined | BlacklistDefaultArgs> = $Result.GetResult<Prisma.$BlacklistPayload, S>

  type BlacklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlacklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BlacklistCountAggregateInputType | true
    }

  export interface BlacklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blacklist'], meta: { name: 'Blacklist' } }
    /**
     * Find zero or one Blacklist that matches the filter.
     * @param {BlacklistFindUniqueArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlacklistFindUniqueArgs>(args: SelectSubset<T, BlacklistFindUniqueArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Blacklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlacklistFindUniqueOrThrowArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlacklistFindUniqueOrThrowArgs>(args: SelectSubset<T, BlacklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Blacklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindFirstArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlacklistFindFirstArgs>(args?: SelectSubset<T, BlacklistFindFirstArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Blacklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindFirstOrThrowArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlacklistFindFirstOrThrowArgs>(args?: SelectSubset<T, BlacklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Blacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blacklists
     * const blacklists = await prisma.blacklist.findMany()
     * 
     * // Get first 10 Blacklists
     * const blacklists = await prisma.blacklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlacklistFindManyArgs>(args?: SelectSubset<T, BlacklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Blacklist.
     * @param {BlacklistCreateArgs} args - Arguments to create a Blacklist.
     * @example
     * // Create one Blacklist
     * const Blacklist = await prisma.blacklist.create({
     *   data: {
     *     // ... data to create a Blacklist
     *   }
     * })
     * 
     */
    create<T extends BlacklistCreateArgs>(args: SelectSubset<T, BlacklistCreateArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Blacklists.
     * @param {BlacklistCreateManyArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklist = await prisma.blacklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlacklistCreateManyArgs>(args?: SelectSubset<T, BlacklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blacklists and returns the data saved in the database.
     * @param {BlacklistCreateManyAndReturnArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklist = await prisma.blacklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blacklists and only return the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlacklistCreateManyAndReturnArgs>(args?: SelectSubset<T, BlacklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Blacklist.
     * @param {BlacklistDeleteArgs} args - Arguments to delete one Blacklist.
     * @example
     * // Delete one Blacklist
     * const Blacklist = await prisma.blacklist.delete({
     *   where: {
     *     // ... filter to delete one Blacklist
     *   }
     * })
     * 
     */
    delete<T extends BlacklistDeleteArgs>(args: SelectSubset<T, BlacklistDeleteArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Blacklist.
     * @param {BlacklistUpdateArgs} args - Arguments to update one Blacklist.
     * @example
     * // Update one Blacklist
     * const blacklist = await prisma.blacklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlacklistUpdateArgs>(args: SelectSubset<T, BlacklistUpdateArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Blacklists.
     * @param {BlacklistDeleteManyArgs} args - Arguments to filter Blacklists to delete.
     * @example
     * // Delete a few Blacklists
     * const { count } = await prisma.blacklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlacklistDeleteManyArgs>(args?: SelectSubset<T, BlacklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blacklists
     * const blacklist = await prisma.blacklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlacklistUpdateManyArgs>(args: SelectSubset<T, BlacklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklists and returns the data updated in the database.
     * @param {BlacklistUpdateManyAndReturnArgs} args - Arguments to update many Blacklists.
     * @example
     * // Update many Blacklists
     * const blacklist = await prisma.blacklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blacklists and only return the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlacklistUpdateManyAndReturnArgs>(args: SelectSubset<T, BlacklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Blacklist.
     * @param {BlacklistUpsertArgs} args - Arguments to update or create a Blacklist.
     * @example
     * // Update or create a Blacklist
     * const blacklist = await prisma.blacklist.upsert({
     *   create: {
     *     // ... data to create a Blacklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blacklist we want to update
     *   }
     * })
     */
    upsert<T extends BlacklistUpsertArgs>(args: SelectSubset<T, BlacklistUpsertArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistCountArgs} args - Arguments to filter Blacklists to count.
     * @example
     * // Count the number of Blacklists
     * const count = await prisma.blacklist.count({
     *   where: {
     *     // ... the filter for the Blacklists we want to count
     *   }
     * })
    **/
    count<T extends BlacklistCountArgs>(
      args?: Subset<T, BlacklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistAggregateArgs>(args: Subset<T, BlacklistAggregateArgs>): Prisma.PrismaPromise<GetBlacklistAggregateType<T>>

    /**
     * Group by Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blacklist model
   */
  readonly fields: BlacklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blacklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlacklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blacklist model
   */ 
  interface BlacklistFieldRefs {
    readonly id: FieldRef<"Blacklist", 'String'>
    readonly chainId: FieldRef<"Blacklist", 'Int'>
    readonly poolAddress: FieldRef<"Blacklist", 'String'>
    readonly userAddress: FieldRef<"Blacklist", 'String'>
    readonly arrestTimestamp: FieldRef<"Blacklist", 'BigInt'>
    readonly arrestDetails: FieldRef<"Blacklist", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Blacklist findUnique
   */
  export type BlacklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where: BlacklistWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist findUniqueOrThrow
   */
  export type BlacklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where: BlacklistWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist findFirst
   */
  export type BlacklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blacklists.
     */
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist findFirstOrThrow
   */
  export type BlacklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blacklists.
     */
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist findMany
   */
  export type BlacklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklists to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist create
   */
  export type BlacklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The data needed to create a Blacklist.
     */
    data: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist createMany
   */
  export type BlacklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blacklists.
     */
    data: BlacklistCreateManyInput | BlacklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blacklist createManyAndReturn
   */
  export type BlacklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * The data used to create many Blacklists.
     */
    data: BlacklistCreateManyInput | BlacklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blacklist update
   */
  export type BlacklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The data needed to update a Blacklist.
     */
    data: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
    /**
     * Choose, which Blacklist to update.
     */
    where: BlacklistWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist updateMany
   */
  export type BlacklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blacklists.
     */
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyInput>
    /**
     * Filter which Blacklists to update
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to update.
     */
    limit?: number
  }

  /**
   * Blacklist updateManyAndReturn
   */
  export type BlacklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * The data used to update Blacklists.
     */
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyInput>
    /**
     * Filter which Blacklists to update
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blacklist upsert
   */
  export type BlacklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The filter to search for the Blacklist to update in case it exists.
     */
    where: BlacklistWhereUniqueInput
    /**
     * In case the Blacklist found by the `where` argument doesn't exist, create a new Blacklist with this data.
     */
    create: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
    /**
     * In case the Blacklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist delete
   */
  export type BlacklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter which Blacklist to delete.
     */
    where: BlacklistWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blacklist deleteMany
   */
  export type BlacklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blacklists to delete
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to delete.
     */
    limit?: number
  }

  /**
   * Blacklist without action
   */
  export type BlacklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
  }


  /**
   * Model Dump
   */

  export type AggregateDump = {
    _count: DumpCountAggregateOutputType | null
    _avg: DumpAvgAggregateOutputType | null
    _sum: DumpSumAggregateOutputType | null
    _min: DumpMinAggregateOutputType | null
    _max: DumpMaxAggregateOutputType | null
  }

  export type DumpAvgAggregateOutputType = {
    chainId: number | null
    timestamp: number | null
  }

  export type DumpSumAggregateOutputType = {
    chainId: number | null
    timestamp: number | null
  }

  export type DumpMinAggregateOutputType = {
    id: string | null
    chainId: number | null
    fromTokenId: string | null
    toTokenId: string | null
    multisig: string | null
    recipient: string | null
    amountIn: string | null
    amountOut: string | null
    datetime: Date | null
    timestamp: number | null
  }

  export type DumpMaxAggregateOutputType = {
    id: string | null
    chainId: number | null
    fromTokenId: string | null
    toTokenId: string | null
    multisig: string | null
    recipient: string | null
    amountIn: string | null
    amountOut: string | null
    datetime: Date | null
    timestamp: number | null
  }

  export type DumpCountAggregateOutputType = {
    id: number
    chainId: number
    fromTokenId: number
    toTokenId: number
    multisig: number
    recipient: number
    amountIn: number
    amountOut: number
    datetime: number
    timestamp: number
    _all: number
  }


  export type DumpAvgAggregateInputType = {
    chainId?: true
    timestamp?: true
  }

  export type DumpSumAggregateInputType = {
    chainId?: true
    timestamp?: true
  }

  export type DumpMinAggregateInputType = {
    id?: true
    chainId?: true
    fromTokenId?: true
    toTokenId?: true
    multisig?: true
    recipient?: true
    amountIn?: true
    amountOut?: true
    datetime?: true
    timestamp?: true
  }

  export type DumpMaxAggregateInputType = {
    id?: true
    chainId?: true
    fromTokenId?: true
    toTokenId?: true
    multisig?: true
    recipient?: true
    amountIn?: true
    amountOut?: true
    datetime?: true
    timestamp?: true
  }

  export type DumpCountAggregateInputType = {
    id?: true
    chainId?: true
    fromTokenId?: true
    toTokenId?: true
    multisig?: true
    recipient?: true
    amountIn?: true
    amountOut?: true
    datetime?: true
    timestamp?: true
    _all?: true
  }

  export type DumpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dump to aggregate.
     */
    where?: DumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dumps to fetch.
     */
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dumps
    **/
    _count?: true | DumpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DumpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DumpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DumpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DumpMaxAggregateInputType
  }

  export type GetDumpAggregateType<T extends DumpAggregateArgs> = {
        [P in keyof T & keyof AggregateDump]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDump[P]>
      : GetScalarType<T[P], AggregateDump[P]>
  }




  export type DumpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DumpWhereInput
    orderBy?: DumpOrderByWithAggregationInput | DumpOrderByWithAggregationInput[]
    by: DumpScalarFieldEnum[] | DumpScalarFieldEnum
    having?: DumpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DumpCountAggregateInputType | true
    _avg?: DumpAvgAggregateInputType
    _sum?: DumpSumAggregateInputType
    _min?: DumpMinAggregateInputType
    _max?: DumpMaxAggregateInputType
  }

  export type DumpGroupByOutputType = {
    id: string
    chainId: number
    fromTokenId: string
    toTokenId: string
    multisig: string
    recipient: string
    amountIn: string
    amountOut: string
    datetime: Date
    timestamp: number
    _count: DumpCountAggregateOutputType | null
    _avg: DumpAvgAggregateOutputType | null
    _sum: DumpSumAggregateOutputType | null
    _min: DumpMinAggregateOutputType | null
    _max: DumpMaxAggregateOutputType | null
  }

  type GetDumpGroupByPayload<T extends DumpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DumpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DumpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DumpGroupByOutputType[P]>
            : GetScalarType<T[P], DumpGroupByOutputType[P]>
        }
      >
    >


  export type DumpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    fromTokenId?: boolean
    toTokenId?: boolean
    multisig?: boolean
    recipient?: boolean
    amountIn?: boolean
    amountOut?: boolean
    datetime?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dump"]>

  export type DumpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    fromTokenId?: boolean
    toTokenId?: boolean
    multisig?: boolean
    recipient?: boolean
    amountIn?: boolean
    amountOut?: boolean
    datetime?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dump"]>

  export type DumpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    fromTokenId?: boolean
    toTokenId?: boolean
    multisig?: boolean
    recipient?: boolean
    amountIn?: boolean
    amountOut?: boolean
    datetime?: boolean
    timestamp?: boolean
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dump"]>

  export type DumpSelectScalar = {
    id?: boolean
    chainId?: boolean
    fromTokenId?: boolean
    toTokenId?: boolean
    multisig?: boolean
    recipient?: boolean
    amountIn?: boolean
    amountOut?: boolean
    datetime?: boolean
    timestamp?: boolean
  }

  export type DumpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chainId" | "fromTokenId" | "toTokenId" | "multisig" | "recipient" | "amountIn" | "amountOut" | "datetime" | "timestamp", ExtArgs["result"]["dump"]>
  export type DumpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type DumpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type DumpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chain?: boolean | ChainDefaultArgs<ExtArgs>
    FromToken?: boolean | TokenDefaultArgs<ExtArgs>
    ToToken?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $DumpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dump"
    objects: {
      Chain: Prisma.$ChainPayload<ExtArgs>
      FromToken: Prisma.$TokenPayload<ExtArgs>
      ToToken: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chainId: number
      fromTokenId: string
      toTokenId: string
      multisig: string
      recipient: string
      amountIn: string
      amountOut: string
      datetime: Date
      timestamp: number
    }, ExtArgs["result"]["dump"]>
    composites: {}
  }

  type DumpGetPayload<S extends boolean | null | undefined | DumpDefaultArgs> = $Result.GetResult<Prisma.$DumpPayload, S>

  type DumpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DumpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DumpCountAggregateInputType | true
    }

  export interface DumpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dump'], meta: { name: 'Dump' } }
    /**
     * Find zero or one Dump that matches the filter.
     * @param {DumpFindUniqueArgs} args - Arguments to find a Dump
     * @example
     * // Get one Dump
     * const dump = await prisma.dump.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DumpFindUniqueArgs>(args: SelectSubset<T, DumpFindUniqueArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Dump that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DumpFindUniqueOrThrowArgs} args - Arguments to find a Dump
     * @example
     * // Get one Dump
     * const dump = await prisma.dump.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DumpFindUniqueOrThrowArgs>(args: SelectSubset<T, DumpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Dump that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpFindFirstArgs} args - Arguments to find a Dump
     * @example
     * // Get one Dump
     * const dump = await prisma.dump.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DumpFindFirstArgs>(args?: SelectSubset<T, DumpFindFirstArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Dump that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpFindFirstOrThrowArgs} args - Arguments to find a Dump
     * @example
     * // Get one Dump
     * const dump = await prisma.dump.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DumpFindFirstOrThrowArgs>(args?: SelectSubset<T, DumpFindFirstOrThrowArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Dumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dumps
     * const dumps = await prisma.dump.findMany()
     * 
     * // Get first 10 Dumps
     * const dumps = await prisma.dump.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dumpWithIdOnly = await prisma.dump.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DumpFindManyArgs>(args?: SelectSubset<T, DumpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Dump.
     * @param {DumpCreateArgs} args - Arguments to create a Dump.
     * @example
     * // Create one Dump
     * const Dump = await prisma.dump.create({
     *   data: {
     *     // ... data to create a Dump
     *   }
     * })
     * 
     */
    create<T extends DumpCreateArgs>(args: SelectSubset<T, DumpCreateArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Dumps.
     * @param {DumpCreateManyArgs} args - Arguments to create many Dumps.
     * @example
     * // Create many Dumps
     * const dump = await prisma.dump.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DumpCreateManyArgs>(args?: SelectSubset<T, DumpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dumps and returns the data saved in the database.
     * @param {DumpCreateManyAndReturnArgs} args - Arguments to create many Dumps.
     * @example
     * // Create many Dumps
     * const dump = await prisma.dump.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dumps and only return the `id`
     * const dumpWithIdOnly = await prisma.dump.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DumpCreateManyAndReturnArgs>(args?: SelectSubset<T, DumpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Dump.
     * @param {DumpDeleteArgs} args - Arguments to delete one Dump.
     * @example
     * // Delete one Dump
     * const Dump = await prisma.dump.delete({
     *   where: {
     *     // ... filter to delete one Dump
     *   }
     * })
     * 
     */
    delete<T extends DumpDeleteArgs>(args: SelectSubset<T, DumpDeleteArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Dump.
     * @param {DumpUpdateArgs} args - Arguments to update one Dump.
     * @example
     * // Update one Dump
     * const dump = await prisma.dump.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DumpUpdateArgs>(args: SelectSubset<T, DumpUpdateArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Dumps.
     * @param {DumpDeleteManyArgs} args - Arguments to filter Dumps to delete.
     * @example
     * // Delete a few Dumps
     * const { count } = await prisma.dump.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DumpDeleteManyArgs>(args?: SelectSubset<T, DumpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dumps
     * const dump = await prisma.dump.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DumpUpdateManyArgs>(args: SelectSubset<T, DumpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dumps and returns the data updated in the database.
     * @param {DumpUpdateManyAndReturnArgs} args - Arguments to update many Dumps.
     * @example
     * // Update many Dumps
     * const dump = await prisma.dump.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dumps and only return the `id`
     * const dumpWithIdOnly = await prisma.dump.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DumpUpdateManyAndReturnArgs>(args: SelectSubset<T, DumpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Dump.
     * @param {DumpUpsertArgs} args - Arguments to update or create a Dump.
     * @example
     * // Update or create a Dump
     * const dump = await prisma.dump.upsert({
     *   create: {
     *     // ... data to create a Dump
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dump we want to update
     *   }
     * })
     */
    upsert<T extends DumpUpsertArgs>(args: SelectSubset<T, DumpUpsertArgs<ExtArgs>>): Prisma__DumpClient<$Result.GetResult<Prisma.$DumpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Dumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpCountArgs} args - Arguments to filter Dumps to count.
     * @example
     * // Count the number of Dumps
     * const count = await prisma.dump.count({
     *   where: {
     *     // ... the filter for the Dumps we want to count
     *   }
     * })
    **/
    count<T extends DumpCountArgs>(
      args?: Subset<T, DumpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DumpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DumpAggregateArgs>(args: Subset<T, DumpAggregateArgs>): Prisma.PrismaPromise<GetDumpAggregateType<T>>

    /**
     * Group by Dump.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DumpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DumpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DumpGroupByArgs['orderBy'] }
        : { orderBy?: DumpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DumpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDumpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dump model
   */
  readonly fields: DumpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dump.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DumpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chain<T extends ChainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChainDefaultArgs<ExtArgs>>): Prisma__ChainClient<$Result.GetResult<Prisma.$ChainPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    FromToken<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ToToken<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dump model
   */ 
  interface DumpFieldRefs {
    readonly id: FieldRef<"Dump", 'String'>
    readonly chainId: FieldRef<"Dump", 'Int'>
    readonly fromTokenId: FieldRef<"Dump", 'String'>
    readonly toTokenId: FieldRef<"Dump", 'String'>
    readonly multisig: FieldRef<"Dump", 'String'>
    readonly recipient: FieldRef<"Dump", 'String'>
    readonly amountIn: FieldRef<"Dump", 'String'>
    readonly amountOut: FieldRef<"Dump", 'String'>
    readonly datetime: FieldRef<"Dump", 'DateTime'>
    readonly timestamp: FieldRef<"Dump", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Dump findUnique
   */
  export type DumpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter, which Dump to fetch.
     */
    where: DumpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump findUniqueOrThrow
   */
  export type DumpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter, which Dump to fetch.
     */
    where: DumpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump findFirst
   */
  export type DumpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter, which Dump to fetch.
     */
    where?: DumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dumps to fetch.
     */
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dumps.
     */
    cursor?: DumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dumps.
     */
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump findFirstOrThrow
   */
  export type DumpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter, which Dump to fetch.
     */
    where?: DumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dumps to fetch.
     */
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dumps.
     */
    cursor?: DumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dumps.
     */
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump findMany
   */
  export type DumpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter, which Dumps to fetch.
     */
    where?: DumpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dumps to fetch.
     */
    orderBy?: DumpOrderByWithRelationInput | DumpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dumps.
     */
    cursor?: DumpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dumps.
     */
    skip?: number
    distinct?: DumpScalarFieldEnum | DumpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump create
   */
  export type DumpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * The data needed to create a Dump.
     */
    data: XOR<DumpCreateInput, DumpUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump createMany
   */
  export type DumpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dumps.
     */
    data: DumpCreateManyInput | DumpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dump createManyAndReturn
   */
  export type DumpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * The data used to create many Dumps.
     */
    data: DumpCreateManyInput | DumpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dump update
   */
  export type DumpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * The data needed to update a Dump.
     */
    data: XOR<DumpUpdateInput, DumpUncheckedUpdateInput>
    /**
     * Choose, which Dump to update.
     */
    where: DumpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump updateMany
   */
  export type DumpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dumps.
     */
    data: XOR<DumpUpdateManyMutationInput, DumpUncheckedUpdateManyInput>
    /**
     * Filter which Dumps to update
     */
    where?: DumpWhereInput
    /**
     * Limit how many Dumps to update.
     */
    limit?: number
  }

  /**
   * Dump updateManyAndReturn
   */
  export type DumpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * The data used to update Dumps.
     */
    data: XOR<DumpUpdateManyMutationInput, DumpUncheckedUpdateManyInput>
    /**
     * Filter which Dumps to update
     */
    where?: DumpWhereInput
    /**
     * Limit how many Dumps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dump upsert
   */
  export type DumpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * The filter to search for the Dump to update in case it exists.
     */
    where: DumpWhereUniqueInput
    /**
     * In case the Dump found by the `where` argument doesn't exist, create a new Dump with this data.
     */
    create: XOR<DumpCreateInput, DumpUncheckedCreateInput>
    /**
     * In case the Dump was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DumpUpdateInput, DumpUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump delete
   */
  export type DumpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
    /**
     * Filter which Dump to delete.
     */
    where: DumpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dump deleteMany
   */
  export type DumpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dumps to delete
     */
    where?: DumpWhereInput
    /**
     * Limit how many Dumps to delete.
     */
    limit?: number
  }

  /**
   * Dump without action
   */
  export type DumpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dump
     */
    select?: DumpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dump
     */
    omit?: DumpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DumpInclude<ExtArgs> | null
  }


  /**
   * Model Logged
   */

  export type AggregateLogged = {
    _count: LoggedCountAggregateOutputType | null
    _avg: LoggedAvgAggregateOutputType | null
    _sum: LoggedSumAggregateOutputType | null
    _min: LoggedMinAggregateOutputType | null
    _max: LoggedMaxAggregateOutputType | null
  }

  export type LoggedAvgAggregateOutputType = {
    chainId: number | null
    fetchAtBlock: number | null
  }

  export type LoggedSumAggregateOutputType = {
    chainId: number | null
    fetchAtBlock: number | null
  }

  export type LoggedMinAggregateOutputType = {
    id: string | null
    chainId: number | null
    type: $Enums.LoggedEntityType | null
    address: string | null
    fetchAtBlock: number | null
    caughtFromAddress: string | null
  }

  export type LoggedMaxAggregateOutputType = {
    id: string | null
    chainId: number | null
    type: $Enums.LoggedEntityType | null
    address: string | null
    fetchAtBlock: number | null
    caughtFromAddress: string | null
  }

  export type LoggedCountAggregateOutputType = {
    id: number
    chainId: number
    type: number
    address: number
    fetchAtBlock: number
    caughtFromAddress: number
    entityData: number
    _all: number
  }


  export type LoggedAvgAggregateInputType = {
    chainId?: true
    fetchAtBlock?: true
  }

  export type LoggedSumAggregateInputType = {
    chainId?: true
    fetchAtBlock?: true
  }

  export type LoggedMinAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    address?: true
    fetchAtBlock?: true
    caughtFromAddress?: true
  }

  export type LoggedMaxAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    address?: true
    fetchAtBlock?: true
    caughtFromAddress?: true
  }

  export type LoggedCountAggregateInputType = {
    id?: true
    chainId?: true
    type?: true
    address?: true
    fetchAtBlock?: true
    caughtFromAddress?: true
    entityData?: true
    _all?: true
  }

  export type LoggedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logged to aggregate.
     */
    where?: LoggedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggeds to fetch.
     */
    orderBy?: LoggedOrderByWithRelationInput | LoggedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoggedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loggeds
    **/
    _count?: true | LoggedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoggedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoggedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoggedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoggedMaxAggregateInputType
  }

  export type GetLoggedAggregateType<T extends LoggedAggregateArgs> = {
        [P in keyof T & keyof AggregateLogged]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogged[P]>
      : GetScalarType<T[P], AggregateLogged[P]>
  }




  export type LoggedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoggedWhereInput
    orderBy?: LoggedOrderByWithAggregationInput | LoggedOrderByWithAggregationInput[]
    by: LoggedScalarFieldEnum[] | LoggedScalarFieldEnum
    having?: LoggedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoggedCountAggregateInputType | true
    _avg?: LoggedAvgAggregateInputType
    _sum?: LoggedSumAggregateInputType
    _min?: LoggedMinAggregateInputType
    _max?: LoggedMaxAggregateInputType
  }

  export type LoggedGroupByOutputType = {
    id: string
    chainId: number
    type: $Enums.LoggedEntityType
    address: string | null
    fetchAtBlock: number
    caughtFromAddress: string
    entityData: JsonValue
    _count: LoggedCountAggregateOutputType | null
    _avg: LoggedAvgAggregateOutputType | null
    _sum: LoggedSumAggregateOutputType | null
    _min: LoggedMinAggregateOutputType | null
    _max: LoggedMaxAggregateOutputType | null
  }

  type GetLoggedGroupByPayload<T extends LoggedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoggedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoggedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoggedGroupByOutputType[P]>
            : GetScalarType<T[P], LoggedGroupByOutputType[P]>
        }
      >
    >


  export type LoggedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    address?: boolean
    fetchAtBlock?: boolean
    caughtFromAddress?: boolean
    entityData?: boolean
  }, ExtArgs["result"]["logged"]>

  export type LoggedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    address?: boolean
    fetchAtBlock?: boolean
    caughtFromAddress?: boolean
    entityData?: boolean
  }, ExtArgs["result"]["logged"]>

  export type LoggedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    type?: boolean
    address?: boolean
    fetchAtBlock?: boolean
    caughtFromAddress?: boolean
    entityData?: boolean
  }, ExtArgs["result"]["logged"]>

  export type LoggedSelectScalar = {
    id?: boolean
    chainId?: boolean
    type?: boolean
    address?: boolean
    fetchAtBlock?: boolean
    caughtFromAddress?: boolean
    entityData?: boolean
  }

  export type LoggedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chainId" | "type" | "address" | "fetchAtBlock" | "caughtFromAddress" | "entityData", ExtArgs["result"]["logged"]>

  export type $LoggedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logged"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chainId: number
      type: $Enums.LoggedEntityType
      address: string | null
      fetchAtBlock: number
      caughtFromAddress: string
      entityData: Prisma.JsonValue
    }, ExtArgs["result"]["logged"]>
    composites: {}
  }

  type LoggedGetPayload<S extends boolean | null | undefined | LoggedDefaultArgs> = $Result.GetResult<Prisma.$LoggedPayload, S>

  type LoggedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoggedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LoggedCountAggregateInputType | true
    }

  export interface LoggedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logged'], meta: { name: 'Logged' } }
    /**
     * Find zero or one Logged that matches the filter.
     * @param {LoggedFindUniqueArgs} args - Arguments to find a Logged
     * @example
     * // Get one Logged
     * const logged = await prisma.logged.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoggedFindUniqueArgs>(args: SelectSubset<T, LoggedFindUniqueArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Logged that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoggedFindUniqueOrThrowArgs} args - Arguments to find a Logged
     * @example
     * // Get one Logged
     * const logged = await prisma.logged.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoggedFindUniqueOrThrowArgs>(args: SelectSubset<T, LoggedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Logged that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedFindFirstArgs} args - Arguments to find a Logged
     * @example
     * // Get one Logged
     * const logged = await prisma.logged.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoggedFindFirstArgs>(args?: SelectSubset<T, LoggedFindFirstArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Logged that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedFindFirstOrThrowArgs} args - Arguments to find a Logged
     * @example
     * // Get one Logged
     * const logged = await prisma.logged.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoggedFindFirstOrThrowArgs>(args?: SelectSubset<T, LoggedFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Loggeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loggeds
     * const loggeds = await prisma.logged.findMany()
     * 
     * // Get first 10 Loggeds
     * const loggeds = await prisma.logged.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loggedWithIdOnly = await prisma.logged.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoggedFindManyArgs>(args?: SelectSubset<T, LoggedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Logged.
     * @param {LoggedCreateArgs} args - Arguments to create a Logged.
     * @example
     * // Create one Logged
     * const Logged = await prisma.logged.create({
     *   data: {
     *     // ... data to create a Logged
     *   }
     * })
     * 
     */
    create<T extends LoggedCreateArgs>(args: SelectSubset<T, LoggedCreateArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Loggeds.
     * @param {LoggedCreateManyArgs} args - Arguments to create many Loggeds.
     * @example
     * // Create many Loggeds
     * const logged = await prisma.logged.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoggedCreateManyArgs>(args?: SelectSubset<T, LoggedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loggeds and returns the data saved in the database.
     * @param {LoggedCreateManyAndReturnArgs} args - Arguments to create many Loggeds.
     * @example
     * // Create many Loggeds
     * const logged = await prisma.logged.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loggeds and only return the `id`
     * const loggedWithIdOnly = await prisma.logged.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoggedCreateManyAndReturnArgs>(args?: SelectSubset<T, LoggedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Logged.
     * @param {LoggedDeleteArgs} args - Arguments to delete one Logged.
     * @example
     * // Delete one Logged
     * const Logged = await prisma.logged.delete({
     *   where: {
     *     // ... filter to delete one Logged
     *   }
     * })
     * 
     */
    delete<T extends LoggedDeleteArgs>(args: SelectSubset<T, LoggedDeleteArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Logged.
     * @param {LoggedUpdateArgs} args - Arguments to update one Logged.
     * @example
     * // Update one Logged
     * const logged = await prisma.logged.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoggedUpdateArgs>(args: SelectSubset<T, LoggedUpdateArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Loggeds.
     * @param {LoggedDeleteManyArgs} args - Arguments to filter Loggeds to delete.
     * @example
     * // Delete a few Loggeds
     * const { count } = await prisma.logged.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoggedDeleteManyArgs>(args?: SelectSubset<T, LoggedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loggeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loggeds
     * const logged = await prisma.logged.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoggedUpdateManyArgs>(args: SelectSubset<T, LoggedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loggeds and returns the data updated in the database.
     * @param {LoggedUpdateManyAndReturnArgs} args - Arguments to update many Loggeds.
     * @example
     * // Update many Loggeds
     * const logged = await prisma.logged.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loggeds and only return the `id`
     * const loggedWithIdOnly = await prisma.logged.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoggedUpdateManyAndReturnArgs>(args: SelectSubset<T, LoggedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Logged.
     * @param {LoggedUpsertArgs} args - Arguments to update or create a Logged.
     * @example
     * // Update or create a Logged
     * const logged = await prisma.logged.upsert({
     *   create: {
     *     // ... data to create a Logged
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logged we want to update
     *   }
     * })
     */
    upsert<T extends LoggedUpsertArgs>(args: SelectSubset<T, LoggedUpsertArgs<ExtArgs>>): Prisma__LoggedClient<$Result.GetResult<Prisma.$LoggedPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Loggeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedCountArgs} args - Arguments to filter Loggeds to count.
     * @example
     * // Count the number of Loggeds
     * const count = await prisma.logged.count({
     *   where: {
     *     // ... the filter for the Loggeds we want to count
     *   }
     * })
    **/
    count<T extends LoggedCountArgs>(
      args?: Subset<T, LoggedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoggedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logged.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoggedAggregateArgs>(args: Subset<T, LoggedAggregateArgs>): Prisma.PrismaPromise<GetLoggedAggregateType<T>>

    /**
     * Group by Logged.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoggedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoggedGroupByArgs['orderBy'] }
        : { orderBy?: LoggedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoggedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoggedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logged model
   */
  readonly fields: LoggedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logged.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoggedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logged model
   */ 
  interface LoggedFieldRefs {
    readonly id: FieldRef<"Logged", 'String'>
    readonly chainId: FieldRef<"Logged", 'Int'>
    readonly type: FieldRef<"Logged", 'LoggedEntityType'>
    readonly address: FieldRef<"Logged", 'String'>
    readonly fetchAtBlock: FieldRef<"Logged", 'Int'>
    readonly caughtFromAddress: FieldRef<"Logged", 'String'>
    readonly entityData: FieldRef<"Logged", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Logged findUnique
   */
  export type LoggedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter, which Logged to fetch.
     */
    where: LoggedWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged findUniqueOrThrow
   */
  export type LoggedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter, which Logged to fetch.
     */
    where: LoggedWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged findFirst
   */
  export type LoggedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter, which Logged to fetch.
     */
    where?: LoggedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggeds to fetch.
     */
    orderBy?: LoggedOrderByWithRelationInput | LoggedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loggeds.
     */
    cursor?: LoggedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loggeds.
     */
    distinct?: LoggedScalarFieldEnum | LoggedScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged findFirstOrThrow
   */
  export type LoggedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter, which Logged to fetch.
     */
    where?: LoggedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggeds to fetch.
     */
    orderBy?: LoggedOrderByWithRelationInput | LoggedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loggeds.
     */
    cursor?: LoggedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loggeds.
     */
    distinct?: LoggedScalarFieldEnum | LoggedScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged findMany
   */
  export type LoggedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter, which Loggeds to fetch.
     */
    where?: LoggedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loggeds to fetch.
     */
    orderBy?: LoggedOrderByWithRelationInput | LoggedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loggeds.
     */
    cursor?: LoggedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loggeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loggeds.
     */
    skip?: number
    distinct?: LoggedScalarFieldEnum | LoggedScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged create
   */
  export type LoggedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * The data needed to create a Logged.
     */
    data: XOR<LoggedCreateInput, LoggedUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged createMany
   */
  export type LoggedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loggeds.
     */
    data: LoggedCreateManyInput | LoggedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logged createManyAndReturn
   */
  export type LoggedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * The data used to create many Loggeds.
     */
    data: LoggedCreateManyInput | LoggedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logged update
   */
  export type LoggedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * The data needed to update a Logged.
     */
    data: XOR<LoggedUpdateInput, LoggedUncheckedUpdateInput>
    /**
     * Choose, which Logged to update.
     */
    where: LoggedWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged updateMany
   */
  export type LoggedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loggeds.
     */
    data: XOR<LoggedUpdateManyMutationInput, LoggedUncheckedUpdateManyInput>
    /**
     * Filter which Loggeds to update
     */
    where?: LoggedWhereInput
    /**
     * Limit how many Loggeds to update.
     */
    limit?: number
  }

  /**
   * Logged updateManyAndReturn
   */
  export type LoggedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * The data used to update Loggeds.
     */
    data: XOR<LoggedUpdateManyMutationInput, LoggedUncheckedUpdateManyInput>
    /**
     * Filter which Loggeds to update
     */
    where?: LoggedWhereInput
    /**
     * Limit how many Loggeds to update.
     */
    limit?: number
  }

  /**
   * Logged upsert
   */
  export type LoggedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * The filter to search for the Logged to update in case it exists.
     */
    where: LoggedWhereUniqueInput
    /**
     * In case the Logged found by the `where` argument doesn't exist, create a new Logged with this data.
     */
    create: XOR<LoggedCreateInput, LoggedUncheckedCreateInput>
    /**
     * In case the Logged was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoggedUpdateInput, LoggedUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged delete
   */
  export type LoggedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
    /**
     * Filter which Logged to delete.
     */
    where: LoggedWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Logged deleteMany
   */
  export type LoggedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loggeds to delete
     */
    where?: LoggedWhereInput
    /**
     * Limit how many Loggeds to delete.
     */
    limit?: number
  }

  /**
   * Logged without action
   */
  export type LoggedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logged
     */
    select?: LoggedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logged
     */
    omit?: LoggedOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    computeChainId: 'computeChainId',
    distributionChainId: 'distributionChainId',
    campaignId: 'campaignId',
    type: 'type',
    distributionType: 'distributionType',
    subType: 'subType',
    rewardTokenId: 'rewardTokenId',
    amount: 'amount',
    opportunityId: 'opportunityId',
    startTimestamp: 'startTimestamp',
    endTimestamp: 'endTimestamp',
    params: 'params',
    description: 'description',
    creatorAddress: 'creatorAddress',
    manualOverrides: 'manualOverrides',
    createdAt: 'createdAt',
    rootCampaignId: 'rootCampaignId',
    parentCampaignId: 'parentCampaignId'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const CampaignStatusScalarFieldEnum: {
    campaignId: 'campaignId',
    computedUntil: 'computedUntil',
    processingStarted: 'processingStarted',
    status: 'status',
    error: 'error',
    details: 'details'
  };

  export type CampaignStatusScalarFieldEnum = (typeof CampaignStatusScalarFieldEnum)[keyof typeof CampaignStatusScalarFieldEnum]


  export const CampaignComputedValueScalarFieldEnum: {
    campaignId: 'campaignId',
    averageBoost: 'averageBoost',
    totalDistributedInUSD: 'totalDistributedInUSD',
    forfeitingBoost: 'forfeitingBoost'
  };

  export type CampaignComputedValueScalarFieldEnum = (typeof CampaignComputedValueScalarFieldEnum)[keyof typeof CampaignComputedValueScalarFieldEnum]


  export const UserComputedValueScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    address: 'address',
    reason: 'reason',
    boost: 'boost'
  };

  export type UserComputedValueScalarFieldEnum = (typeof UserComputedValueScalarFieldEnum)[keyof typeof UserComputedValueScalarFieldEnum]


  export const ChainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon'
  };

  export type ChainScalarFieldEnum = (typeof ChainScalarFieldEnum)[keyof typeof ChainScalarFieldEnum]


  export const ExplorerScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    chainId: 'chainId'
  };

  export type ExplorerScalarFieldEnum = (typeof ExplorerScalarFieldEnum)[keyof typeof ExplorerScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    chainId: 'chainId',
    type: 'type',
    identifier: 'identifier',
    name: 'name',
    description: 'description',
    howToSteps: 'howToSteps',
    depositUrl: 'depositUrl',
    explorerAddress: 'explorerAddress',
    status: 'status',
    action: 'action',
    mainProtocolId: 'mainProtocolId',
    tvl: 'tvl',
    apr: 'apr',
    dailyRewards: 'dailyRewards',
    tags: 'tags',
    lastCampaignCreatedAt: 'lastCampaignCreatedAt',
    manualOverrides: 'manualOverrides'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const ProtocolScalarFieldEnum: {
    id: 'id',
    tags: 'tags',
    name: 'name',
    description: 'description',
    url: 'url',
    icon: 'icon'
  };

  export type ProtocolScalarFieldEnum = (typeof ProtocolScalarFieldEnum)[keyof typeof ProtocolScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    chainId: 'chainId',
    address: 'address',
    decimals: 'decimals',
    symbol: 'symbol',
    displaySymbol: 'displaySymbol',
    icon: 'icon',
    verified: 'verified',
    isTest: 'isTest',
    isPoint: 'isPoint',
    isPreTGE: 'isPreTGE',
    isNative: 'isNative',
    price: 'price'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const AprRecordScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    cumulated: 'cumulated',
    opportunityId: 'opportunityId'
  };

  export type AprRecordScalarFieldEnum = (typeof AprRecordScalarFieldEnum)[keyof typeof AprRecordScalarFieldEnum]


  export const AprBreakdownScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    type: 'type',
    value: 'value',
    aprRecordId: 'aprRecordId'
  };

  export type AprBreakdownScalarFieldEnum = (typeof AprBreakdownScalarFieldEnum)[keyof typeof AprBreakdownScalarFieldEnum]


  export const TVLRecordScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    total: 'total',
    opportunityId: 'opportunityId'
  };

  export type TVLRecordScalarFieldEnum = (typeof TVLRecordScalarFieldEnum)[keyof typeof TVLRecordScalarFieldEnum]


  export const TVLBreakdownScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    type: 'type',
    value: 'value',
    tvlRecordId: 'tvlRecordId'
  };

  export type TVLBreakdownScalarFieldEnum = (typeof TVLBreakdownScalarFieldEnum)[keyof typeof TVLBreakdownScalarFieldEnum]


  export const DailyRewardsRecordScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    total: 'total',
    opportunityId: 'opportunityId'
  };

  export type DailyRewardsRecordScalarFieldEnum = (typeof DailyRewardsRecordScalarFieldEnum)[keyof typeof DailyRewardsRecordScalarFieldEnum]


  export const DailyRewardsBreakdownScalarFieldEnum: {
    id: 'id',
    value: 'value',
    campaignId: 'campaignId',
    dailyRewardsRecordId: 'dailyRewardsRecordId'
  };

  export type DailyRewardsBreakdownScalarFieldEnum = (typeof DailyRewardsBreakdownScalarFieldEnum)[keyof typeof DailyRewardsBreakdownScalarFieldEnum]


  export const UserScalarFieldEnum: {
    address: 'address',
    tags: 'tags',
    creatorId: 'creatorId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CreatorScalarFieldEnum: {
    id: 'id',
    icon: 'icon',
    name: 'name',
    rebateFee: 'rebateFee'
  };

  export type CreatorScalarFieldEnum = (typeof CreatorScalarFieldEnum)[keyof typeof CreatorScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    root: 'root',
    recipient: 'recipient',
    rewardTokenId: 'rewardTokenId',
    amount: 'amount',
    claimed: 'claimed',
    pending: 'pending',
    proofs: 'proofs'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const RewardBreakdownScalarFieldEnum: {
    id: 'id',
    protocolId: 'protocolId',
    reason: 'reason',
    amount: 'amount',
    claimed: 'claimed',
    pending: 'pending',
    rewardId: 'rewardId',
    campaignId: 'campaignId',
    subCampaignId: 'subCampaignId'
  };

  export type RewardBreakdownScalarFieldEnum = (typeof RewardBreakdownScalarFieldEnum)[keyof typeof RewardBreakdownScalarFieldEnum]


  export const MerklRootScalarFieldEnum: {
    root: 'root',
    chainId: 'chainId',
    epoch: 'epoch',
    timestamp: 'timestamp'
  };

  export type MerklRootScalarFieldEnum = (typeof MerklRootScalarFieldEnum)[keyof typeof MerklRootScalarFieldEnum]


  export const PriceSourceScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    method: 'method',
    args: 'args'
  };

  export type PriceSourceScalarFieldEnum = (typeof PriceSourceScalarFieldEnum)[keyof typeof PriceSourceScalarFieldEnum]


  export const BlacklistScalarFieldEnum: {
    id: 'id',
    chainId: 'chainId',
    poolAddress: 'poolAddress',
    userAddress: 'userAddress',
    arrestTimestamp: 'arrestTimestamp',
    arrestDetails: 'arrestDetails'
  };

  export type BlacklistScalarFieldEnum = (typeof BlacklistScalarFieldEnum)[keyof typeof BlacklistScalarFieldEnum]


  export const DumpScalarFieldEnum: {
    id: 'id',
    chainId: 'chainId',
    fromTokenId: 'fromTokenId',
    toTokenId: 'toTokenId',
    multisig: 'multisig',
    recipient: 'recipient',
    amountIn: 'amountIn',
    amountOut: 'amountOut',
    datetime: 'datetime',
    timestamp: 'timestamp'
  };

  export type DumpScalarFieldEnum = (typeof DumpScalarFieldEnum)[keyof typeof DumpScalarFieldEnum]


  export const LoggedScalarFieldEnum: {
    id: 'id',
    chainId: 'chainId',
    type: 'type',
    address: 'address',
    fetchAtBlock: 'fetchAtBlock',
    caughtFromAddress: 'caughtFromAddress',
    entityData: 'entityData'
  };

  export type LoggedScalarFieldEnum = (typeof LoggedScalarFieldEnum)[keyof typeof LoggedScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CampaignOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type',
    rewardTokenId: 'rewardTokenId',
    amount: 'amount',
    opportunityId: 'opportunityId',
    description: 'description',
    creatorAddress: 'creatorAddress',
    rootCampaignId: 'rootCampaignId',
    parentCampaignId: 'parentCampaignId'
  };

  export type CampaignOrderByRelevanceFieldEnum = (typeof CampaignOrderByRelevanceFieldEnum)[keyof typeof CampaignOrderByRelevanceFieldEnum]


  export const CampaignStatusOrderByRelevanceFieldEnum: {
    campaignId: 'campaignId',
    error: 'error'
  };

  export type CampaignStatusOrderByRelevanceFieldEnum = (typeof CampaignStatusOrderByRelevanceFieldEnum)[keyof typeof CampaignStatusOrderByRelevanceFieldEnum]


  export const CampaignComputedValueOrderByRelevanceFieldEnum: {
    campaignId: 'campaignId'
  };

  export type CampaignComputedValueOrderByRelevanceFieldEnum = (typeof CampaignComputedValueOrderByRelevanceFieldEnum)[keyof typeof CampaignComputedValueOrderByRelevanceFieldEnum]


  export const UserComputedValueOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    address: 'address',
    reason: 'reason'
  };

  export type UserComputedValueOrderByRelevanceFieldEnum = (typeof UserComputedValueOrderByRelevanceFieldEnum)[keyof typeof UserComputedValueOrderByRelevanceFieldEnum]


  export const ChainOrderByRelevanceFieldEnum: {
    name: 'name',
    icon: 'icon'
  };

  export type ChainOrderByRelevanceFieldEnum = (typeof ChainOrderByRelevanceFieldEnum)[keyof typeof ChainOrderByRelevanceFieldEnum]


  export const ExplorerOrderByRelevanceFieldEnum: {
    id: 'id',
    url: 'url'
  };

  export type ExplorerOrderByRelevanceFieldEnum = (typeof ExplorerOrderByRelevanceFieldEnum)[keyof typeof ExplorerOrderByRelevanceFieldEnum]


  export const OpportunityOrderByRelevanceFieldEnum: {
    id: 'id',
    type: 'type',
    identifier: 'identifier',
    name: 'name',
    description: 'description',
    howToSteps: 'howToSteps',
    depositUrl: 'depositUrl',
    explorerAddress: 'explorerAddress',
    mainProtocolId: 'mainProtocolId',
    tags: 'tags'
  };

  export type OpportunityOrderByRelevanceFieldEnum = (typeof OpportunityOrderByRelevanceFieldEnum)[keyof typeof OpportunityOrderByRelevanceFieldEnum]


  export const ProtocolOrderByRelevanceFieldEnum: {
    id: 'id',
    tags: 'tags',
    name: 'name',
    description: 'description',
    url: 'url',
    icon: 'icon'
  };

  export type ProtocolOrderByRelevanceFieldEnum = (typeof ProtocolOrderByRelevanceFieldEnum)[keyof typeof ProtocolOrderByRelevanceFieldEnum]


  export const TokenOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    symbol: 'symbol',
    displaySymbol: 'displaySymbol',
    icon: 'icon'
  };

  export type TokenOrderByRelevanceFieldEnum = (typeof TokenOrderByRelevanceFieldEnum)[keyof typeof TokenOrderByRelevanceFieldEnum]


  export const AprRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId'
  };

  export type AprRecordOrderByRelevanceFieldEnum = (typeof AprRecordOrderByRelevanceFieldEnum)[keyof typeof AprRecordOrderByRelevanceFieldEnum]


  export const AprBreakdownOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    aprRecordId: 'aprRecordId'
  };

  export type AprBreakdownOrderByRelevanceFieldEnum = (typeof AprBreakdownOrderByRelevanceFieldEnum)[keyof typeof AprBreakdownOrderByRelevanceFieldEnum]


  export const TVLRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId'
  };

  export type TVLRecordOrderByRelevanceFieldEnum = (typeof TVLRecordOrderByRelevanceFieldEnum)[keyof typeof TVLRecordOrderByRelevanceFieldEnum]


  export const TVLBreakdownOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    tvlRecordId: 'tvlRecordId'
  };

  export type TVLBreakdownOrderByRelevanceFieldEnum = (typeof TVLBreakdownOrderByRelevanceFieldEnum)[keyof typeof TVLBreakdownOrderByRelevanceFieldEnum]


  export const DailyRewardsRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    opportunityId: 'opportunityId'
  };

  export type DailyRewardsRecordOrderByRelevanceFieldEnum = (typeof DailyRewardsRecordOrderByRelevanceFieldEnum)[keyof typeof DailyRewardsRecordOrderByRelevanceFieldEnum]


  export const DailyRewardsBreakdownOrderByRelevanceFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    dailyRewardsRecordId: 'dailyRewardsRecordId'
  };

  export type DailyRewardsBreakdownOrderByRelevanceFieldEnum = (typeof DailyRewardsBreakdownOrderByRelevanceFieldEnum)[keyof typeof DailyRewardsBreakdownOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    address: 'address',
    tags: 'tags',
    creatorId: 'creatorId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const CreatorOrderByRelevanceFieldEnum: {
    id: 'id',
    icon: 'icon',
    name: 'name'
  };

  export type CreatorOrderByRelevanceFieldEnum = (typeof CreatorOrderByRelevanceFieldEnum)[keyof typeof CreatorOrderByRelevanceFieldEnum]


  export const RewardOrderByRelevanceFieldEnum: {
    id: 'id',
    root: 'root',
    recipient: 'recipient',
    rewardTokenId: 'rewardTokenId',
    amount: 'amount',
    claimed: 'claimed',
    pending: 'pending',
    proofs: 'proofs'
  };

  export type RewardOrderByRelevanceFieldEnum = (typeof RewardOrderByRelevanceFieldEnum)[keyof typeof RewardOrderByRelevanceFieldEnum]


  export const RewardBreakdownOrderByRelevanceFieldEnum: {
    id: 'id',
    protocolId: 'protocolId',
    reason: 'reason',
    amount: 'amount',
    claimed: 'claimed',
    pending: 'pending',
    rewardId: 'rewardId',
    campaignId: 'campaignId',
    subCampaignId: 'subCampaignId'
  };

  export type RewardBreakdownOrderByRelevanceFieldEnum = (typeof RewardBreakdownOrderByRelevanceFieldEnum)[keyof typeof RewardBreakdownOrderByRelevanceFieldEnum]


  export const MerklRootOrderByRelevanceFieldEnum: {
    root: 'root'
  };

  export type MerklRootOrderByRelevanceFieldEnum = (typeof MerklRootOrderByRelevanceFieldEnum)[keyof typeof MerklRootOrderByRelevanceFieldEnum]


  export const PriceSourceOrderByRelevanceFieldEnum: {
    symbol: 'symbol'
  };

  export type PriceSourceOrderByRelevanceFieldEnum = (typeof PriceSourceOrderByRelevanceFieldEnum)[keyof typeof PriceSourceOrderByRelevanceFieldEnum]


  export const BlacklistOrderByRelevanceFieldEnum: {
    id: 'id',
    poolAddress: 'poolAddress',
    userAddress: 'userAddress'
  };

  export type BlacklistOrderByRelevanceFieldEnum = (typeof BlacklistOrderByRelevanceFieldEnum)[keyof typeof BlacklistOrderByRelevanceFieldEnum]


  export const DumpOrderByRelevanceFieldEnum: {
    id: 'id',
    fromTokenId: 'fromTokenId',
    toTokenId: 'toTokenId',
    multisig: 'multisig',
    recipient: 'recipient',
    amountIn: 'amountIn',
    amountOut: 'amountOut'
  };

  export type DumpOrderByRelevanceFieldEnum = (typeof DumpOrderByRelevanceFieldEnum)[keyof typeof DumpOrderByRelevanceFieldEnum]


  export const LoggedOrderByRelevanceFieldEnum: {
    id: 'id',
    address: 'address',
    caughtFromAddress: 'caughtFromAddress'
  };

  export type LoggedOrderByRelevanceFieldEnum = (typeof LoggedOrderByRelevanceFieldEnum)[keyof typeof LoggedOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DistributionType'
   */
  export type EnumDistributionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DistributionType'>
    


  /**
   * Reference to a field of type 'DistributionType[]'
   */
  export type ListEnumDistributionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DistributionType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CampaignManualOverride[]'
   */
  export type ListEnumCampaignManualOverrideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignManualOverride[]'>
    


  /**
   * Reference to a field of type 'CampaignManualOverride'
   */
  export type EnumCampaignManualOverrideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignManualOverride'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'RunStatus'
   */
  export type EnumRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RunStatus'>
    


  /**
   * Reference to a field of type 'RunStatus[]'
   */
  export type ListEnumRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RunStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ExplorerType'
   */
  export type EnumExplorerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExplorerType'>
    


  /**
   * Reference to a field of type 'ExplorerType[]'
   */
  export type ListEnumExplorerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExplorerType[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'OpportunityAction'
   */
  export type EnumOpportunityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityAction'>
    


  /**
   * Reference to a field of type 'OpportunityAction[]'
   */
  export type ListEnumOpportunityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityAction[]'>
    


  /**
   * Reference to a field of type 'OpportunityManualOverride[]'
   */
  export type ListEnumOpportunityManualOverrideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityManualOverride[]'>
    


  /**
   * Reference to a field of type 'OpportunityManualOverride'
   */
  export type EnumOpportunityManualOverrideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityManualOverride'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AprType'
   */
  export type EnumAprTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AprType'>
    


  /**
   * Reference to a field of type 'AprType[]'
   */
  export type ListEnumAprTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AprType[]'>
    


  /**
   * Reference to a field of type 'TvlType'
   */
  export type EnumTvlTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TvlType'>
    


  /**
   * Reference to a field of type 'TvlType[]'
   */
  export type ListEnumTvlTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TvlType[]'>
    


  /**
   * Reference to a field of type 'PriceSourceMethod'
   */
  export type EnumPriceSourceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceSourceMethod'>
    


  /**
   * Reference to a field of type 'PriceSourceMethod[]'
   */
  export type ListEnumPriceSourceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceSourceMethod[]'>
    


  /**
   * Reference to a field of type 'LoggedEntityType'
   */
  export type EnumLoggedEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoggedEntityType'>
    


  /**
   * Reference to a field of type 'LoggedEntityType[]'
   */
  export type ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoggedEntityType[]'>
    
  /**
   * Deep Input Types
   */


  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    computeChainId?: IntFilter<"Campaign"> | number
    distributionChainId?: IntFilter<"Campaign"> | number
    campaignId?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    distributionType?: EnumDistributionTypeFilter<"Campaign"> | $Enums.DistributionType
    subType?: IntNullableFilter<"Campaign"> | number | null
    rewardTokenId?: StringFilter<"Campaign"> | string
    amount?: StringFilter<"Campaign"> | string
    opportunityId?: StringFilter<"Campaign"> | string
    startTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    endTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    params?: JsonFilter<"Campaign">
    description?: StringNullableFilter<"Campaign"> | string | null
    creatorAddress?: StringFilter<"Campaign"> | string
    manualOverrides?: EnumCampaignManualOverrideNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    rootCampaignId?: StringNullableFilter<"Campaign"> | string | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
    ComputeChain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    DistributionChain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    RewardToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    RewardBreakdown?: RewardBreakdownListRelationFilter
    DailyRewardsBreakdown?: DailyRewardsBreakdownListRelationFilter
    Creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    CampaignStatus?: CampaignStatusListRelationFilter
    CampaignEngineValues?: CampaignComputedValueListRelationFilter
    UserComputedValue?: UserComputedValueListRelationFilter
    rootCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    subCampaigns?: CampaignListRelationFilter
    parentCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    childCampaigns?: CampaignListRelationFilter
    RewardBreakdownSubCampaign?: RewardBreakdownListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    distributionType?: SortOrder
    subType?: SortOrderInput | SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    opportunityId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    params?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorAddress?: SortOrder
    manualOverrides?: SortOrder
    createdAt?: SortOrder
    rootCampaignId?: SortOrderInput | SortOrder
    parentCampaignId?: SortOrderInput | SortOrder
    ComputeChain?: ChainOrderByWithRelationInput
    DistributionChain?: ChainOrderByWithRelationInput
    RewardToken?: TokenOrderByWithRelationInput
    Opportunity?: OpportunityOrderByWithRelationInput
    RewardBreakdown?: RewardBreakdownOrderByRelationAggregateInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownOrderByRelationAggregateInput
    Creator?: UserOrderByWithRelationInput
    CampaignStatus?: CampaignStatusOrderByRelationAggregateInput
    CampaignEngineValues?: CampaignComputedValueOrderByRelationAggregateInput
    UserComputedValue?: UserComputedValueOrderByRelationAggregateInput
    rootCampaign?: CampaignOrderByWithRelationInput
    subCampaigns?: CampaignOrderByRelationAggregateInput
    parentCampaign?: CampaignOrderByWithRelationInput
    childCampaigns?: CampaignOrderByRelationAggregateInput
    RewardBreakdownSubCampaign?: RewardBreakdownOrderByRelationAggregateInput
    _relevance?: CampaignOrderByRelevanceInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    distributionChainId_campaignId?: CampaignDistributionChainIdCampaignIdCompoundUniqueInput
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    computeChainId?: IntFilter<"Campaign"> | number
    distributionChainId?: IntFilter<"Campaign"> | number
    campaignId?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    distributionType?: EnumDistributionTypeFilter<"Campaign"> | $Enums.DistributionType
    subType?: IntNullableFilter<"Campaign"> | number | null
    rewardTokenId?: StringFilter<"Campaign"> | string
    amount?: StringFilter<"Campaign"> | string
    opportunityId?: StringFilter<"Campaign"> | string
    startTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    endTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    params?: JsonFilter<"Campaign">
    description?: StringNullableFilter<"Campaign"> | string | null
    creatorAddress?: StringFilter<"Campaign"> | string
    manualOverrides?: EnumCampaignManualOverrideNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    rootCampaignId?: StringNullableFilter<"Campaign"> | string | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
    ComputeChain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    DistributionChain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    RewardToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    RewardBreakdown?: RewardBreakdownListRelationFilter
    DailyRewardsBreakdown?: DailyRewardsBreakdownListRelationFilter
    Creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    CampaignStatus?: CampaignStatusListRelationFilter
    CampaignEngineValues?: CampaignComputedValueListRelationFilter
    UserComputedValue?: UserComputedValueListRelationFilter
    rootCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    subCampaigns?: CampaignListRelationFilter
    parentCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    childCampaigns?: CampaignListRelationFilter
    RewardBreakdownSubCampaign?: RewardBreakdownListRelationFilter
  }, "id" | "distributionChainId_campaignId">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    distributionType?: SortOrder
    subType?: SortOrderInput | SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    opportunityId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    params?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorAddress?: SortOrder
    manualOverrides?: SortOrder
    createdAt?: SortOrder
    rootCampaignId?: SortOrderInput | SortOrder
    parentCampaignId?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    computeChainId?: IntWithAggregatesFilter<"Campaign"> | number
    distributionChainId?: IntWithAggregatesFilter<"Campaign"> | number
    campaignId?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    distributionType?: EnumDistributionTypeWithAggregatesFilter<"Campaign"> | $Enums.DistributionType
    subType?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    rewardTokenId?: StringWithAggregatesFilter<"Campaign"> | string
    amount?: StringWithAggregatesFilter<"Campaign"> | string
    opportunityId?: StringWithAggregatesFilter<"Campaign"> | string
    startTimestamp?: BigIntWithAggregatesFilter<"Campaign"> | bigint | number
    endTimestamp?: BigIntWithAggregatesFilter<"Campaign"> | bigint | number
    params?: JsonWithAggregatesFilter<"Campaign">
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    creatorAddress?: StringWithAggregatesFilter<"Campaign"> | string
    manualOverrides?: EnumCampaignManualOverrideNullableListFilter<"Campaign">
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    rootCampaignId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    parentCampaignId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
  }

  export type CampaignStatusWhereInput = {
    AND?: CampaignStatusWhereInput | CampaignStatusWhereInput[]
    OR?: CampaignStatusWhereInput[]
    NOT?: CampaignStatusWhereInput | CampaignStatusWhereInput[]
    campaignId?: StringFilter<"CampaignStatus"> | string
    computedUntil?: BigIntFilter<"CampaignStatus"> | bigint | number
    processingStarted?: BigIntFilter<"CampaignStatus"> | bigint | number
    status?: EnumRunStatusFilter<"CampaignStatus"> | $Enums.RunStatus
    error?: StringFilter<"CampaignStatus"> | string
    details?: JsonFilter<"CampaignStatus">
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignStatusOrderByWithRelationInput = {
    campaignId?: SortOrder
    computedUntil?: SortOrder
    processingStarted?: SortOrder
    status?: SortOrder
    error?: SortOrder
    details?: SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    _relevance?: CampaignStatusOrderByRelevanceInput
  }

  export type CampaignStatusWhereUniqueInput = Prisma.AtLeast<{
    campaignId?: string
    AND?: CampaignStatusWhereInput | CampaignStatusWhereInput[]
    OR?: CampaignStatusWhereInput[]
    NOT?: CampaignStatusWhereInput | CampaignStatusWhereInput[]
    computedUntil?: BigIntFilter<"CampaignStatus"> | bigint | number
    processingStarted?: BigIntFilter<"CampaignStatus"> | bigint | number
    status?: EnumRunStatusFilter<"CampaignStatus"> | $Enums.RunStatus
    error?: StringFilter<"CampaignStatus"> | string
    details?: JsonFilter<"CampaignStatus">
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "campaignId">

  export type CampaignStatusOrderByWithAggregationInput = {
    campaignId?: SortOrder
    computedUntil?: SortOrder
    processingStarted?: SortOrder
    status?: SortOrder
    error?: SortOrder
    details?: SortOrder
    _count?: CampaignStatusCountOrderByAggregateInput
    _avg?: CampaignStatusAvgOrderByAggregateInput
    _max?: CampaignStatusMaxOrderByAggregateInput
    _min?: CampaignStatusMinOrderByAggregateInput
    _sum?: CampaignStatusSumOrderByAggregateInput
  }

  export type CampaignStatusScalarWhereWithAggregatesInput = {
    AND?: CampaignStatusScalarWhereWithAggregatesInput | CampaignStatusScalarWhereWithAggregatesInput[]
    OR?: CampaignStatusScalarWhereWithAggregatesInput[]
    NOT?: CampaignStatusScalarWhereWithAggregatesInput | CampaignStatusScalarWhereWithAggregatesInput[]
    campaignId?: StringWithAggregatesFilter<"CampaignStatus"> | string
    computedUntil?: BigIntWithAggregatesFilter<"CampaignStatus"> | bigint | number
    processingStarted?: BigIntWithAggregatesFilter<"CampaignStatus"> | bigint | number
    status?: EnumRunStatusWithAggregatesFilter<"CampaignStatus"> | $Enums.RunStatus
    error?: StringWithAggregatesFilter<"CampaignStatus"> | string
    details?: JsonWithAggregatesFilter<"CampaignStatus">
  }

  export type CampaignComputedValueWhereInput = {
    AND?: CampaignComputedValueWhereInput | CampaignComputedValueWhereInput[]
    OR?: CampaignComputedValueWhereInput[]
    NOT?: CampaignComputedValueWhereInput | CampaignComputedValueWhereInput[]
    campaignId?: StringFilter<"CampaignComputedValue"> | string
    averageBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    totalDistributedInUSD?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    forfeitingBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignComputedValueOrderByWithRelationInput = {
    campaignId?: SortOrder
    averageBoost?: SortOrderInput | SortOrder
    totalDistributedInUSD?: SortOrderInput | SortOrder
    forfeitingBoost?: SortOrderInput | SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    _relevance?: CampaignComputedValueOrderByRelevanceInput
  }

  export type CampaignComputedValueWhereUniqueInput = Prisma.AtLeast<{
    campaignId?: string
    AND?: CampaignComputedValueWhereInput | CampaignComputedValueWhereInput[]
    OR?: CampaignComputedValueWhereInput[]
    NOT?: CampaignComputedValueWhereInput | CampaignComputedValueWhereInput[]
    averageBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    totalDistributedInUSD?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    forfeitingBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "campaignId">

  export type CampaignComputedValueOrderByWithAggregationInput = {
    campaignId?: SortOrder
    averageBoost?: SortOrderInput | SortOrder
    totalDistributedInUSD?: SortOrderInput | SortOrder
    forfeitingBoost?: SortOrderInput | SortOrder
    _count?: CampaignComputedValueCountOrderByAggregateInput
    _avg?: CampaignComputedValueAvgOrderByAggregateInput
    _max?: CampaignComputedValueMaxOrderByAggregateInput
    _min?: CampaignComputedValueMinOrderByAggregateInput
    _sum?: CampaignComputedValueSumOrderByAggregateInput
  }

  export type CampaignComputedValueScalarWhereWithAggregatesInput = {
    AND?: CampaignComputedValueScalarWhereWithAggregatesInput | CampaignComputedValueScalarWhereWithAggregatesInput[]
    OR?: CampaignComputedValueScalarWhereWithAggregatesInput[]
    NOT?: CampaignComputedValueScalarWhereWithAggregatesInput | CampaignComputedValueScalarWhereWithAggregatesInput[]
    campaignId?: StringWithAggregatesFilter<"CampaignComputedValue"> | string
    averageBoost?: FloatNullableWithAggregatesFilter<"CampaignComputedValue"> | number | null
    totalDistributedInUSD?: FloatNullableWithAggregatesFilter<"CampaignComputedValue"> | number | null
    forfeitingBoost?: FloatNullableWithAggregatesFilter<"CampaignComputedValue"> | number | null
  }

  export type UserComputedValueWhereInput = {
    AND?: UserComputedValueWhereInput | UserComputedValueWhereInput[]
    OR?: UserComputedValueWhereInput[]
    NOT?: UserComputedValueWhereInput | UserComputedValueWhereInput[]
    id?: UuidFilter<"UserComputedValue"> | string
    campaignId?: StringFilter<"UserComputedValue"> | string
    address?: StringFilter<"UserComputedValue"> | string
    reason?: StringFilter<"UserComputedValue"> | string
    boost?: FloatNullableFilter<"UserComputedValue"> | number | null
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserComputedValueOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    address?: SortOrder
    reason?: SortOrder
    boost?: SortOrderInput | SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: UserComputedValueOrderByRelevanceInput
  }

  export type UserComputedValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_address_reason?: UserComputedValueCampaignIdAddressReasonCompoundUniqueInput
    AND?: UserComputedValueWhereInput | UserComputedValueWhereInput[]
    OR?: UserComputedValueWhereInput[]
    NOT?: UserComputedValueWhereInput | UserComputedValueWhereInput[]
    campaignId?: StringFilter<"UserComputedValue"> | string
    address?: StringFilter<"UserComputedValue"> | string
    reason?: StringFilter<"UserComputedValue"> | string
    boost?: FloatNullableFilter<"UserComputedValue"> | number | null
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "campaignId_address_reason">

  export type UserComputedValueOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    address?: SortOrder
    reason?: SortOrder
    boost?: SortOrderInput | SortOrder
    _count?: UserComputedValueCountOrderByAggregateInput
    _avg?: UserComputedValueAvgOrderByAggregateInput
    _max?: UserComputedValueMaxOrderByAggregateInput
    _min?: UserComputedValueMinOrderByAggregateInput
    _sum?: UserComputedValueSumOrderByAggregateInput
  }

  export type UserComputedValueScalarWhereWithAggregatesInput = {
    AND?: UserComputedValueScalarWhereWithAggregatesInput | UserComputedValueScalarWhereWithAggregatesInput[]
    OR?: UserComputedValueScalarWhereWithAggregatesInput[]
    NOT?: UserComputedValueScalarWhereWithAggregatesInput | UserComputedValueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserComputedValue"> | string
    campaignId?: StringWithAggregatesFilter<"UserComputedValue"> | string
    address?: StringWithAggregatesFilter<"UserComputedValue"> | string
    reason?: StringWithAggregatesFilter<"UserComputedValue"> | string
    boost?: FloatNullableWithAggregatesFilter<"UserComputedValue"> | number | null
  }

  export type ChainWhereInput = {
    AND?: ChainWhereInput | ChainWhereInput[]
    OR?: ChainWhereInput[]
    NOT?: ChainWhereInput | ChainWhereInput[]
    id?: IntFilter<"Chain"> | number
    name?: StringFilter<"Chain"> | string
    icon?: StringFilter<"Chain"> | string
    Explorer?: ExplorerListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Distribution?: CampaignListRelationFilter
    Token?: TokenListRelationFilter
    Opportunity?: OpportunityListRelationFilter
    MerklRoot?: MerklRootListRelationFilter
    Blacklist?: BlacklistListRelationFilter
    Dump?: DumpListRelationFilter
  }

  export type ChainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    Explorer?: ExplorerOrderByRelationAggregateInput
    Campaigns?: CampaignOrderByRelationAggregateInput
    Distribution?: CampaignOrderByRelationAggregateInput
    Token?: TokenOrderByRelationAggregateInput
    Opportunity?: OpportunityOrderByRelationAggregateInput
    MerklRoot?: MerklRootOrderByRelationAggregateInput
    Blacklist?: BlacklistOrderByRelationAggregateInput
    Dump?: DumpOrderByRelationAggregateInput
    _relevance?: ChainOrderByRelevanceInput
  }

  export type ChainWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChainWhereInput | ChainWhereInput[]
    OR?: ChainWhereInput[]
    NOT?: ChainWhereInput | ChainWhereInput[]
    name?: StringFilter<"Chain"> | string
    icon?: StringFilter<"Chain"> | string
    Explorer?: ExplorerListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Distribution?: CampaignListRelationFilter
    Token?: TokenListRelationFilter
    Opportunity?: OpportunityListRelationFilter
    MerklRoot?: MerklRootListRelationFilter
    Blacklist?: BlacklistListRelationFilter
    Dump?: DumpListRelationFilter
  }, "id">

  export type ChainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    _count?: ChainCountOrderByAggregateInput
    _avg?: ChainAvgOrderByAggregateInput
    _max?: ChainMaxOrderByAggregateInput
    _min?: ChainMinOrderByAggregateInput
    _sum?: ChainSumOrderByAggregateInput
  }

  export type ChainScalarWhereWithAggregatesInput = {
    AND?: ChainScalarWhereWithAggregatesInput | ChainScalarWhereWithAggregatesInput[]
    OR?: ChainScalarWhereWithAggregatesInput[]
    NOT?: ChainScalarWhereWithAggregatesInput | ChainScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chain"> | number
    name?: StringWithAggregatesFilter<"Chain"> | string
    icon?: StringWithAggregatesFilter<"Chain"> | string
  }

  export type ExplorerWhereInput = {
    AND?: ExplorerWhereInput | ExplorerWhereInput[]
    OR?: ExplorerWhereInput[]
    NOT?: ExplorerWhereInput | ExplorerWhereInput[]
    id?: StringFilter<"Explorer"> | string
    type?: EnumExplorerTypeFilter<"Explorer"> | $Enums.ExplorerType
    url?: StringFilter<"Explorer"> | string
    chainId?: IntFilter<"Explorer"> | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
  }

  export type ExplorerOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    chainId?: SortOrder
    Chain?: ChainOrderByWithRelationInput
    _relevance?: ExplorerOrderByRelevanceInput
  }

  export type ExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_chainId?: ExplorerTypeChainIdCompoundUniqueInput
    AND?: ExplorerWhereInput | ExplorerWhereInput[]
    OR?: ExplorerWhereInput[]
    NOT?: ExplorerWhereInput | ExplorerWhereInput[]
    type?: EnumExplorerTypeFilter<"Explorer"> | $Enums.ExplorerType
    url?: StringFilter<"Explorer"> | string
    chainId?: IntFilter<"Explorer"> | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
  }, "id" | "type_chainId">

  export type ExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    chainId?: SortOrder
    _count?: ExplorerCountOrderByAggregateInput
    _avg?: ExplorerAvgOrderByAggregateInput
    _max?: ExplorerMaxOrderByAggregateInput
    _min?: ExplorerMinOrderByAggregateInput
    _sum?: ExplorerSumOrderByAggregateInput
  }

  export type ExplorerScalarWhereWithAggregatesInput = {
    AND?: ExplorerScalarWhereWithAggregatesInput | ExplorerScalarWhereWithAggregatesInput[]
    OR?: ExplorerScalarWhereWithAggregatesInput[]
    NOT?: ExplorerScalarWhereWithAggregatesInput | ExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Explorer"> | string
    type?: EnumExplorerTypeWithAggregatesFilter<"Explorer"> | $Enums.ExplorerType
    url?: StringWithAggregatesFilter<"Explorer"> | string
    chainId?: IntWithAggregatesFilter<"Explorer"> | number
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    chainId?: IntFilter<"Opportunity"> | number
    type?: StringFilter<"Opportunity"> | string
    identifier?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    howToSteps?: StringNullableListFilter<"Opportunity">
    depositUrl?: StringNullableFilter<"Opportunity"> | string | null
    explorerAddress?: StringNullableFilter<"Opportunity"> | string | null
    status?: EnumStatusFilter<"Opportunity"> | $Enums.Status
    action?: EnumOpportunityActionFilter<"Opportunity"> | $Enums.OpportunityAction
    mainProtocolId?: StringNullableFilter<"Opportunity"> | string | null
    tvl?: FloatFilter<"Opportunity"> | number
    apr?: FloatFilter<"Opportunity"> | number
    dailyRewards?: FloatFilter<"Opportunity"> | number
    tags?: StringNullableListFilter<"Opportunity">
    lastCampaignCreatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    manualOverrides?: EnumOpportunityManualOverrideNullableListFilter<"Opportunity">
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Tokens?: TokenListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Protocols?: ProtocolListRelationFilter
    MainProtocol?: XOR<ProtocolNullableScalarRelationFilter, ProtocolWhereInput> | null
    TvlRecords?: TVLRecordListRelationFilter
    AprRecords?: AprRecordListRelationFilter
    DailyRewardsRecords?: DailyRewardsRecordListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    description?: SortOrder
    howToSteps?: SortOrder
    depositUrl?: SortOrderInput | SortOrder
    explorerAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    action?: SortOrder
    mainProtocolId?: SortOrderInput | SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
    tags?: SortOrder
    lastCampaignCreatedAt?: SortOrder
    manualOverrides?: SortOrder
    Chain?: ChainOrderByWithRelationInput
    Tokens?: TokenOrderByRelationAggregateInput
    Campaigns?: CampaignOrderByRelationAggregateInput
    Protocols?: ProtocolOrderByRelationAggregateInput
    MainProtocol?: ProtocolOrderByWithRelationInput
    TvlRecords?: TVLRecordOrderByRelationAggregateInput
    AprRecords?: AprRecordOrderByRelationAggregateInput
    DailyRewardsRecords?: DailyRewardsRecordOrderByRelationAggregateInput
    _relevance?: OpportunityOrderByRelevanceInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId_type_identifier?: OpportunityChainIdTypeIdentifierCompoundUniqueInput
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    chainId?: IntFilter<"Opportunity"> | number
    type?: StringFilter<"Opportunity"> | string
    identifier?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    howToSteps?: StringNullableListFilter<"Opportunity">
    depositUrl?: StringNullableFilter<"Opportunity"> | string | null
    explorerAddress?: StringNullableFilter<"Opportunity"> | string | null
    status?: EnumStatusFilter<"Opportunity"> | $Enums.Status
    action?: EnumOpportunityActionFilter<"Opportunity"> | $Enums.OpportunityAction
    mainProtocolId?: StringNullableFilter<"Opportunity"> | string | null
    tvl?: FloatFilter<"Opportunity"> | number
    apr?: FloatFilter<"Opportunity"> | number
    dailyRewards?: FloatFilter<"Opportunity"> | number
    tags?: StringNullableListFilter<"Opportunity">
    lastCampaignCreatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    manualOverrides?: EnumOpportunityManualOverrideNullableListFilter<"Opportunity">
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Tokens?: TokenListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Protocols?: ProtocolListRelationFilter
    MainProtocol?: XOR<ProtocolNullableScalarRelationFilter, ProtocolWhereInput> | null
    TvlRecords?: TVLRecordListRelationFilter
    AprRecords?: AprRecordListRelationFilter
    DailyRewardsRecords?: DailyRewardsRecordListRelationFilter
  }, "id" | "chainId_type_identifier">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    description?: SortOrder
    howToSteps?: SortOrder
    depositUrl?: SortOrderInput | SortOrder
    explorerAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    action?: SortOrder
    mainProtocolId?: SortOrderInput | SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
    tags?: SortOrder
    lastCampaignCreatedAt?: SortOrder
    manualOverrides?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    chainId?: IntWithAggregatesFilter<"Opportunity"> | number
    type?: StringWithAggregatesFilter<"Opportunity"> | string
    identifier?: StringWithAggregatesFilter<"Opportunity"> | string
    name?: StringWithAggregatesFilter<"Opportunity"> | string
    description?: StringWithAggregatesFilter<"Opportunity"> | string
    howToSteps?: StringNullableListFilter<"Opportunity">
    depositUrl?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    explorerAddress?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Opportunity"> | $Enums.Status
    action?: EnumOpportunityActionWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityAction
    mainProtocolId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    tvl?: FloatWithAggregatesFilter<"Opportunity"> | number
    apr?: FloatWithAggregatesFilter<"Opportunity"> | number
    dailyRewards?: FloatWithAggregatesFilter<"Opportunity"> | number
    tags?: StringNullableListFilter<"Opportunity">
    lastCampaignCreatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    manualOverrides?: EnumOpportunityManualOverrideNullableListFilter<"Opportunity">
  }

  export type ProtocolWhereInput = {
    AND?: ProtocolWhereInput | ProtocolWhereInput[]
    OR?: ProtocolWhereInput[]
    NOT?: ProtocolWhereInput | ProtocolWhereInput[]
    id?: StringFilter<"Protocol"> | string
    tags?: StringNullableListFilter<"Protocol">
    name?: StringFilter<"Protocol"> | string
    description?: StringFilter<"Protocol"> | string
    url?: StringFilter<"Protocol"> | string
    icon?: StringFilter<"Protocol"> | string
    MainOpportunities?: OpportunityListRelationFilter
    Opportunities?: OpportunityListRelationFilter
    RewardBreakdown?: RewardBreakdownListRelationFilter
  }

  export type ProtocolOrderByWithRelationInput = {
    id?: SortOrder
    tags?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    MainOpportunities?: OpportunityOrderByRelationAggregateInput
    Opportunities?: OpportunityOrderByRelationAggregateInput
    RewardBreakdown?: RewardBreakdownOrderByRelationAggregateInput
    _relevance?: ProtocolOrderByRelevanceInput
  }

  export type ProtocolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProtocolWhereInput | ProtocolWhereInput[]
    OR?: ProtocolWhereInput[]
    NOT?: ProtocolWhereInput | ProtocolWhereInput[]
    tags?: StringNullableListFilter<"Protocol">
    name?: StringFilter<"Protocol"> | string
    description?: StringFilter<"Protocol"> | string
    url?: StringFilter<"Protocol"> | string
    icon?: StringFilter<"Protocol"> | string
    MainOpportunities?: OpportunityListRelationFilter
    Opportunities?: OpportunityListRelationFilter
    RewardBreakdown?: RewardBreakdownListRelationFilter
  }, "id">

  export type ProtocolOrderByWithAggregationInput = {
    id?: SortOrder
    tags?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    _count?: ProtocolCountOrderByAggregateInput
    _max?: ProtocolMaxOrderByAggregateInput
    _min?: ProtocolMinOrderByAggregateInput
  }

  export type ProtocolScalarWhereWithAggregatesInput = {
    AND?: ProtocolScalarWhereWithAggregatesInput | ProtocolScalarWhereWithAggregatesInput[]
    OR?: ProtocolScalarWhereWithAggregatesInput[]
    NOT?: ProtocolScalarWhereWithAggregatesInput | ProtocolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Protocol"> | string
    tags?: StringNullableListFilter<"Protocol">
    name?: StringWithAggregatesFilter<"Protocol"> | string
    description?: StringWithAggregatesFilter<"Protocol"> | string
    url?: StringWithAggregatesFilter<"Protocol"> | string
    icon?: StringWithAggregatesFilter<"Protocol"> | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringNullableFilter<"Token"> | string | null
    chainId?: IntFilter<"Token"> | number
    address?: StringFilter<"Token"> | string
    decimals?: IntFilter<"Token"> | number
    symbol?: StringFilter<"Token"> | string
    displaySymbol?: StringFilter<"Token"> | string
    icon?: StringFilter<"Token"> | string
    verified?: BoolFilter<"Token"> | boolean
    isTest?: BoolFilter<"Token"> | boolean
    isPoint?: BoolFilter<"Token"> | boolean
    isPreTGE?: BoolFilter<"Token"> | boolean
    isNative?: BoolFilter<"Token"> | boolean
    price?: FloatNullableFilter<"Token"> | number | null
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Opportunity?: OpportunityListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Reward?: RewardListRelationFilter
    DumpTo?: DumpListRelationFilter
    DumpFrom?: DumpListRelationFilter
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    chainId?: SortOrder
    address?: SortOrder
    decimals?: SortOrder
    symbol?: SortOrder
    displaySymbol?: SortOrder
    icon?: SortOrder
    verified?: SortOrder
    isTest?: SortOrder
    isPoint?: SortOrder
    isPreTGE?: SortOrder
    isNative?: SortOrder
    price?: SortOrderInput | SortOrder
    Chain?: ChainOrderByWithRelationInput
    Opportunity?: OpportunityOrderByRelationAggregateInput
    Campaigns?: CampaignOrderByRelationAggregateInput
    Reward?: RewardOrderByRelationAggregateInput
    DumpTo?: DumpOrderByRelationAggregateInput
    DumpFrom?: DumpOrderByRelationAggregateInput
    _relevance?: TokenOrderByRelevanceInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId_address?: TokenChainIdAddressCompoundUniqueInput
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    name?: StringNullableFilter<"Token"> | string | null
    chainId?: IntFilter<"Token"> | number
    address?: StringFilter<"Token"> | string
    decimals?: IntFilter<"Token"> | number
    symbol?: StringFilter<"Token"> | string
    displaySymbol?: StringFilter<"Token"> | string
    icon?: StringFilter<"Token"> | string
    verified?: BoolFilter<"Token"> | boolean
    isTest?: BoolFilter<"Token"> | boolean
    isPoint?: BoolFilter<"Token"> | boolean
    isPreTGE?: BoolFilter<"Token"> | boolean
    isNative?: BoolFilter<"Token"> | boolean
    price?: FloatNullableFilter<"Token"> | number | null
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Opportunity?: OpportunityListRelationFilter
    Campaigns?: CampaignListRelationFilter
    Reward?: RewardListRelationFilter
    DumpTo?: DumpListRelationFilter
    DumpFrom?: DumpListRelationFilter
  }, "id" | "chainId_address">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    chainId?: SortOrder
    address?: SortOrder
    decimals?: SortOrder
    symbol?: SortOrder
    displaySymbol?: SortOrder
    icon?: SortOrder
    verified?: SortOrder
    isTest?: SortOrder
    isPoint?: SortOrder
    isPreTGE?: SortOrder
    isNative?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    name?: StringNullableWithAggregatesFilter<"Token"> | string | null
    chainId?: IntWithAggregatesFilter<"Token"> | number
    address?: StringWithAggregatesFilter<"Token"> | string
    decimals?: IntWithAggregatesFilter<"Token"> | number
    symbol?: StringWithAggregatesFilter<"Token"> | string
    displaySymbol?: StringWithAggregatesFilter<"Token"> | string
    icon?: StringWithAggregatesFilter<"Token"> | string
    verified?: BoolWithAggregatesFilter<"Token"> | boolean
    isTest?: BoolWithAggregatesFilter<"Token"> | boolean
    isPoint?: BoolWithAggregatesFilter<"Token"> | boolean
    isPreTGE?: BoolWithAggregatesFilter<"Token"> | boolean
    isNative?: BoolWithAggregatesFilter<"Token"> | boolean
    price?: FloatNullableWithAggregatesFilter<"Token"> | number | null
  }

  export type AprRecordWhereInput = {
    AND?: AprRecordWhereInput | AprRecordWhereInput[]
    OR?: AprRecordWhereInput[]
    NOT?: AprRecordWhereInput | AprRecordWhereInput[]
    id?: StringFilter<"AprRecord"> | string
    timestamp?: BigIntFilter<"AprRecord"> | bigint | number
    cumulated?: FloatFilter<"AprRecord"> | number
    opportunityId?: StringFilter<"AprRecord"> | string
    AprBreakdown?: AprBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }

  export type AprRecordOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    cumulated?: SortOrder
    opportunityId?: SortOrder
    AprBreakdown?: AprBreakdownOrderByRelationAggregateInput
    Opportunity?: OpportunityOrderByWithRelationInput
    _relevance?: AprRecordOrderByRelevanceInput
  }

  export type AprRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    opportunityId_timestamp?: AprRecordOpportunityIdTimestampCompoundUniqueInput
    AND?: AprRecordWhereInput | AprRecordWhereInput[]
    OR?: AprRecordWhereInput[]
    NOT?: AprRecordWhereInput | AprRecordWhereInput[]
    timestamp?: BigIntFilter<"AprRecord"> | bigint | number
    cumulated?: FloatFilter<"AprRecord"> | number
    opportunityId?: StringFilter<"AprRecord"> | string
    AprBreakdown?: AprBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }, "id" | "opportunityId_timestamp">

  export type AprRecordOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    cumulated?: SortOrder
    opportunityId?: SortOrder
    _count?: AprRecordCountOrderByAggregateInput
    _avg?: AprRecordAvgOrderByAggregateInput
    _max?: AprRecordMaxOrderByAggregateInput
    _min?: AprRecordMinOrderByAggregateInput
    _sum?: AprRecordSumOrderByAggregateInput
  }

  export type AprRecordScalarWhereWithAggregatesInput = {
    AND?: AprRecordScalarWhereWithAggregatesInput | AprRecordScalarWhereWithAggregatesInput[]
    OR?: AprRecordScalarWhereWithAggregatesInput[]
    NOT?: AprRecordScalarWhereWithAggregatesInput | AprRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AprRecord"> | string
    timestamp?: BigIntWithAggregatesFilter<"AprRecord"> | bigint | number
    cumulated?: FloatWithAggregatesFilter<"AprRecord"> | number
    opportunityId?: StringWithAggregatesFilter<"AprRecord"> | string
  }

  export type AprBreakdownWhereInput = {
    AND?: AprBreakdownWhereInput | AprBreakdownWhereInput[]
    OR?: AprBreakdownWhereInput[]
    NOT?: AprBreakdownWhereInput | AprBreakdownWhereInput[]
    id?: UuidFilter<"AprBreakdown"> | string
    identifier?: StringFilter<"AprBreakdown"> | string
    type?: EnumAprTypeFilter<"AprBreakdown"> | $Enums.AprType
    value?: FloatFilter<"AprBreakdown"> | number
    aprRecordId?: StringFilter<"AprBreakdown"> | string
    AprRecord?: XOR<AprRecordScalarRelationFilter, AprRecordWhereInput>
  }

  export type AprBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    aprRecordId?: SortOrder
    AprRecord?: AprRecordOrderByWithRelationInput
    _relevance?: AprBreakdownOrderByRelevanceInput
  }

  export type AprBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AprBreakdownWhereInput | AprBreakdownWhereInput[]
    OR?: AprBreakdownWhereInput[]
    NOT?: AprBreakdownWhereInput | AprBreakdownWhereInput[]
    identifier?: StringFilter<"AprBreakdown"> | string
    type?: EnumAprTypeFilter<"AprBreakdown"> | $Enums.AprType
    value?: FloatFilter<"AprBreakdown"> | number
    aprRecordId?: StringFilter<"AprBreakdown"> | string
    AprRecord?: XOR<AprRecordScalarRelationFilter, AprRecordWhereInput>
  }, "id">

  export type AprBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    aprRecordId?: SortOrder
    _count?: AprBreakdownCountOrderByAggregateInput
    _avg?: AprBreakdownAvgOrderByAggregateInput
    _max?: AprBreakdownMaxOrderByAggregateInput
    _min?: AprBreakdownMinOrderByAggregateInput
    _sum?: AprBreakdownSumOrderByAggregateInput
  }

  export type AprBreakdownScalarWhereWithAggregatesInput = {
    AND?: AprBreakdownScalarWhereWithAggregatesInput | AprBreakdownScalarWhereWithAggregatesInput[]
    OR?: AprBreakdownScalarWhereWithAggregatesInput[]
    NOT?: AprBreakdownScalarWhereWithAggregatesInput | AprBreakdownScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AprBreakdown"> | string
    identifier?: StringWithAggregatesFilter<"AprBreakdown"> | string
    type?: EnumAprTypeWithAggregatesFilter<"AprBreakdown"> | $Enums.AprType
    value?: FloatWithAggregatesFilter<"AprBreakdown"> | number
    aprRecordId?: StringWithAggregatesFilter<"AprBreakdown"> | string
  }

  export type TVLRecordWhereInput = {
    AND?: TVLRecordWhereInput | TVLRecordWhereInput[]
    OR?: TVLRecordWhereInput[]
    NOT?: TVLRecordWhereInput | TVLRecordWhereInput[]
    id?: StringFilter<"TVLRecord"> | string
    timestamp?: BigIntFilter<"TVLRecord"> | bigint | number
    total?: FloatFilter<"TVLRecord"> | number
    opportunityId?: StringFilter<"TVLRecord"> | string
    TvlBreakdown?: TVLBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }

  export type TVLRecordOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
    TvlBreakdown?: TVLBreakdownOrderByRelationAggregateInput
    Opportunity?: OpportunityOrderByWithRelationInput
    _relevance?: TVLRecordOrderByRelevanceInput
  }

  export type TVLRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    opportunityId_timestamp?: TVLRecordOpportunityIdTimestampCompoundUniqueInput
    AND?: TVLRecordWhereInput | TVLRecordWhereInput[]
    OR?: TVLRecordWhereInput[]
    NOT?: TVLRecordWhereInput | TVLRecordWhereInput[]
    timestamp?: BigIntFilter<"TVLRecord"> | bigint | number
    total?: FloatFilter<"TVLRecord"> | number
    opportunityId?: StringFilter<"TVLRecord"> | string
    TvlBreakdown?: TVLBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }, "id" | "opportunityId_timestamp">

  export type TVLRecordOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
    _count?: TVLRecordCountOrderByAggregateInput
    _avg?: TVLRecordAvgOrderByAggregateInput
    _max?: TVLRecordMaxOrderByAggregateInput
    _min?: TVLRecordMinOrderByAggregateInput
    _sum?: TVLRecordSumOrderByAggregateInput
  }

  export type TVLRecordScalarWhereWithAggregatesInput = {
    AND?: TVLRecordScalarWhereWithAggregatesInput | TVLRecordScalarWhereWithAggregatesInput[]
    OR?: TVLRecordScalarWhereWithAggregatesInput[]
    NOT?: TVLRecordScalarWhereWithAggregatesInput | TVLRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TVLRecord"> | string
    timestamp?: BigIntWithAggregatesFilter<"TVLRecord"> | bigint | number
    total?: FloatWithAggregatesFilter<"TVLRecord"> | number
    opportunityId?: StringWithAggregatesFilter<"TVLRecord"> | string
  }

  export type TVLBreakdownWhereInput = {
    AND?: TVLBreakdownWhereInput | TVLBreakdownWhereInput[]
    OR?: TVLBreakdownWhereInput[]
    NOT?: TVLBreakdownWhereInput | TVLBreakdownWhereInput[]
    id?: UuidFilter<"TVLBreakdown"> | string
    identifier?: StringFilter<"TVLBreakdown"> | string
    type?: EnumTvlTypeFilter<"TVLBreakdown"> | $Enums.TvlType
    value?: FloatFilter<"TVLBreakdown"> | number
    tvlRecordId?: StringFilter<"TVLBreakdown"> | string
    TvlRecord?: XOR<TVLRecordScalarRelationFilter, TVLRecordWhereInput>
  }

  export type TVLBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    tvlRecordId?: SortOrder
    TvlRecord?: TVLRecordOrderByWithRelationInput
    _relevance?: TVLBreakdownOrderByRelevanceInput
  }

  export type TVLBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TVLBreakdownWhereInput | TVLBreakdownWhereInput[]
    OR?: TVLBreakdownWhereInput[]
    NOT?: TVLBreakdownWhereInput | TVLBreakdownWhereInput[]
    identifier?: StringFilter<"TVLBreakdown"> | string
    type?: EnumTvlTypeFilter<"TVLBreakdown"> | $Enums.TvlType
    value?: FloatFilter<"TVLBreakdown"> | number
    tvlRecordId?: StringFilter<"TVLBreakdown"> | string
    TvlRecord?: XOR<TVLRecordScalarRelationFilter, TVLRecordWhereInput>
  }, "id">

  export type TVLBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    tvlRecordId?: SortOrder
    _count?: TVLBreakdownCountOrderByAggregateInput
    _avg?: TVLBreakdownAvgOrderByAggregateInput
    _max?: TVLBreakdownMaxOrderByAggregateInput
    _min?: TVLBreakdownMinOrderByAggregateInput
    _sum?: TVLBreakdownSumOrderByAggregateInput
  }

  export type TVLBreakdownScalarWhereWithAggregatesInput = {
    AND?: TVLBreakdownScalarWhereWithAggregatesInput | TVLBreakdownScalarWhereWithAggregatesInput[]
    OR?: TVLBreakdownScalarWhereWithAggregatesInput[]
    NOT?: TVLBreakdownScalarWhereWithAggregatesInput | TVLBreakdownScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TVLBreakdown"> | string
    identifier?: StringWithAggregatesFilter<"TVLBreakdown"> | string
    type?: EnumTvlTypeWithAggregatesFilter<"TVLBreakdown"> | $Enums.TvlType
    value?: FloatWithAggregatesFilter<"TVLBreakdown"> | number
    tvlRecordId?: StringWithAggregatesFilter<"TVLBreakdown"> | string
  }

  export type DailyRewardsRecordWhereInput = {
    AND?: DailyRewardsRecordWhereInput | DailyRewardsRecordWhereInput[]
    OR?: DailyRewardsRecordWhereInput[]
    NOT?: DailyRewardsRecordWhereInput | DailyRewardsRecordWhereInput[]
    id?: StringFilter<"DailyRewardsRecord"> | string
    timestamp?: BigIntFilter<"DailyRewardsRecord"> | bigint | number
    total?: FloatFilter<"DailyRewardsRecord"> | number
    opportunityId?: StringFilter<"DailyRewardsRecord"> | string
    DailyRewardsBreakdown?: DailyRewardsBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }

  export type DailyRewardsRecordOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
    DailyRewardsBreakdown?: DailyRewardsBreakdownOrderByRelationAggregateInput
    Opportunity?: OpportunityOrderByWithRelationInput
    _relevance?: DailyRewardsRecordOrderByRelevanceInput
  }

  export type DailyRewardsRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    opportunityId_timestamp?: DailyRewardsRecordOpportunityIdTimestampCompoundUniqueInput
    AND?: DailyRewardsRecordWhereInput | DailyRewardsRecordWhereInput[]
    OR?: DailyRewardsRecordWhereInput[]
    NOT?: DailyRewardsRecordWhereInput | DailyRewardsRecordWhereInput[]
    timestamp?: BigIntFilter<"DailyRewardsRecord"> | bigint | number
    total?: FloatFilter<"DailyRewardsRecord"> | number
    opportunityId?: StringFilter<"DailyRewardsRecord"> | string
    DailyRewardsBreakdown?: DailyRewardsBreakdownListRelationFilter
    Opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }, "id" | "opportunityId_timestamp">

  export type DailyRewardsRecordOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
    _count?: DailyRewardsRecordCountOrderByAggregateInput
    _avg?: DailyRewardsRecordAvgOrderByAggregateInput
    _max?: DailyRewardsRecordMaxOrderByAggregateInput
    _min?: DailyRewardsRecordMinOrderByAggregateInput
    _sum?: DailyRewardsRecordSumOrderByAggregateInput
  }

  export type DailyRewardsRecordScalarWhereWithAggregatesInput = {
    AND?: DailyRewardsRecordScalarWhereWithAggregatesInput | DailyRewardsRecordScalarWhereWithAggregatesInput[]
    OR?: DailyRewardsRecordScalarWhereWithAggregatesInput[]
    NOT?: DailyRewardsRecordScalarWhereWithAggregatesInput | DailyRewardsRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyRewardsRecord"> | string
    timestamp?: BigIntWithAggregatesFilter<"DailyRewardsRecord"> | bigint | number
    total?: FloatWithAggregatesFilter<"DailyRewardsRecord"> | number
    opportunityId?: StringWithAggregatesFilter<"DailyRewardsRecord"> | string
  }

  export type DailyRewardsBreakdownWhereInput = {
    AND?: DailyRewardsBreakdownWhereInput | DailyRewardsBreakdownWhereInput[]
    OR?: DailyRewardsBreakdownWhereInput[]
    NOT?: DailyRewardsBreakdownWhereInput | DailyRewardsBreakdownWhereInput[]
    id?: UuidFilter<"DailyRewardsBreakdown"> | string
    value?: FloatFilter<"DailyRewardsBreakdown"> | number
    campaignId?: StringFilter<"DailyRewardsBreakdown"> | string
    dailyRewardsRecordId?: StringFilter<"DailyRewardsBreakdown"> | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    DailyRewardsRecord?: XOR<DailyRewardsRecordScalarRelationFilter, DailyRewardsRecordWhereInput>
  }

  export type DailyRewardsBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    campaignId?: SortOrder
    dailyRewardsRecordId?: SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    DailyRewardsRecord?: DailyRewardsRecordOrderByWithRelationInput
    _relevance?: DailyRewardsBreakdownOrderByRelevanceInput
  }

  export type DailyRewardsBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyRewardsBreakdownWhereInput | DailyRewardsBreakdownWhereInput[]
    OR?: DailyRewardsBreakdownWhereInput[]
    NOT?: DailyRewardsBreakdownWhereInput | DailyRewardsBreakdownWhereInput[]
    value?: FloatFilter<"DailyRewardsBreakdown"> | number
    campaignId?: StringFilter<"DailyRewardsBreakdown"> | string
    dailyRewardsRecordId?: StringFilter<"DailyRewardsBreakdown"> | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    DailyRewardsRecord?: XOR<DailyRewardsRecordScalarRelationFilter, DailyRewardsRecordWhereInput>
  }, "id">

  export type DailyRewardsBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    campaignId?: SortOrder
    dailyRewardsRecordId?: SortOrder
    _count?: DailyRewardsBreakdownCountOrderByAggregateInput
    _avg?: DailyRewardsBreakdownAvgOrderByAggregateInput
    _max?: DailyRewardsBreakdownMaxOrderByAggregateInput
    _min?: DailyRewardsBreakdownMinOrderByAggregateInput
    _sum?: DailyRewardsBreakdownSumOrderByAggregateInput
  }

  export type DailyRewardsBreakdownScalarWhereWithAggregatesInput = {
    AND?: DailyRewardsBreakdownScalarWhereWithAggregatesInput | DailyRewardsBreakdownScalarWhereWithAggregatesInput[]
    OR?: DailyRewardsBreakdownScalarWhereWithAggregatesInput[]
    NOT?: DailyRewardsBreakdownScalarWhereWithAggregatesInput | DailyRewardsBreakdownScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DailyRewardsBreakdown"> | string
    value?: FloatWithAggregatesFilter<"DailyRewardsBreakdown"> | number
    campaignId?: StringWithAggregatesFilter<"DailyRewardsBreakdown"> | string
    dailyRewardsRecordId?: StringWithAggregatesFilter<"DailyRewardsBreakdown"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    address?: StringFilter<"User"> | string
    tags?: StringNullableListFilter<"User">
    creatorId?: StringNullableFilter<"User"> | string | null
    Rewards?: RewardListRelationFilter
    Blacklist?: BlacklistListRelationFilter
    CampaignsCreated?: CampaignListRelationFilter
    UserComputedValue?: UserComputedValueListRelationFilter
    Creator?: XOR<CreatorNullableScalarRelationFilter, CreatorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    address?: SortOrder
    tags?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    Rewards?: RewardOrderByRelationAggregateInput
    Blacklist?: BlacklistOrderByRelationAggregateInput
    CampaignsCreated?: CampaignOrderByRelationAggregateInput
    UserComputedValue?: UserComputedValueOrderByRelationAggregateInput
    Creator?: CreatorOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    address?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tags?: StringNullableListFilter<"User">
    creatorId?: StringNullableFilter<"User"> | string | null
    Rewards?: RewardListRelationFilter
    Blacklist?: BlacklistListRelationFilter
    CampaignsCreated?: CampaignListRelationFilter
    UserComputedValue?: UserComputedValueListRelationFilter
    Creator?: XOR<CreatorNullableScalarRelationFilter, CreatorWhereInput> | null
  }, "address">

  export type UserOrderByWithAggregationInput = {
    address?: SortOrder
    tags?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    address?: StringWithAggregatesFilter<"User"> | string
    tags?: StringNullableListFilter<"User">
    creatorId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type CreatorWhereInput = {
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    id?: StringFilter<"Creator"> | string
    icon?: StringNullableFilter<"Creator"> | string | null
    name?: StringFilter<"Creator"> | string
    rebateFee?: IntFilter<"Creator"> | number
    Users?: UserListRelationFilter
  }

  export type CreatorOrderByWithRelationInput = {
    id?: SortOrder
    icon?: SortOrderInput | SortOrder
    name?: SortOrder
    rebateFee?: SortOrder
    Users?: UserOrderByRelationAggregateInput
    _relevance?: CreatorOrderByRelevanceInput
  }

  export type CreatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatorWhereInput | CreatorWhereInput[]
    OR?: CreatorWhereInput[]
    NOT?: CreatorWhereInput | CreatorWhereInput[]
    icon?: StringNullableFilter<"Creator"> | string | null
    name?: StringFilter<"Creator"> | string
    rebateFee?: IntFilter<"Creator"> | number
    Users?: UserListRelationFilter
  }, "id">

  export type CreatorOrderByWithAggregationInput = {
    id?: SortOrder
    icon?: SortOrderInput | SortOrder
    name?: SortOrder
    rebateFee?: SortOrder
    _count?: CreatorCountOrderByAggregateInput
    _avg?: CreatorAvgOrderByAggregateInput
    _max?: CreatorMaxOrderByAggregateInput
    _min?: CreatorMinOrderByAggregateInput
    _sum?: CreatorSumOrderByAggregateInput
  }

  export type CreatorScalarWhereWithAggregatesInput = {
    AND?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    OR?: CreatorScalarWhereWithAggregatesInput[]
    NOT?: CreatorScalarWhereWithAggregatesInput | CreatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creator"> | string
    icon?: StringNullableWithAggregatesFilter<"Creator"> | string | null
    name?: StringWithAggregatesFilter<"Creator"> | string
    rebateFee?: IntWithAggregatesFilter<"Creator"> | number
  }

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    id?: StringFilter<"Reward"> | string
    root?: StringFilter<"Reward"> | string
    recipient?: StringFilter<"Reward"> | string
    rewardTokenId?: StringFilter<"Reward"> | string
    amount?: StringFilter<"Reward"> | string
    claimed?: StringFilter<"Reward"> | string
    pending?: StringFilter<"Reward"> | string
    proofs?: StringNullableListFilter<"Reward">
    MerklRoot?: XOR<MerklRootScalarRelationFilter, MerklRootWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    RewardToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    Breakdown?: RewardBreakdownListRelationFilter
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    root?: SortOrder
    recipient?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    proofs?: SortOrder
    MerklRoot?: MerklRootOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    RewardToken?: TokenOrderByWithRelationInput
    Breakdown?: RewardBreakdownOrderByRelationAggregateInput
    _relevance?: RewardOrderByRelevanceInput
  }

  export type RewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    root_recipient_rewardTokenId?: RewardRootRecipientRewardTokenIdCompoundUniqueInput
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    root?: StringFilter<"Reward"> | string
    recipient?: StringFilter<"Reward"> | string
    rewardTokenId?: StringFilter<"Reward"> | string
    amount?: StringFilter<"Reward"> | string
    claimed?: StringFilter<"Reward"> | string
    pending?: StringFilter<"Reward"> | string
    proofs?: StringNullableListFilter<"Reward">
    MerklRoot?: XOR<MerklRootScalarRelationFilter, MerklRootWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    RewardToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    Breakdown?: RewardBreakdownListRelationFilter
  }, "id" | "root_recipient_rewardTokenId">

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    root?: SortOrder
    recipient?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    proofs?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    OR?: RewardScalarWhereWithAggregatesInput[]
    NOT?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reward"> | string
    root?: StringWithAggregatesFilter<"Reward"> | string
    recipient?: StringWithAggregatesFilter<"Reward"> | string
    rewardTokenId?: StringWithAggregatesFilter<"Reward"> | string
    amount?: StringWithAggregatesFilter<"Reward"> | string
    claimed?: StringWithAggregatesFilter<"Reward"> | string
    pending?: StringWithAggregatesFilter<"Reward"> | string
    proofs?: StringNullableListFilter<"Reward">
  }

  export type RewardBreakdownWhereInput = {
    AND?: RewardBreakdownWhereInput | RewardBreakdownWhereInput[]
    OR?: RewardBreakdownWhereInput[]
    NOT?: RewardBreakdownWhereInput | RewardBreakdownWhereInput[]
    id?: UuidFilter<"RewardBreakdown"> | string
    protocolId?: StringNullableFilter<"RewardBreakdown"> | string | null
    reason?: StringFilter<"RewardBreakdown"> | string
    amount?: StringFilter<"RewardBreakdown"> | string
    claimed?: StringFilter<"RewardBreakdown"> | string
    pending?: StringFilter<"RewardBreakdown"> | string
    rewardId?: StringFilter<"RewardBreakdown"> | string
    campaignId?: StringFilter<"RewardBreakdown"> | string
    subCampaignId?: StringNullableFilter<"RewardBreakdown"> | string | null
    Protocol?: XOR<ProtocolNullableScalarRelationFilter, ProtocolWhereInput> | null
    Reward?: XOR<RewardScalarRelationFilter, RewardWhereInput>
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    SubCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }

  export type RewardBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    protocolId?: SortOrderInput | SortOrder
    reason?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    rewardId?: SortOrder
    campaignId?: SortOrder
    subCampaignId?: SortOrderInput | SortOrder
    Protocol?: ProtocolOrderByWithRelationInput
    Reward?: RewardOrderByWithRelationInput
    Campaign?: CampaignOrderByWithRelationInput
    SubCampaign?: CampaignOrderByWithRelationInput
    _relevance?: RewardBreakdownOrderByRelevanceInput
  }

  export type RewardBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rewardId_campaignId_reason?: RewardBreakdownRewardIdCampaignIdReasonCompoundUniqueInput
    AND?: RewardBreakdownWhereInput | RewardBreakdownWhereInput[]
    OR?: RewardBreakdownWhereInput[]
    NOT?: RewardBreakdownWhereInput | RewardBreakdownWhereInput[]
    protocolId?: StringNullableFilter<"RewardBreakdown"> | string | null
    reason?: StringFilter<"RewardBreakdown"> | string
    amount?: StringFilter<"RewardBreakdown"> | string
    claimed?: StringFilter<"RewardBreakdown"> | string
    pending?: StringFilter<"RewardBreakdown"> | string
    rewardId?: StringFilter<"RewardBreakdown"> | string
    campaignId?: StringFilter<"RewardBreakdown"> | string
    subCampaignId?: StringNullableFilter<"RewardBreakdown"> | string | null
    Protocol?: XOR<ProtocolNullableScalarRelationFilter, ProtocolWhereInput> | null
    Reward?: XOR<RewardScalarRelationFilter, RewardWhereInput>
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    SubCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }, "id" | "rewardId_campaignId_reason">

  export type RewardBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    protocolId?: SortOrderInput | SortOrder
    reason?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    rewardId?: SortOrder
    campaignId?: SortOrder
    subCampaignId?: SortOrderInput | SortOrder
    _count?: RewardBreakdownCountOrderByAggregateInput
    _max?: RewardBreakdownMaxOrderByAggregateInput
    _min?: RewardBreakdownMinOrderByAggregateInput
  }

  export type RewardBreakdownScalarWhereWithAggregatesInput = {
    AND?: RewardBreakdownScalarWhereWithAggregatesInput | RewardBreakdownScalarWhereWithAggregatesInput[]
    OR?: RewardBreakdownScalarWhereWithAggregatesInput[]
    NOT?: RewardBreakdownScalarWhereWithAggregatesInput | RewardBreakdownScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RewardBreakdown"> | string
    protocolId?: StringNullableWithAggregatesFilter<"RewardBreakdown"> | string | null
    reason?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    amount?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    claimed?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    pending?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    rewardId?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    campaignId?: StringWithAggregatesFilter<"RewardBreakdown"> | string
    subCampaignId?: StringNullableWithAggregatesFilter<"RewardBreakdown"> | string | null
  }

  export type MerklRootWhereInput = {
    AND?: MerklRootWhereInput | MerklRootWhereInput[]
    OR?: MerklRootWhereInput[]
    NOT?: MerklRootWhereInput | MerklRootWhereInput[]
    root?: StringFilter<"MerklRoot"> | string
    chainId?: IntFilter<"MerklRoot"> | number
    epoch?: IntFilter<"MerklRoot"> | number
    timestamp?: BigIntFilter<"MerklRoot"> | bigint | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Rewards?: RewardListRelationFilter
  }

  export type MerklRootOrderByWithRelationInput = {
    root?: SortOrder
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
    Chain?: ChainOrderByWithRelationInput
    Rewards?: RewardOrderByRelationAggregateInput
    _relevance?: MerklRootOrderByRelevanceInput
  }

  export type MerklRootWhereUniqueInput = Prisma.AtLeast<{
    root?: string
    AND?: MerklRootWhereInput | MerklRootWhereInput[]
    OR?: MerklRootWhereInput[]
    NOT?: MerklRootWhereInput | MerklRootWhereInput[]
    chainId?: IntFilter<"MerklRoot"> | number
    epoch?: IntFilter<"MerklRoot"> | number
    timestamp?: BigIntFilter<"MerklRoot"> | bigint | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    Rewards?: RewardListRelationFilter
  }, "root">

  export type MerklRootOrderByWithAggregationInput = {
    root?: SortOrder
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
    _count?: MerklRootCountOrderByAggregateInput
    _avg?: MerklRootAvgOrderByAggregateInput
    _max?: MerklRootMaxOrderByAggregateInput
    _min?: MerklRootMinOrderByAggregateInput
    _sum?: MerklRootSumOrderByAggregateInput
  }

  export type MerklRootScalarWhereWithAggregatesInput = {
    AND?: MerklRootScalarWhereWithAggregatesInput | MerklRootScalarWhereWithAggregatesInput[]
    OR?: MerklRootScalarWhereWithAggregatesInput[]
    NOT?: MerklRootScalarWhereWithAggregatesInput | MerklRootScalarWhereWithAggregatesInput[]
    root?: StringWithAggregatesFilter<"MerklRoot"> | string
    chainId?: IntWithAggregatesFilter<"MerklRoot"> | number
    epoch?: IntWithAggregatesFilter<"MerklRoot"> | number
    timestamp?: BigIntWithAggregatesFilter<"MerklRoot"> | bigint | number
  }

  export type PriceSourceWhereInput = {
    AND?: PriceSourceWhereInput | PriceSourceWhereInput[]
    OR?: PriceSourceWhereInput[]
    NOT?: PriceSourceWhereInput | PriceSourceWhereInput[]
    id?: IntFilter<"PriceSource"> | number
    symbol?: StringFilter<"PriceSource"> | string
    method?: EnumPriceSourceMethodFilter<"PriceSource"> | $Enums.PriceSourceMethod
    args?: JsonNullableFilter<"PriceSource">
  }

  export type PriceSourceOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    method?: SortOrder
    args?: SortOrderInput | SortOrder
    _relevance?: PriceSourceOrderByRelevanceInput
  }

  export type PriceSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol?: string
    AND?: PriceSourceWhereInput | PriceSourceWhereInput[]
    OR?: PriceSourceWhereInput[]
    NOT?: PriceSourceWhereInput | PriceSourceWhereInput[]
    method?: EnumPriceSourceMethodFilter<"PriceSource"> | $Enums.PriceSourceMethod
    args?: JsonNullableFilter<"PriceSource">
  }, "id" | "symbol">

  export type PriceSourceOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    method?: SortOrder
    args?: SortOrderInput | SortOrder
    _count?: PriceSourceCountOrderByAggregateInput
    _avg?: PriceSourceAvgOrderByAggregateInput
    _max?: PriceSourceMaxOrderByAggregateInput
    _min?: PriceSourceMinOrderByAggregateInput
    _sum?: PriceSourceSumOrderByAggregateInput
  }

  export type PriceSourceScalarWhereWithAggregatesInput = {
    AND?: PriceSourceScalarWhereWithAggregatesInput | PriceSourceScalarWhereWithAggregatesInput[]
    OR?: PriceSourceScalarWhereWithAggregatesInput[]
    NOT?: PriceSourceScalarWhereWithAggregatesInput | PriceSourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PriceSource"> | number
    symbol?: StringWithAggregatesFilter<"PriceSource"> | string
    method?: EnumPriceSourceMethodWithAggregatesFilter<"PriceSource"> | $Enums.PriceSourceMethod
    args?: JsonNullableWithAggregatesFilter<"PriceSource">
  }

  export type BlacklistWhereInput = {
    AND?: BlacklistWhereInput | BlacklistWhereInput[]
    OR?: BlacklistWhereInput[]
    NOT?: BlacklistWhereInput | BlacklistWhereInput[]
    id?: StringFilter<"Blacklist"> | string
    chainId?: IntFilter<"Blacklist"> | number
    poolAddress?: StringFilter<"Blacklist"> | string
    userAddress?: StringFilter<"Blacklist"> | string
    arrestTimestamp?: BigIntFilter<"Blacklist"> | bigint | number
    arrestDetails?: JsonFilter<"Blacklist">
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlacklistOrderByWithRelationInput = {
    id?: SortOrder
    chainId?: SortOrder
    poolAddress?: SortOrder
    userAddress?: SortOrder
    arrestTimestamp?: SortOrder
    arrestDetails?: SortOrder
    Chain?: ChainOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: BlacklistOrderByRelevanceInput
  }

  export type BlacklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId_userAddress_poolAddress?: BlacklistChainIdUserAddressPoolAddressCompoundUniqueInput
    AND?: BlacklistWhereInput | BlacklistWhereInput[]
    OR?: BlacklistWhereInput[]
    NOT?: BlacklistWhereInput | BlacklistWhereInput[]
    chainId?: IntFilter<"Blacklist"> | number
    poolAddress?: StringFilter<"Blacklist"> | string
    userAddress?: StringFilter<"Blacklist"> | string
    arrestTimestamp?: BigIntFilter<"Blacklist"> | bigint | number
    arrestDetails?: JsonFilter<"Blacklist">
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "chainId_userAddress_poolAddress">

  export type BlacklistOrderByWithAggregationInput = {
    id?: SortOrder
    chainId?: SortOrder
    poolAddress?: SortOrder
    userAddress?: SortOrder
    arrestTimestamp?: SortOrder
    arrestDetails?: SortOrder
    _count?: BlacklistCountOrderByAggregateInput
    _avg?: BlacklistAvgOrderByAggregateInput
    _max?: BlacklistMaxOrderByAggregateInput
    _min?: BlacklistMinOrderByAggregateInput
    _sum?: BlacklistSumOrderByAggregateInput
  }

  export type BlacklistScalarWhereWithAggregatesInput = {
    AND?: BlacklistScalarWhereWithAggregatesInput | BlacklistScalarWhereWithAggregatesInput[]
    OR?: BlacklistScalarWhereWithAggregatesInput[]
    NOT?: BlacklistScalarWhereWithAggregatesInput | BlacklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blacklist"> | string
    chainId?: IntWithAggregatesFilter<"Blacklist"> | number
    poolAddress?: StringWithAggregatesFilter<"Blacklist"> | string
    userAddress?: StringWithAggregatesFilter<"Blacklist"> | string
    arrestTimestamp?: BigIntWithAggregatesFilter<"Blacklist"> | bigint | number
    arrestDetails?: JsonWithAggregatesFilter<"Blacklist">
  }

  export type DumpWhereInput = {
    AND?: DumpWhereInput | DumpWhereInput[]
    OR?: DumpWhereInput[]
    NOT?: DumpWhereInput | DumpWhereInput[]
    id?: StringFilter<"Dump"> | string
    chainId?: IntFilter<"Dump"> | number
    fromTokenId?: StringFilter<"Dump"> | string
    toTokenId?: StringFilter<"Dump"> | string
    multisig?: StringFilter<"Dump"> | string
    recipient?: StringFilter<"Dump"> | string
    amountIn?: StringFilter<"Dump"> | string
    amountOut?: StringFilter<"Dump"> | string
    datetime?: DateTimeFilter<"Dump"> | Date | string
    timestamp?: IntFilter<"Dump"> | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    FromToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    ToToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }

  export type DumpOrderByWithRelationInput = {
    id?: SortOrder
    chainId?: SortOrder
    fromTokenId?: SortOrder
    toTokenId?: SortOrder
    multisig?: SortOrder
    recipient?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    datetime?: SortOrder
    timestamp?: SortOrder
    Chain?: ChainOrderByWithRelationInput
    FromToken?: TokenOrderByWithRelationInput
    ToToken?: TokenOrderByWithRelationInput
    _relevance?: DumpOrderByRelevanceInput
  }

  export type DumpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId_fromTokenId_toTokenId_timestamp?: DumpChainIdFromTokenIdToTokenIdTimestampCompoundUniqueInput
    AND?: DumpWhereInput | DumpWhereInput[]
    OR?: DumpWhereInput[]
    NOT?: DumpWhereInput | DumpWhereInput[]
    chainId?: IntFilter<"Dump"> | number
    fromTokenId?: StringFilter<"Dump"> | string
    toTokenId?: StringFilter<"Dump"> | string
    multisig?: StringFilter<"Dump"> | string
    recipient?: StringFilter<"Dump"> | string
    amountIn?: StringFilter<"Dump"> | string
    amountOut?: StringFilter<"Dump"> | string
    datetime?: DateTimeFilter<"Dump"> | Date | string
    timestamp?: IntFilter<"Dump"> | number
    Chain?: XOR<ChainScalarRelationFilter, ChainWhereInput>
    FromToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
    ToToken?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }, "id" | "chainId_fromTokenId_toTokenId_timestamp">

  export type DumpOrderByWithAggregationInput = {
    id?: SortOrder
    chainId?: SortOrder
    fromTokenId?: SortOrder
    toTokenId?: SortOrder
    multisig?: SortOrder
    recipient?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    datetime?: SortOrder
    timestamp?: SortOrder
    _count?: DumpCountOrderByAggregateInput
    _avg?: DumpAvgOrderByAggregateInput
    _max?: DumpMaxOrderByAggregateInput
    _min?: DumpMinOrderByAggregateInput
    _sum?: DumpSumOrderByAggregateInput
  }

  export type DumpScalarWhereWithAggregatesInput = {
    AND?: DumpScalarWhereWithAggregatesInput | DumpScalarWhereWithAggregatesInput[]
    OR?: DumpScalarWhereWithAggregatesInput[]
    NOT?: DumpScalarWhereWithAggregatesInput | DumpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dump"> | string
    chainId?: IntWithAggregatesFilter<"Dump"> | number
    fromTokenId?: StringWithAggregatesFilter<"Dump"> | string
    toTokenId?: StringWithAggregatesFilter<"Dump"> | string
    multisig?: StringWithAggregatesFilter<"Dump"> | string
    recipient?: StringWithAggregatesFilter<"Dump"> | string
    amountIn?: StringWithAggregatesFilter<"Dump"> | string
    amountOut?: StringWithAggregatesFilter<"Dump"> | string
    datetime?: DateTimeWithAggregatesFilter<"Dump"> | Date | string
    timestamp?: IntWithAggregatesFilter<"Dump"> | number
  }

  export type LoggedWhereInput = {
    AND?: LoggedWhereInput | LoggedWhereInput[]
    OR?: LoggedWhereInput[]
    NOT?: LoggedWhereInput | LoggedWhereInput[]
    id?: StringFilter<"Logged"> | string
    chainId?: IntFilter<"Logged"> | number
    type?: EnumLoggedEntityTypeFilter<"Logged"> | $Enums.LoggedEntityType
    address?: StringNullableFilter<"Logged"> | string | null
    fetchAtBlock?: IntFilter<"Logged"> | number
    caughtFromAddress?: StringFilter<"Logged"> | string
    entityData?: JsonFilter<"Logged">
  }

  export type LoggedOrderByWithRelationInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    fetchAtBlock?: SortOrder
    caughtFromAddress?: SortOrder
    entityData?: SortOrder
    _relevance?: LoggedOrderByRelevanceInput
  }

  export type LoggedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId_address?: LoggedChainIdAddressCompoundUniqueInput
    AND?: LoggedWhereInput | LoggedWhereInput[]
    OR?: LoggedWhereInput[]
    NOT?: LoggedWhereInput | LoggedWhereInput[]
    chainId?: IntFilter<"Logged"> | number
    type?: EnumLoggedEntityTypeFilter<"Logged"> | $Enums.LoggedEntityType
    address?: StringNullableFilter<"Logged"> | string | null
    fetchAtBlock?: IntFilter<"Logged"> | number
    caughtFromAddress?: StringFilter<"Logged"> | string
    entityData?: JsonFilter<"Logged">
  }, "id" | "chainId_address">

  export type LoggedOrderByWithAggregationInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    fetchAtBlock?: SortOrder
    caughtFromAddress?: SortOrder
    entityData?: SortOrder
    _count?: LoggedCountOrderByAggregateInput
    _avg?: LoggedAvgOrderByAggregateInput
    _max?: LoggedMaxOrderByAggregateInput
    _min?: LoggedMinOrderByAggregateInput
    _sum?: LoggedSumOrderByAggregateInput
  }

  export type LoggedScalarWhereWithAggregatesInput = {
    AND?: LoggedScalarWhereWithAggregatesInput | LoggedScalarWhereWithAggregatesInput[]
    OR?: LoggedScalarWhereWithAggregatesInput[]
    NOT?: LoggedScalarWhereWithAggregatesInput | LoggedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Logged"> | string
    chainId?: IntWithAggregatesFilter<"Logged"> | number
    type?: EnumLoggedEntityTypeWithAggregatesFilter<"Logged"> | $Enums.LoggedEntityType
    address?: StringNullableWithAggregatesFilter<"Logged"> | string | null
    fetchAtBlock?: IntWithAggregatesFilter<"Logged"> | number
    caughtFromAddress?: StringWithAggregatesFilter<"Logged"> | string
    entityData?: JsonWithAggregatesFilter<"Logged">
  }

  export type CampaignCreateInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignStatusCreateInput = {
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
    Campaign: CampaignCreateNestedOneWithoutCampaignStatusInput
  }

  export type CampaignStatusUncheckedCreateInput = {
    campaignId: string
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUpdateInput = {
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    Campaign?: CampaignUpdateOneRequiredWithoutCampaignStatusNestedInput
  }

  export type CampaignStatusUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusCreateManyInput = {
    campaignId: string
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUpdateManyMutationInput = {
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignComputedValueCreateInput = {
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
    Campaign: CampaignCreateNestedOneWithoutCampaignEngineValuesInput
  }

  export type CampaignComputedValueUncheckedCreateInput = {
    campaignId: string
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
  }

  export type CampaignComputedValueUpdateInput = {
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    Campaign?: CampaignUpdateOneRequiredWithoutCampaignEngineValuesNestedInput
  }

  export type CampaignComputedValueUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignComputedValueCreateManyInput = {
    campaignId: string
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
  }

  export type CampaignComputedValueUpdateManyMutationInput = {
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignComputedValueUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueCreateInput = {
    id?: string
    reason: string
    boost?: number | null
    Campaign: CampaignCreateNestedOneWithoutUserComputedValueInput
    User?: UserCreateNestedOneWithoutUserComputedValueInput
  }

  export type UserComputedValueUncheckedCreateInput = {
    id?: string
    campaignId: string
    address: string
    reason: string
    boost?: number | null
  }

  export type UserComputedValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
    Campaign?: CampaignUpdateOneRequiredWithoutUserComputedValueNestedInput
    User?: UserUpdateOneWithoutUserComputedValueNestedInput
  }

  export type UserComputedValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueCreateManyInput = {
    id?: string
    campaignId: string
    address: string
    reason: string
    boost?: number | null
  }

  export type UserComputedValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ChainCreateInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type ChainCreateManyInput = {
    id: number
    name: string
    icon: string
  }

  export type ChainUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type ChainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type ExplorerCreateInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
    Chain: ChainCreateNestedOneWithoutExplorerInput
  }

  export type ExplorerUncheckedCreateInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
    chainId: number
  }

  export type ExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
    Chain?: ChainUpdateOneRequiredWithoutExplorerNestedInput
  }

  export type ExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
  }

  export type ExplorerCreateManyInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
    chainId: number
  }

  export type ExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
  }

  export type OpportunityCreateInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type ProtocolCreateInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityCreateNestedManyWithoutMainProtocolInput
    Opportunities?: OpportunityCreateNestedManyWithoutProtocolsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityUncheckedCreateNestedManyWithoutMainProtocolInput
    Opportunities?: OpportunityUncheckedCreateNestedManyWithoutProtocolsInput
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUpdateManyWithoutMainProtocolNestedInput
    Opportunities?: OpportunityUpdateManyWithoutProtocolsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUncheckedUpdateManyWithoutMainProtocolNestedInput
    Opportunities?: OpportunityUncheckedUpdateManyWithoutProtocolsNestedInput
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolCreateManyInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
  }

  export type ProtocolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type ProtocolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TokenCreateInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenCreateManyInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AprRecordCreateInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    AprBreakdown?: AprBreakdownCreateNestedManyWithoutAprRecordInput
    Opportunity: OpportunityCreateNestedOneWithoutAprRecordsInput
  }

  export type AprRecordUncheckedCreateInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    opportunityId: string
    AprBreakdown?: AprBreakdownUncheckedCreateNestedManyWithoutAprRecordInput
  }

  export type AprRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    AprBreakdown?: AprBreakdownUpdateManyWithoutAprRecordNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutAprRecordsNestedInput
  }

  export type AprRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
    AprBreakdown?: AprBreakdownUncheckedUpdateManyWithoutAprRecordNestedInput
  }

  export type AprRecordCreateManyInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    opportunityId: string
  }

  export type AprRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
  }

  export type AprRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type AprBreakdownCreateInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
    AprRecord: AprRecordCreateNestedOneWithoutAprBreakdownInput
  }

  export type AprBreakdownUncheckedCreateInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
    aprRecordId: string
  }

  export type AprBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
    AprRecord?: AprRecordUpdateOneRequiredWithoutAprBreakdownNestedInput
  }

  export type AprBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
    aprRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type AprBreakdownCreateManyInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
    aprRecordId: string
  }

  export type AprBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type AprBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
    aprRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type TVLRecordCreateInput = {
    id: string
    timestamp: bigint | number
    total: number
    TvlBreakdown?: TVLBreakdownCreateNestedManyWithoutTvlRecordInput
    Opportunity: OpportunityCreateNestedOneWithoutTvlRecordsInput
  }

  export type TVLRecordUncheckedCreateInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
    TvlBreakdown?: TVLBreakdownUncheckedCreateNestedManyWithoutTvlRecordInput
  }

  export type TVLRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    TvlBreakdown?: TVLBreakdownUpdateManyWithoutTvlRecordNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutTvlRecordsNestedInput
  }

  export type TVLRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
    TvlBreakdown?: TVLBreakdownUncheckedUpdateManyWithoutTvlRecordNestedInput
  }

  export type TVLRecordCreateManyInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
  }

  export type TVLRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type TVLRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type TVLBreakdownCreateInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
    TvlRecord: TVLRecordCreateNestedOneWithoutTvlBreakdownInput
  }

  export type TVLBreakdownUncheckedCreateInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
    tvlRecordId: string
  }

  export type TVLBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
    TvlRecord?: TVLRecordUpdateOneRequiredWithoutTvlBreakdownNestedInput
  }

  export type TVLBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
    tvlRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type TVLBreakdownCreateManyInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
    tvlRecordId: string
  }

  export type TVLBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type TVLBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
    tvlRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsRecordCreateInput = {
    id: string
    timestamp: bigint | number
    total: number
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutDailyRewardsRecordInput
    Opportunity: OpportunityCreateNestedOneWithoutDailyRewardsRecordsInput
  }

  export type DailyRewardsRecordUncheckedCreateInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutDailyRewardsRecordInput
  }

  export type DailyRewardsRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutDailyRewardsRecordNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutDailyRewardsRecordsNestedInput
  }

  export type DailyRewardsRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutDailyRewardsRecordNestedInput
  }

  export type DailyRewardsRecordCreateManyInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
  }

  export type DailyRewardsRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type DailyRewardsRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsBreakdownCreateInput = {
    id?: string
    value: number
    Campaign: CampaignCreateNestedOneWithoutDailyRewardsBreakdownInput
    DailyRewardsRecord: DailyRewardsRecordCreateNestedOneWithoutDailyRewardsBreakdownInput
  }

  export type DailyRewardsBreakdownUncheckedCreateInput = {
    id?: string
    value: number
    campaignId: string
    dailyRewardsRecordId: string
  }

  export type DailyRewardsBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    Campaign?: CampaignUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput
    DailyRewardsRecord?: DailyRewardsRecordUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput
  }

  export type DailyRewardsBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    dailyRewardsRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsBreakdownCreateManyInput = {
    id?: string
    value: number
    campaignId: string
    dailyRewardsRecordId: string
  }

  export type DailyRewardsBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type DailyRewardsBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    dailyRewardsRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutUserInput
    Creator?: CreatorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
    Rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutUserNestedInput
    Creator?: CreatorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    Rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
  }

  export type UserUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatorCreateInput = {
    id: string
    icon?: string | null
    name: string
    rebateFee?: number
    Users?: UserCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateInput = {
    id: string
    icon?: string | null
    name: string
    rebateFee?: number
    Users?: UserUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
    Users?: UserUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
    Users?: UserUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateManyInput = {
    id: string
    icon?: string | null
    name: string
    rebateFee?: number
  }

  export type CreatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
  }

  export type CreatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
  }

  export type RewardCreateInput = {
    id: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    MerklRoot: MerklRootCreateNestedOneWithoutRewardsInput
    User: UserCreateNestedOneWithoutRewardsInput
    RewardToken: TokenCreateNestedOneWithoutRewardInput
    Breakdown?: RewardBreakdownCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateInput = {
    id: string
    root: string
    recipient: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    MerklRoot?: MerklRootUpdateOneRequiredWithoutRewardsNestedInput
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutRewardNestedInput
    Breakdown?: RewardBreakdownUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardCreateManyInput = {
    id: string
    root: string
    recipient: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
  }

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }

  export type RewardBreakdownCreateInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    Protocol?: ProtocolCreateNestedOneWithoutRewardBreakdownInput
    Reward: RewardCreateNestedOneWithoutBreakdownInput
    Campaign: CampaignCreateNestedOneWithoutRewardBreakdownInput
    SubCampaign?: CampaignCreateNestedOneWithoutRewardBreakdownSubCampaignInput
  }

  export type RewardBreakdownUncheckedCreateInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    Protocol?: ProtocolUpdateOneWithoutRewardBreakdownNestedInput
    Reward?: RewardUpdateOneRequiredWithoutBreakdownNestedInput
    Campaign?: CampaignUpdateOneRequiredWithoutRewardBreakdownNestedInput
    SubCampaign?: CampaignUpdateOneWithoutRewardBreakdownSubCampaignNestedInput
  }

  export type RewardBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardBreakdownCreateManyInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
  }

  export type RewardBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerklRootCreateInput = {
    root: string
    epoch: number
    timestamp: bigint | number
    Chain: ChainCreateNestedOneWithoutMerklRootInput
    Rewards?: RewardCreateNestedManyWithoutMerklRootInput
  }

  export type MerklRootUncheckedCreateInput = {
    root: string
    chainId: number
    epoch: number
    timestamp: bigint | number
    Rewards?: RewardUncheckedCreateNestedManyWithoutMerklRootInput
  }

  export type MerklRootUpdateInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    Chain?: ChainUpdateOneRequiredWithoutMerklRootNestedInput
    Rewards?: RewardUpdateManyWithoutMerklRootNestedInput
  }

  export type MerklRootUncheckedUpdateInput = {
    root?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    Rewards?: RewardUncheckedUpdateManyWithoutMerklRootNestedInput
  }

  export type MerklRootCreateManyInput = {
    root: string
    chainId: number
    epoch: number
    timestamp: bigint | number
  }

  export type MerklRootUpdateManyMutationInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MerklRootUncheckedUpdateManyInput = {
    root?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PriceSourceCreateInput = {
    symbol: string
    method: $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceUncheckedCreateInput = {
    id?: number
    symbol: string
    method: $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    method?: EnumPriceSourceMethodFieldUpdateOperationsInput | $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    method?: EnumPriceSourceMethodFieldUpdateOperationsInput | $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceCreateManyInput = {
    id?: number
    symbol: string
    method: $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    method?: EnumPriceSourceMethodFieldUpdateOperationsInput | $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceSourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    method?: EnumPriceSourceMethodFieldUpdateOperationsInput | $Enums.PriceSourceMethod
    args?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlacklistCreateInput = {
    id: string
    poolAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
    Chain: ChainCreateNestedOneWithoutBlacklistInput
    User: UserCreateNestedOneWithoutBlacklistInput
  }

  export type BlacklistUncheckedCreateInput = {
    id: string
    chainId: number
    poolAddress: string
    userAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
    Chain?: ChainUpdateOneRequiredWithoutBlacklistNestedInput
    User?: UserUpdateOneRequiredWithoutBlacklistNestedInput
  }

  export type BlacklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    poolAddress?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistCreateManyInput = {
    id: string
    chainId: number
    poolAddress: string
    userAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    poolAddress?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type DumpCreateInput = {
    id: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
    Chain: ChainCreateNestedOneWithoutDumpInput
    FromToken: TokenCreateNestedOneWithoutDumpFromInput
    ToToken: TokenCreateNestedOneWithoutDumpToInput
  }

  export type DumpUncheckedCreateInput = {
    id: string
    chainId: number
    fromTokenId: string
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
    Chain?: ChainUpdateOneRequiredWithoutDumpNestedInput
    FromToken?: TokenUpdateOneRequiredWithoutDumpFromNestedInput
    ToToken?: TokenUpdateOneRequiredWithoutDumpToNestedInput
  }

  export type DumpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    fromTokenId?: StringFieldUpdateOperationsInput | string
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpCreateManyInput = {
    id: string
    chainId: number
    fromTokenId: string
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    fromTokenId?: StringFieldUpdateOperationsInput | string
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LoggedCreateInput = {
    id: string
    chainId: number
    type?: $Enums.LoggedEntityType
    address?: string | null
    fetchAtBlock: number
    caughtFromAddress: string
    entityData: JsonNullValueInput | InputJsonValue
  }

  export type LoggedUncheckedCreateInput = {
    id: string
    chainId: number
    type?: $Enums.LoggedEntityType
    address?: string | null
    fetchAtBlock: number
    caughtFromAddress: string
    entityData: JsonNullValueInput | InputJsonValue
  }

  export type LoggedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: EnumLoggedEntityTypeFieldUpdateOperationsInput | $Enums.LoggedEntityType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fetchAtBlock?: IntFieldUpdateOperationsInput | number
    caughtFromAddress?: StringFieldUpdateOperationsInput | string
    entityData?: JsonNullValueInput | InputJsonValue
  }

  export type LoggedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: EnumLoggedEntityTypeFieldUpdateOperationsInput | $Enums.LoggedEntityType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fetchAtBlock?: IntFieldUpdateOperationsInput | number
    caughtFromAddress?: StringFieldUpdateOperationsInput | string
    entityData?: JsonNullValueInput | InputJsonValue
  }

  export type LoggedCreateManyInput = {
    id: string
    chainId: number
    type?: $Enums.LoggedEntityType
    address?: string | null
    fetchAtBlock: number
    caughtFromAddress: string
    entityData: JsonNullValueInput | InputJsonValue
  }

  export type LoggedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: EnumLoggedEntityTypeFieldUpdateOperationsInput | $Enums.LoggedEntityType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fetchAtBlock?: IntFieldUpdateOperationsInput | number
    caughtFromAddress?: StringFieldUpdateOperationsInput | string
    entityData?: JsonNullValueInput | InputJsonValue
  }

  export type LoggedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: EnumLoggedEntityTypeFieldUpdateOperationsInput | $Enums.LoggedEntityType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    fetchAtBlock?: IntFieldUpdateOperationsInput | number
    caughtFromAddress?: StringFieldUpdateOperationsInput | string
    entityData?: JsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumDistributionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DistributionType | EnumDistributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributionTypeFilter<$PrismaModel> | $Enums.DistributionType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumCampaignManualOverrideNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignManualOverride[] | ListEnumCampaignManualOverrideFieldRefInput<$PrismaModel> | null
    has?: $Enums.CampaignManualOverride | EnumCampaignManualOverrideFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.CampaignManualOverride[] | ListEnumCampaignManualOverrideFieldRefInput<$PrismaModel>
    hasSome?: $Enums.CampaignManualOverride[] | ListEnumCampaignManualOverrideFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ChainScalarRelationFilter = {
    is?: ChainWhereInput
    isNot?: ChainWhereInput
  }

  export type TokenScalarRelationFilter = {
    is?: TokenWhereInput
    isNot?: TokenWhereInput
  }

  export type OpportunityScalarRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type RewardBreakdownListRelationFilter = {
    every?: RewardBreakdownWhereInput
    some?: RewardBreakdownWhereInput
    none?: RewardBreakdownWhereInput
  }

  export type DailyRewardsBreakdownListRelationFilter = {
    every?: DailyRewardsBreakdownWhereInput
    some?: DailyRewardsBreakdownWhereInput
    none?: DailyRewardsBreakdownWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CampaignStatusListRelationFilter = {
    every?: CampaignStatusWhereInput
    some?: CampaignStatusWhereInput
    none?: CampaignStatusWhereInput
  }

  export type CampaignComputedValueListRelationFilter = {
    every?: CampaignComputedValueWhereInput
    some?: CampaignComputedValueWhereInput
    none?: CampaignComputedValueWhereInput
  }

  export type UserComputedValueListRelationFilter = {
    every?: UserComputedValueWhereInput
    some?: UserComputedValueWhereInput
    none?: UserComputedValueWhereInput
  }

  export type CampaignNullableScalarRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RewardBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRewardsBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignComputedValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserComputedValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelevanceInput = {
    fields: CampaignOrderByRelevanceFieldEnum | CampaignOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CampaignDistributionChainIdCampaignIdCompoundUniqueInput = {
    distributionChainId: number
    campaignId: string
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    distributionType?: SortOrder
    subType?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    opportunityId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    params?: SortOrder
    description?: SortOrder
    creatorAddress?: SortOrder
    manualOverrides?: SortOrder
    createdAt?: SortOrder
    rootCampaignId?: SortOrder
    parentCampaignId?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    subType?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    distributionType?: SortOrder
    subType?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    opportunityId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    description?: SortOrder
    creatorAddress?: SortOrder
    createdAt?: SortOrder
    rootCampaignId?: SortOrder
    parentCampaignId?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    distributionType?: SortOrder
    subType?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    opportunityId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    description?: SortOrder
    creatorAddress?: SortOrder
    createdAt?: SortOrder
    rootCampaignId?: SortOrder
    parentCampaignId?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    computeChainId?: SortOrder
    distributionChainId?: SortOrder
    subType?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDistributionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DistributionType | EnumDistributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DistributionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDistributionTypeFilter<$PrismaModel>
    _max?: NestedEnumDistributionTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RunStatus | EnumRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRunStatusFilter<$PrismaModel> | $Enums.RunStatus
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignStatusOrderByRelevanceInput = {
    fields: CampaignStatusOrderByRelevanceFieldEnum | CampaignStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CampaignStatusCountOrderByAggregateInput = {
    campaignId?: SortOrder
    computedUntil?: SortOrder
    processingStarted?: SortOrder
    status?: SortOrder
    error?: SortOrder
    details?: SortOrder
  }

  export type CampaignStatusAvgOrderByAggregateInput = {
    computedUntil?: SortOrder
    processingStarted?: SortOrder
  }

  export type CampaignStatusMaxOrderByAggregateInput = {
    campaignId?: SortOrder
    computedUntil?: SortOrder
    processingStarted?: SortOrder
    status?: SortOrder
    error?: SortOrder
  }

  export type CampaignStatusMinOrderByAggregateInput = {
    campaignId?: SortOrder
    computedUntil?: SortOrder
    processingStarted?: SortOrder
    status?: SortOrder
    error?: SortOrder
  }

  export type CampaignStatusSumOrderByAggregateInput = {
    computedUntil?: SortOrder
    processingStarted?: SortOrder
  }

  export type EnumRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RunStatus | EnumRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.RunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRunStatusFilter<$PrismaModel>
    _max?: NestedEnumRunStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CampaignComputedValueOrderByRelevanceInput = {
    fields: CampaignComputedValueOrderByRelevanceFieldEnum | CampaignComputedValueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CampaignComputedValueCountOrderByAggregateInput = {
    campaignId?: SortOrder
    averageBoost?: SortOrder
    totalDistributedInUSD?: SortOrder
    forfeitingBoost?: SortOrder
  }

  export type CampaignComputedValueAvgOrderByAggregateInput = {
    averageBoost?: SortOrder
    totalDistributedInUSD?: SortOrder
    forfeitingBoost?: SortOrder
  }

  export type CampaignComputedValueMaxOrderByAggregateInput = {
    campaignId?: SortOrder
    averageBoost?: SortOrder
    totalDistributedInUSD?: SortOrder
    forfeitingBoost?: SortOrder
  }

  export type CampaignComputedValueMinOrderByAggregateInput = {
    campaignId?: SortOrder
    averageBoost?: SortOrder
    totalDistributedInUSD?: SortOrder
    forfeitingBoost?: SortOrder
  }

  export type CampaignComputedValueSumOrderByAggregateInput = {
    averageBoost?: SortOrder
    totalDistributedInUSD?: SortOrder
    forfeitingBoost?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserComputedValueOrderByRelevanceInput = {
    fields: UserComputedValueOrderByRelevanceFieldEnum | UserComputedValueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserComputedValueCampaignIdAddressReasonCompoundUniqueInput = {
    campaignId: string
    address: string
    reason: string
  }

  export type UserComputedValueCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    address?: SortOrder
    reason?: SortOrder
    boost?: SortOrder
  }

  export type UserComputedValueAvgOrderByAggregateInput = {
    boost?: SortOrder
  }

  export type UserComputedValueMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    address?: SortOrder
    reason?: SortOrder
    boost?: SortOrder
  }

  export type UserComputedValueMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    address?: SortOrder
    reason?: SortOrder
    boost?: SortOrder
  }

  export type UserComputedValueSumOrderByAggregateInput = {
    boost?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ExplorerListRelationFilter = {
    every?: ExplorerWhereInput
    some?: ExplorerWhereInput
    none?: ExplorerWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type MerklRootListRelationFilter = {
    every?: MerklRootWhereInput
    some?: MerklRootWhereInput
    none?: MerklRootWhereInput
  }

  export type BlacklistListRelationFilter = {
    every?: BlacklistWhereInput
    some?: BlacklistWhereInput
    none?: BlacklistWhereInput
  }

  export type DumpListRelationFilter = {
    every?: DumpWhereInput
    some?: DumpWhereInput
    none?: DumpWhereInput
  }

  export type ExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerklRootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlacklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DumpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChainOrderByRelevanceInput = {
    fields: ChainOrderByRelevanceFieldEnum | ChainOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type ChainAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type ChainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type ChainSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumExplorerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExplorerType | EnumExplorerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExplorerTypeFilter<$PrismaModel> | $Enums.ExplorerType
  }

  export type ExplorerOrderByRelevanceInput = {
    fields: ExplorerOrderByRelevanceFieldEnum | ExplorerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExplorerTypeChainIdCompoundUniqueInput = {
    type: $Enums.ExplorerType
    chainId: number
  }

  export type ExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    chainId?: SortOrder
  }

  export type ExplorerAvgOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type ExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    chainId?: SortOrder
  }

  export type ExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    chainId?: SortOrder
  }

  export type ExplorerSumOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type EnumExplorerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExplorerType | EnumExplorerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExplorerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExplorerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExplorerTypeFilter<$PrismaModel>
    _max?: NestedEnumExplorerTypeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumOpportunityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityAction | EnumOpportunityActionFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityActionFilter<$PrismaModel> | $Enums.OpportunityAction
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumOpportunityManualOverrideNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityManualOverride[] | ListEnumOpportunityManualOverrideFieldRefInput<$PrismaModel> | null
    has?: $Enums.OpportunityManualOverride | EnumOpportunityManualOverrideFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.OpportunityManualOverride[] | ListEnumOpportunityManualOverrideFieldRefInput<$PrismaModel>
    hasSome?: $Enums.OpportunityManualOverride[] | ListEnumOpportunityManualOverrideFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProtocolListRelationFilter = {
    every?: ProtocolWhereInput
    some?: ProtocolWhereInput
    none?: ProtocolWhereInput
  }

  export type ProtocolNullableScalarRelationFilter = {
    is?: ProtocolWhereInput | null
    isNot?: ProtocolWhereInput | null
  }

  export type TVLRecordListRelationFilter = {
    every?: TVLRecordWhereInput
    some?: TVLRecordWhereInput
    none?: TVLRecordWhereInput
  }

  export type AprRecordListRelationFilter = {
    every?: AprRecordWhereInput
    some?: AprRecordWhereInput
    none?: AprRecordWhereInput
  }

  export type DailyRewardsRecordListRelationFilter = {
    every?: DailyRewardsRecordWhereInput
    some?: DailyRewardsRecordWhereInput
    none?: DailyRewardsRecordWhereInput
  }

  export type ProtocolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TVLRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AprRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRewardsRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelevanceInput = {
    fields: OpportunityOrderByRelevanceFieldEnum | OpportunityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OpportunityChainIdTypeIdentifierCompoundUniqueInput = {
    chainId: number
    type: string
    identifier: string
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    description?: SortOrder
    howToSteps?: SortOrder
    depositUrl?: SortOrder
    explorerAddress?: SortOrder
    status?: SortOrder
    action?: SortOrder
    mainProtocolId?: SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
    tags?: SortOrder
    lastCampaignCreatedAt?: SortOrder
    manualOverrides?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    chainId?: SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    description?: SortOrder
    depositUrl?: SortOrder
    explorerAddress?: SortOrder
    status?: SortOrder
    action?: SortOrder
    mainProtocolId?: SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
    lastCampaignCreatedAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    description?: SortOrder
    depositUrl?: SortOrder
    explorerAddress?: SortOrder
    status?: SortOrder
    action?: SortOrder
    mainProtocolId?: SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
    lastCampaignCreatedAt?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    chainId?: SortOrder
    tvl?: SortOrder
    apr?: SortOrder
    dailyRewards?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumOpportunityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityAction | EnumOpportunityActionFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityActionWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityActionFilter<$PrismaModel>
    _max?: NestedEnumOpportunityActionFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProtocolOrderByRelevanceInput = {
    fields: ProtocolOrderByRelevanceFieldEnum | ProtocolOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProtocolCountOrderByAggregateInput = {
    id?: SortOrder
    tags?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
  }

  export type ProtocolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
  }

  export type ProtocolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelevanceInput = {
    fields: TokenOrderByRelevanceFieldEnum | TokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TokenChainIdAddressCompoundUniqueInput = {
    chainId: number
    address: string
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chainId?: SortOrder
    address?: SortOrder
    decimals?: SortOrder
    symbol?: SortOrder
    displaySymbol?: SortOrder
    icon?: SortOrder
    verified?: SortOrder
    isTest?: SortOrder
    isPoint?: SortOrder
    isPreTGE?: SortOrder
    isNative?: SortOrder
    price?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
    price?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chainId?: SortOrder
    address?: SortOrder
    decimals?: SortOrder
    symbol?: SortOrder
    displaySymbol?: SortOrder
    icon?: SortOrder
    verified?: SortOrder
    isTest?: SortOrder
    isPoint?: SortOrder
    isPreTGE?: SortOrder
    isNative?: SortOrder
    price?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    chainId?: SortOrder
    address?: SortOrder
    decimals?: SortOrder
    symbol?: SortOrder
    displaySymbol?: SortOrder
    icon?: SortOrder
    verified?: SortOrder
    isTest?: SortOrder
    isPoint?: SortOrder
    isPreTGE?: SortOrder
    isNative?: SortOrder
    price?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    chainId?: SortOrder
    decimals?: SortOrder
    price?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AprBreakdownListRelationFilter = {
    every?: AprBreakdownWhereInput
    some?: AprBreakdownWhereInput
    none?: AprBreakdownWhereInput
  }

  export type AprBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AprRecordOrderByRelevanceInput = {
    fields: AprRecordOrderByRelevanceFieldEnum | AprRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AprRecordOpportunityIdTimestampCompoundUniqueInput = {
    opportunityId: string
    timestamp: bigint | number
  }

  export type AprRecordCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    cumulated?: SortOrder
    opportunityId?: SortOrder
  }

  export type AprRecordAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    cumulated?: SortOrder
  }

  export type AprRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    cumulated?: SortOrder
    opportunityId?: SortOrder
  }

  export type AprRecordMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    cumulated?: SortOrder
    opportunityId?: SortOrder
  }

  export type AprRecordSumOrderByAggregateInput = {
    timestamp?: SortOrder
    cumulated?: SortOrder
  }

  export type EnumAprTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AprType | EnumAprTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAprTypeFilter<$PrismaModel> | $Enums.AprType
  }

  export type AprRecordScalarRelationFilter = {
    is?: AprRecordWhereInput
    isNot?: AprRecordWhereInput
  }

  export type AprBreakdownOrderByRelevanceInput = {
    fields: AprBreakdownOrderByRelevanceFieldEnum | AprBreakdownOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AprBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    aprRecordId?: SortOrder
  }

  export type AprBreakdownAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type AprBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    aprRecordId?: SortOrder
  }

  export type AprBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    aprRecordId?: SortOrder
  }

  export type AprBreakdownSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumAprTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AprType | EnumAprTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAprTypeWithAggregatesFilter<$PrismaModel> | $Enums.AprType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAprTypeFilter<$PrismaModel>
    _max?: NestedEnumAprTypeFilter<$PrismaModel>
  }

  export type TVLBreakdownListRelationFilter = {
    every?: TVLBreakdownWhereInput
    some?: TVLBreakdownWhereInput
    none?: TVLBreakdownWhereInput
  }

  export type TVLBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TVLRecordOrderByRelevanceInput = {
    fields: TVLRecordOrderByRelevanceFieldEnum | TVLRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TVLRecordOpportunityIdTimestampCompoundUniqueInput = {
    opportunityId: string
    timestamp: bigint | number
  }

  export type TVLRecordCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type TVLRecordAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    total?: SortOrder
  }

  export type TVLRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type TVLRecordMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type TVLRecordSumOrderByAggregateInput = {
    timestamp?: SortOrder
    total?: SortOrder
  }

  export type EnumTvlTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TvlType | EnumTvlTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTvlTypeFilter<$PrismaModel> | $Enums.TvlType
  }

  export type TVLRecordScalarRelationFilter = {
    is?: TVLRecordWhereInput
    isNot?: TVLRecordWhereInput
  }

  export type TVLBreakdownOrderByRelevanceInput = {
    fields: TVLBreakdownOrderByRelevanceFieldEnum | TVLBreakdownOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TVLBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    tvlRecordId?: SortOrder
  }

  export type TVLBreakdownAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TVLBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    tvlRecordId?: SortOrder
  }

  export type TVLBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    value?: SortOrder
    tvlRecordId?: SortOrder
  }

  export type TVLBreakdownSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumTvlTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TvlType | EnumTvlTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTvlTypeWithAggregatesFilter<$PrismaModel> | $Enums.TvlType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTvlTypeFilter<$PrismaModel>
    _max?: NestedEnumTvlTypeFilter<$PrismaModel>
  }

  export type DailyRewardsRecordOrderByRelevanceInput = {
    fields: DailyRewardsRecordOrderByRelevanceFieldEnum | DailyRewardsRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DailyRewardsRecordOpportunityIdTimestampCompoundUniqueInput = {
    opportunityId: string
    timestamp: bigint | number
  }

  export type DailyRewardsRecordCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type DailyRewardsRecordAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    total?: SortOrder
  }

  export type DailyRewardsRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type DailyRewardsRecordMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    total?: SortOrder
    opportunityId?: SortOrder
  }

  export type DailyRewardsRecordSumOrderByAggregateInput = {
    timestamp?: SortOrder
    total?: SortOrder
  }

  export type DailyRewardsRecordScalarRelationFilter = {
    is?: DailyRewardsRecordWhereInput
    isNot?: DailyRewardsRecordWhereInput
  }

  export type DailyRewardsBreakdownOrderByRelevanceInput = {
    fields: DailyRewardsBreakdownOrderByRelevanceFieldEnum | DailyRewardsBreakdownOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DailyRewardsBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    campaignId?: SortOrder
    dailyRewardsRecordId?: SortOrder
  }

  export type DailyRewardsBreakdownAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type DailyRewardsBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    campaignId?: SortOrder
    dailyRewardsRecordId?: SortOrder
  }

  export type DailyRewardsBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    campaignId?: SortOrder
    dailyRewardsRecordId?: SortOrder
  }

  export type DailyRewardsBreakdownSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CreatorNullableScalarRelationFilter = {
    is?: CreatorWhereInput | null
    isNot?: CreatorWhereInput | null
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    address?: SortOrder
    tags?: SortOrder
    creatorId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    address?: SortOrder
    creatorId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    address?: SortOrder
    creatorId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorOrderByRelevanceInput = {
    fields: CreatorOrderByRelevanceFieldEnum | CreatorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CreatorCountOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    rebateFee?: SortOrder
  }

  export type CreatorAvgOrderByAggregateInput = {
    rebateFee?: SortOrder
  }

  export type CreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    rebateFee?: SortOrder
  }

  export type CreatorMinOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    rebateFee?: SortOrder
  }

  export type CreatorSumOrderByAggregateInput = {
    rebateFee?: SortOrder
  }

  export type MerklRootScalarRelationFilter = {
    is?: MerklRootWhereInput
    isNot?: MerklRootWhereInput
  }

  export type RewardOrderByRelevanceInput = {
    fields: RewardOrderByRelevanceFieldEnum | RewardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RewardRootRecipientRewardTokenIdCompoundUniqueInput = {
    root: string
    recipient: string
    rewardTokenId: string
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    root?: SortOrder
    recipient?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    proofs?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    root?: SortOrder
    recipient?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    root?: SortOrder
    recipient?: SortOrder
    rewardTokenId?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
  }

  export type RewardScalarRelationFilter = {
    is?: RewardWhereInput
    isNot?: RewardWhereInput
  }

  export type RewardBreakdownOrderByRelevanceInput = {
    fields: RewardBreakdownOrderByRelevanceFieldEnum | RewardBreakdownOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RewardBreakdownRewardIdCampaignIdReasonCompoundUniqueInput = {
    rewardId: string
    campaignId: string
    reason: string
  }

  export type RewardBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    reason?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    rewardId?: SortOrder
    campaignId?: SortOrder
    subCampaignId?: SortOrder
  }

  export type RewardBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    reason?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    rewardId?: SortOrder
    campaignId?: SortOrder
    subCampaignId?: SortOrder
  }

  export type RewardBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    reason?: SortOrder
    amount?: SortOrder
    claimed?: SortOrder
    pending?: SortOrder
    rewardId?: SortOrder
    campaignId?: SortOrder
    subCampaignId?: SortOrder
  }

  export type MerklRootOrderByRelevanceInput = {
    fields: MerklRootOrderByRelevanceFieldEnum | MerklRootOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MerklRootCountOrderByAggregateInput = {
    root?: SortOrder
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
  }

  export type MerklRootAvgOrderByAggregateInput = {
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
  }

  export type MerklRootMaxOrderByAggregateInput = {
    root?: SortOrder
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
  }

  export type MerklRootMinOrderByAggregateInput = {
    root?: SortOrder
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
  }

  export type MerklRootSumOrderByAggregateInput = {
    chainId?: SortOrder
    epoch?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumPriceSourceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceSourceMethod | EnumPriceSourceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceSourceMethodFilter<$PrismaModel> | $Enums.PriceSourceMethod
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PriceSourceOrderByRelevanceInput = {
    fields: PriceSourceOrderByRelevanceFieldEnum | PriceSourceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PriceSourceCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    method?: SortOrder
    args?: SortOrder
  }

  export type PriceSourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PriceSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    method?: SortOrder
  }

  export type PriceSourceMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    method?: SortOrder
  }

  export type PriceSourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPriceSourceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceSourceMethod | EnumPriceSourceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceSourceMethodWithAggregatesFilter<$PrismaModel> | $Enums.PriceSourceMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceSourceMethodFilter<$PrismaModel>
    _max?: NestedEnumPriceSourceMethodFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BlacklistOrderByRelevanceInput = {
    fields: BlacklistOrderByRelevanceFieldEnum | BlacklistOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BlacklistChainIdUserAddressPoolAddressCompoundUniqueInput = {
    chainId: number
    userAddress: string
    poolAddress: string
  }

  export type BlacklistCountOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    poolAddress?: SortOrder
    userAddress?: SortOrder
    arrestTimestamp?: SortOrder
    arrestDetails?: SortOrder
  }

  export type BlacklistAvgOrderByAggregateInput = {
    chainId?: SortOrder
    arrestTimestamp?: SortOrder
  }

  export type BlacklistMaxOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    poolAddress?: SortOrder
    userAddress?: SortOrder
    arrestTimestamp?: SortOrder
  }

  export type BlacklistMinOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    poolAddress?: SortOrder
    userAddress?: SortOrder
    arrestTimestamp?: SortOrder
  }

  export type BlacklistSumOrderByAggregateInput = {
    chainId?: SortOrder
    arrestTimestamp?: SortOrder
  }

  export type DumpOrderByRelevanceInput = {
    fields: DumpOrderByRelevanceFieldEnum | DumpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DumpChainIdFromTokenIdToTokenIdTimestampCompoundUniqueInput = {
    chainId: number
    fromTokenId: string
    toTokenId: string
    timestamp: number
  }

  export type DumpCountOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    fromTokenId?: SortOrder
    toTokenId?: SortOrder
    multisig?: SortOrder
    recipient?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    datetime?: SortOrder
    timestamp?: SortOrder
  }

  export type DumpAvgOrderByAggregateInput = {
    chainId?: SortOrder
    timestamp?: SortOrder
  }

  export type DumpMaxOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    fromTokenId?: SortOrder
    toTokenId?: SortOrder
    multisig?: SortOrder
    recipient?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    datetime?: SortOrder
    timestamp?: SortOrder
  }

  export type DumpMinOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    fromTokenId?: SortOrder
    toTokenId?: SortOrder
    multisig?: SortOrder
    recipient?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    datetime?: SortOrder
    timestamp?: SortOrder
  }

  export type DumpSumOrderByAggregateInput = {
    chainId?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumLoggedEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoggedEntityType | EnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoggedEntityTypeFilter<$PrismaModel> | $Enums.LoggedEntityType
  }

  export type LoggedOrderByRelevanceInput = {
    fields: LoggedOrderByRelevanceFieldEnum | LoggedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LoggedChainIdAddressCompoundUniqueInput = {
    chainId: number
    address: string
  }

  export type LoggedCountOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    fetchAtBlock?: SortOrder
    caughtFromAddress?: SortOrder
    entityData?: SortOrder
  }

  export type LoggedAvgOrderByAggregateInput = {
    chainId?: SortOrder
    fetchAtBlock?: SortOrder
  }

  export type LoggedMaxOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    fetchAtBlock?: SortOrder
    caughtFromAddress?: SortOrder
  }

  export type LoggedMinOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    type?: SortOrder
    address?: SortOrder
    fetchAtBlock?: SortOrder
    caughtFromAddress?: SortOrder
  }

  export type LoggedSumOrderByAggregateInput = {
    chainId?: SortOrder
    fetchAtBlock?: SortOrder
  }

  export type EnumLoggedEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoggedEntityType | EnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoggedEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoggedEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoggedEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumLoggedEntityTypeFilter<$PrismaModel>
  }

  export type CampaignCreatemanualOverridesInput = {
    set: $Enums.CampaignManualOverride[]
  }

  export type ChainCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ChainCreateWithoutCampaignsInput, ChainUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ChainCreateOrConnectWithoutCampaignsInput
    connect?: ChainWhereUniqueInput
  }

  export type ChainCreateNestedOneWithoutDistributionInput = {
    create?: XOR<ChainCreateWithoutDistributionInput, ChainUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: ChainCreateOrConnectWithoutDistributionInput
    connect?: ChainWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<TokenCreateWithoutCampaignsInput, TokenUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutCampaignsInput
    connect?: TokenWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<OpportunityCreateWithoutCampaignsInput, OpportunityUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutCampaignsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type RewardBreakdownCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput> | RewardBreakdownCreateWithoutCampaignInput[] | RewardBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutCampaignInput | RewardBreakdownCreateOrConnectWithoutCampaignInput[]
    createMany?: RewardBreakdownCreateManyCampaignInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput> | DailyRewardsBreakdownCreateWithoutCampaignInput[] | DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput | DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput[]
    createMany?: DailyRewardsBreakdownCreateManyCampaignInputEnvelope
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCampaignsCreatedInput = {
    create?: XOR<UserCreateWithoutCampaignsCreatedInput, UserUncheckedCreateWithoutCampaignsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignStatusCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput> | CampaignStatusCreateWithoutCampaignInput[] | CampaignStatusUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignStatusCreateOrConnectWithoutCampaignInput | CampaignStatusCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignStatusCreateManyCampaignInputEnvelope
    connect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
  }

  export type CampaignComputedValueCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput> | CampaignComputedValueCreateWithoutCampaignInput[] | CampaignComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignComputedValueCreateOrConnectWithoutCampaignInput | CampaignComputedValueCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignComputedValueCreateManyCampaignInputEnvelope
    connect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
  }

  export type UserComputedValueCreateNestedManyWithoutCampaignInput = {
    create?: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput> | UserComputedValueCreateWithoutCampaignInput[] | UserComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutCampaignInput | UserComputedValueCreateOrConnectWithoutCampaignInput[]
    createMany?: UserComputedValueCreateManyCampaignInputEnvelope
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
  }

  export type CampaignCreateNestedOneWithoutSubCampaignsInput = {
    create?: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubCampaignsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutRootCampaignInput = {
    create?: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput> | CampaignCreateWithoutRootCampaignInput[] | CampaignUncheckedCreateWithoutRootCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRootCampaignInput | CampaignCreateOrConnectWithoutRootCampaignInput[]
    createMany?: CampaignCreateManyRootCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignCreateNestedOneWithoutChildCampaignsInput = {
    create?: XOR<CampaignCreateWithoutChildCampaignsInput, CampaignUncheckedCreateWithoutChildCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChildCampaignsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutParentCampaignInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type RewardBreakdownCreateNestedManyWithoutSubCampaignInput = {
    create?: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput> | RewardBreakdownCreateWithoutSubCampaignInput[] | RewardBreakdownUncheckedCreateWithoutSubCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutSubCampaignInput | RewardBreakdownCreateOrConnectWithoutSubCampaignInput[]
    createMany?: RewardBreakdownCreateManySubCampaignInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput> | RewardBreakdownCreateWithoutCampaignInput[] | RewardBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutCampaignInput | RewardBreakdownCreateOrConnectWithoutCampaignInput[]
    createMany?: RewardBreakdownCreateManyCampaignInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput> | DailyRewardsBreakdownCreateWithoutCampaignInput[] | DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput | DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput[]
    createMany?: DailyRewardsBreakdownCreateManyCampaignInputEnvelope
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
  }

  export type CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput> | CampaignStatusCreateWithoutCampaignInput[] | CampaignStatusUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignStatusCreateOrConnectWithoutCampaignInput | CampaignStatusCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignStatusCreateManyCampaignInputEnvelope
    connect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
  }

  export type CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput> | CampaignComputedValueCreateWithoutCampaignInput[] | CampaignComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignComputedValueCreateOrConnectWithoutCampaignInput | CampaignComputedValueCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignComputedValueCreateManyCampaignInputEnvelope
    connect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
  }

  export type UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput> | UserComputedValueCreateWithoutCampaignInput[] | UserComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutCampaignInput | UserComputedValueCreateOrConnectWithoutCampaignInput[]
    createMany?: UserComputedValueCreateManyCampaignInputEnvelope
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutRootCampaignInput = {
    create?: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput> | CampaignCreateWithoutRootCampaignInput[] | CampaignUncheckedCreateWithoutRootCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRootCampaignInput | CampaignCreateOrConnectWithoutRootCampaignInput[]
    createMany?: CampaignCreateManyRootCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutParentCampaignInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput = {
    create?: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput> | RewardBreakdownCreateWithoutSubCampaignInput[] | RewardBreakdownUncheckedCreateWithoutSubCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutSubCampaignInput | RewardBreakdownCreateOrConnectWithoutSubCampaignInput[]
    createMany?: RewardBreakdownCreateManySubCampaignInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumDistributionTypeFieldUpdateOperationsInput = {
    set?: $Enums.DistributionType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CampaignUpdatemanualOverridesInput = {
    set?: $Enums.CampaignManualOverride[]
    push?: $Enums.CampaignManualOverride | $Enums.CampaignManualOverride[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ChainUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ChainCreateWithoutCampaignsInput, ChainUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ChainCreateOrConnectWithoutCampaignsInput
    upsert?: ChainUpsertWithoutCampaignsInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutCampaignsInput, ChainUpdateWithoutCampaignsInput>, ChainUncheckedUpdateWithoutCampaignsInput>
  }

  export type ChainUpdateOneRequiredWithoutDistributionNestedInput = {
    create?: XOR<ChainCreateWithoutDistributionInput, ChainUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: ChainCreateOrConnectWithoutDistributionInput
    upsert?: ChainUpsertWithoutDistributionInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutDistributionInput, ChainUpdateWithoutDistributionInput>, ChainUncheckedUpdateWithoutDistributionInput>
  }

  export type TokenUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<TokenCreateWithoutCampaignsInput, TokenUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutCampaignsInput
    upsert?: TokenUpsertWithoutCampaignsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutCampaignsInput, TokenUpdateWithoutCampaignsInput>, TokenUncheckedUpdateWithoutCampaignsInput>
  }

  export type OpportunityUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<OpportunityCreateWithoutCampaignsInput, OpportunityUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutCampaignsInput
    upsert?: OpportunityUpsertWithoutCampaignsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutCampaignsInput, OpportunityUpdateWithoutCampaignsInput>, OpportunityUncheckedUpdateWithoutCampaignsInput>
  }

  export type RewardBreakdownUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput> | RewardBreakdownCreateWithoutCampaignInput[] | RewardBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutCampaignInput | RewardBreakdownCreateOrConnectWithoutCampaignInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutCampaignInput | RewardBreakdownUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RewardBreakdownCreateManyCampaignInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutCampaignInput | RewardBreakdownUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutCampaignInput | RewardBreakdownUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput> | DailyRewardsBreakdownCreateWithoutCampaignInput[] | DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput | DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput[]
    upsert?: DailyRewardsBreakdownUpsertWithWhereUniqueWithoutCampaignInput | DailyRewardsBreakdownUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DailyRewardsBreakdownCreateManyCampaignInputEnvelope
    set?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    disconnect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    delete?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    update?: DailyRewardsBreakdownUpdateWithWhereUniqueWithoutCampaignInput | DailyRewardsBreakdownUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DailyRewardsBreakdownUpdateManyWithWhereWithoutCampaignInput | DailyRewardsBreakdownUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsCreatedInput, UserUncheckedCreateWithoutCampaignsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsCreatedInput
    upsert?: UserUpsertWithoutCampaignsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsCreatedInput, UserUpdateWithoutCampaignsCreatedInput>, UserUncheckedUpdateWithoutCampaignsCreatedInput>
  }

  export type CampaignStatusUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput> | CampaignStatusCreateWithoutCampaignInput[] | CampaignStatusUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignStatusCreateOrConnectWithoutCampaignInput | CampaignStatusCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignStatusUpsertWithWhereUniqueWithoutCampaignInput | CampaignStatusUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignStatusCreateManyCampaignInputEnvelope
    set?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    disconnect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    delete?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    connect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    update?: CampaignStatusUpdateWithWhereUniqueWithoutCampaignInput | CampaignStatusUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignStatusUpdateManyWithWhereWithoutCampaignInput | CampaignStatusUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignStatusScalarWhereInput | CampaignStatusScalarWhereInput[]
  }

  export type CampaignComputedValueUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput> | CampaignComputedValueCreateWithoutCampaignInput[] | CampaignComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignComputedValueCreateOrConnectWithoutCampaignInput | CampaignComputedValueCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignComputedValueUpsertWithWhereUniqueWithoutCampaignInput | CampaignComputedValueUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignComputedValueCreateManyCampaignInputEnvelope
    set?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    disconnect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    delete?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    connect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    update?: CampaignComputedValueUpdateWithWhereUniqueWithoutCampaignInput | CampaignComputedValueUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignComputedValueUpdateManyWithWhereWithoutCampaignInput | CampaignComputedValueUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignComputedValueScalarWhereInput | CampaignComputedValueScalarWhereInput[]
  }

  export type UserComputedValueUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput> | UserComputedValueCreateWithoutCampaignInput[] | UserComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutCampaignInput | UserComputedValueCreateOrConnectWithoutCampaignInput[]
    upsert?: UserComputedValueUpsertWithWhereUniqueWithoutCampaignInput | UserComputedValueUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: UserComputedValueCreateManyCampaignInputEnvelope
    set?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    disconnect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    delete?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    update?: UserComputedValueUpdateWithWhereUniqueWithoutCampaignInput | UserComputedValueUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: UserComputedValueUpdateManyWithWhereWithoutCampaignInput | UserComputedValueUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
  }

  export type CampaignUpdateOneWithoutSubCampaignsNestedInput = {
    create?: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubCampaignsInput
    upsert?: CampaignUpsertWithoutSubCampaignsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSubCampaignsInput, CampaignUpdateWithoutSubCampaignsInput>, CampaignUncheckedUpdateWithoutSubCampaignsInput>
  }

  export type CampaignUpdateManyWithoutRootCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput> | CampaignCreateWithoutRootCampaignInput[] | CampaignUncheckedCreateWithoutRootCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRootCampaignInput | CampaignCreateOrConnectWithoutRootCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutRootCampaignInput | CampaignUpsertWithWhereUniqueWithoutRootCampaignInput[]
    createMany?: CampaignCreateManyRootCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutRootCampaignInput | CampaignUpdateWithWhereUniqueWithoutRootCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutRootCampaignInput | CampaignUpdateManyWithWhereWithoutRootCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUpdateOneWithoutChildCampaignsNestedInput = {
    create?: XOR<CampaignCreateWithoutChildCampaignsInput, CampaignUncheckedCreateWithoutChildCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChildCampaignsInput
    upsert?: CampaignUpsertWithoutChildCampaignsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutChildCampaignsInput, CampaignUpdateWithoutChildCampaignsInput>, CampaignUncheckedUpdateWithoutChildCampaignsInput>
  }

  export type CampaignUpdateManyWithoutParentCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentCampaignInput | CampaignUpsertWithWhereUniqueWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentCampaignInput | CampaignUpdateWithWhereUniqueWithoutParentCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentCampaignInput | CampaignUpdateManyWithWhereWithoutParentCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type RewardBreakdownUpdateManyWithoutSubCampaignNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput> | RewardBreakdownCreateWithoutSubCampaignInput[] | RewardBreakdownUncheckedCreateWithoutSubCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutSubCampaignInput | RewardBreakdownCreateOrConnectWithoutSubCampaignInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutSubCampaignInput | RewardBreakdownUpsertWithWhereUniqueWithoutSubCampaignInput[]
    createMany?: RewardBreakdownCreateManySubCampaignInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutSubCampaignInput | RewardBreakdownUpdateWithWhereUniqueWithoutSubCampaignInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutSubCampaignInput | RewardBreakdownUpdateManyWithWhereWithoutSubCampaignInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput> | RewardBreakdownCreateWithoutCampaignInput[] | RewardBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutCampaignInput | RewardBreakdownCreateOrConnectWithoutCampaignInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutCampaignInput | RewardBreakdownUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RewardBreakdownCreateManyCampaignInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutCampaignInput | RewardBreakdownUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutCampaignInput | RewardBreakdownUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput> | DailyRewardsBreakdownCreateWithoutCampaignInput[] | DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput | DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput[]
    upsert?: DailyRewardsBreakdownUpsertWithWhereUniqueWithoutCampaignInput | DailyRewardsBreakdownUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DailyRewardsBreakdownCreateManyCampaignInputEnvelope
    set?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    disconnect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    delete?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    update?: DailyRewardsBreakdownUpdateWithWhereUniqueWithoutCampaignInput | DailyRewardsBreakdownUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DailyRewardsBreakdownUpdateManyWithWhereWithoutCampaignInput | DailyRewardsBreakdownUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
  }

  export type CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput> | CampaignStatusCreateWithoutCampaignInput[] | CampaignStatusUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignStatusCreateOrConnectWithoutCampaignInput | CampaignStatusCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignStatusUpsertWithWhereUniqueWithoutCampaignInput | CampaignStatusUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignStatusCreateManyCampaignInputEnvelope
    set?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    disconnect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    delete?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    connect?: CampaignStatusWhereUniqueInput | CampaignStatusWhereUniqueInput[]
    update?: CampaignStatusUpdateWithWhereUniqueWithoutCampaignInput | CampaignStatusUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignStatusUpdateManyWithWhereWithoutCampaignInput | CampaignStatusUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignStatusScalarWhereInput | CampaignStatusScalarWhereInput[]
  }

  export type CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput> | CampaignComputedValueCreateWithoutCampaignInput[] | CampaignComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignComputedValueCreateOrConnectWithoutCampaignInput | CampaignComputedValueCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignComputedValueUpsertWithWhereUniqueWithoutCampaignInput | CampaignComputedValueUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignComputedValueCreateManyCampaignInputEnvelope
    set?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    disconnect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    delete?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    connect?: CampaignComputedValueWhereUniqueInput | CampaignComputedValueWhereUniqueInput[]
    update?: CampaignComputedValueUpdateWithWhereUniqueWithoutCampaignInput | CampaignComputedValueUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignComputedValueUpdateManyWithWhereWithoutCampaignInput | CampaignComputedValueUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignComputedValueScalarWhereInput | CampaignComputedValueScalarWhereInput[]
  }

  export type UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput> | UserComputedValueCreateWithoutCampaignInput[] | UserComputedValueUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutCampaignInput | UserComputedValueCreateOrConnectWithoutCampaignInput[]
    upsert?: UserComputedValueUpsertWithWhereUniqueWithoutCampaignInput | UserComputedValueUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: UserComputedValueCreateManyCampaignInputEnvelope
    set?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    disconnect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    delete?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    update?: UserComputedValueUpdateWithWhereUniqueWithoutCampaignInput | UserComputedValueUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: UserComputedValueUpdateManyWithWhereWithoutCampaignInput | UserComputedValueUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput> | CampaignCreateWithoutRootCampaignInput[] | CampaignUncheckedCreateWithoutRootCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRootCampaignInput | CampaignCreateOrConnectWithoutRootCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutRootCampaignInput | CampaignUpsertWithWhereUniqueWithoutRootCampaignInput[]
    createMany?: CampaignCreateManyRootCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutRootCampaignInput | CampaignUpdateWithWhereUniqueWithoutRootCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutRootCampaignInput | CampaignUpdateManyWithWhereWithoutRootCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentCampaignInput | CampaignUpsertWithWhereUniqueWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentCampaignInput | CampaignUpdateWithWhereUniqueWithoutParentCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentCampaignInput | CampaignUpdateManyWithWhereWithoutParentCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput> | RewardBreakdownCreateWithoutSubCampaignInput[] | RewardBreakdownUncheckedCreateWithoutSubCampaignInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutSubCampaignInput | RewardBreakdownCreateOrConnectWithoutSubCampaignInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutSubCampaignInput | RewardBreakdownUpsertWithWhereUniqueWithoutSubCampaignInput[]
    createMany?: RewardBreakdownCreateManySubCampaignInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutSubCampaignInput | RewardBreakdownUpdateWithWhereUniqueWithoutSubCampaignInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutSubCampaignInput | RewardBreakdownUpdateManyWithWhereWithoutSubCampaignInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutCampaignStatusInput = {
    create?: XOR<CampaignCreateWithoutCampaignStatusInput, CampaignUncheckedCreateWithoutCampaignStatusInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignStatusInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumRunStatusFieldUpdateOperationsInput = {
    set?: $Enums.RunStatus
  }

  export type CampaignUpdateOneRequiredWithoutCampaignStatusNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignStatusInput, CampaignUncheckedCreateWithoutCampaignStatusInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignStatusInput
    upsert?: CampaignUpsertWithoutCampaignStatusInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignStatusInput, CampaignUpdateWithoutCampaignStatusInput>, CampaignUncheckedUpdateWithoutCampaignStatusInput>
  }

  export type CampaignCreateNestedOneWithoutCampaignEngineValuesInput = {
    create?: XOR<CampaignCreateWithoutCampaignEngineValuesInput, CampaignUncheckedCreateWithoutCampaignEngineValuesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignEngineValuesInput
    connect?: CampaignWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutCampaignEngineValuesNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignEngineValuesInput, CampaignUncheckedCreateWithoutCampaignEngineValuesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignEngineValuesInput
    upsert?: CampaignUpsertWithoutCampaignEngineValuesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignEngineValuesInput, CampaignUpdateWithoutCampaignEngineValuesInput>, CampaignUncheckedUpdateWithoutCampaignEngineValuesInput>
  }

  export type CampaignCreateNestedOneWithoutUserComputedValueInput = {
    create?: XOR<CampaignCreateWithoutUserComputedValueInput, CampaignUncheckedCreateWithoutUserComputedValueInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutUserComputedValueInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserComputedValueInput = {
    create?: XOR<UserCreateWithoutUserComputedValueInput, UserUncheckedCreateWithoutUserComputedValueInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserComputedValueInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutUserComputedValueNestedInput = {
    create?: XOR<CampaignCreateWithoutUserComputedValueInput, CampaignUncheckedCreateWithoutUserComputedValueInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutUserComputedValueInput
    upsert?: CampaignUpsertWithoutUserComputedValueInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutUserComputedValueInput, CampaignUpdateWithoutUserComputedValueInput>, CampaignUncheckedUpdateWithoutUserComputedValueInput>
  }

  export type UserUpdateOneWithoutUserComputedValueNestedInput = {
    create?: XOR<UserCreateWithoutUserComputedValueInput, UserUncheckedCreateWithoutUserComputedValueInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserComputedValueInput
    upsert?: UserUpsertWithoutUserComputedValueInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserComputedValueInput, UserUpdateWithoutUserComputedValueInput>, UserUncheckedUpdateWithoutUserComputedValueInput>
  }

  export type ExplorerCreateNestedManyWithoutChainInput = {
    create?: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput> | ExplorerCreateWithoutChainInput[] | ExplorerUncheckedCreateWithoutChainInput[]
    connectOrCreate?: ExplorerCreateOrConnectWithoutChainInput | ExplorerCreateOrConnectWithoutChainInput[]
    createMany?: ExplorerCreateManyChainInputEnvelope
    connect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutComputeChainInput = {
    create?: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput> | CampaignCreateWithoutComputeChainInput[] | CampaignUncheckedCreateWithoutComputeChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutComputeChainInput | CampaignCreateOrConnectWithoutComputeChainInput[]
    createMany?: CampaignCreateManyComputeChainInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutDistributionChainInput = {
    create?: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput> | CampaignCreateWithoutDistributionChainInput[] | CampaignUncheckedCreateWithoutDistributionChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionChainInput | CampaignCreateOrConnectWithoutDistributionChainInput[]
    createMany?: CampaignCreateManyDistributionChainInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutChainInput = {
    create?: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput> | TokenCreateWithoutChainInput[] | TokenUncheckedCreateWithoutChainInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutChainInput | TokenCreateOrConnectWithoutChainInput[]
    createMany?: TokenCreateManyChainInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutChainInput = {
    create?: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput> | OpportunityCreateWithoutChainInput[] | OpportunityUncheckedCreateWithoutChainInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutChainInput | OpportunityCreateOrConnectWithoutChainInput[]
    createMany?: OpportunityCreateManyChainInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type MerklRootCreateNestedManyWithoutChainInput = {
    create?: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput> | MerklRootCreateWithoutChainInput[] | MerklRootUncheckedCreateWithoutChainInput[]
    connectOrCreate?: MerklRootCreateOrConnectWithoutChainInput | MerklRootCreateOrConnectWithoutChainInput[]
    createMany?: MerklRootCreateManyChainInputEnvelope
    connect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
  }

  export type BlacklistCreateNestedManyWithoutChainInput = {
    create?: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput> | BlacklistCreateWithoutChainInput[] | BlacklistUncheckedCreateWithoutChainInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutChainInput | BlacklistCreateOrConnectWithoutChainInput[]
    createMany?: BlacklistCreateManyChainInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type DumpCreateNestedManyWithoutChainInput = {
    create?: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput> | DumpCreateWithoutChainInput[] | DumpUncheckedCreateWithoutChainInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutChainInput | DumpCreateOrConnectWithoutChainInput[]
    createMany?: DumpCreateManyChainInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type ExplorerUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput> | ExplorerCreateWithoutChainInput[] | ExplorerUncheckedCreateWithoutChainInput[]
    connectOrCreate?: ExplorerCreateOrConnectWithoutChainInput | ExplorerCreateOrConnectWithoutChainInput[]
    createMany?: ExplorerCreateManyChainInputEnvelope
    connect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutComputeChainInput = {
    create?: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput> | CampaignCreateWithoutComputeChainInput[] | CampaignUncheckedCreateWithoutComputeChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutComputeChainInput | CampaignCreateOrConnectWithoutComputeChainInput[]
    createMany?: CampaignCreateManyComputeChainInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutDistributionChainInput = {
    create?: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput> | CampaignCreateWithoutDistributionChainInput[] | CampaignUncheckedCreateWithoutDistributionChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionChainInput | CampaignCreateOrConnectWithoutDistributionChainInput[]
    createMany?: CampaignCreateManyDistributionChainInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput> | TokenCreateWithoutChainInput[] | TokenUncheckedCreateWithoutChainInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutChainInput | TokenCreateOrConnectWithoutChainInput[]
    createMany?: TokenCreateManyChainInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput> | OpportunityCreateWithoutChainInput[] | OpportunityUncheckedCreateWithoutChainInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutChainInput | OpportunityCreateOrConnectWithoutChainInput[]
    createMany?: OpportunityCreateManyChainInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type MerklRootUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput> | MerklRootCreateWithoutChainInput[] | MerklRootUncheckedCreateWithoutChainInput[]
    connectOrCreate?: MerklRootCreateOrConnectWithoutChainInput | MerklRootCreateOrConnectWithoutChainInput[]
    createMany?: MerklRootCreateManyChainInputEnvelope
    connect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
  }

  export type BlacklistUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput> | BlacklistCreateWithoutChainInput[] | BlacklistUncheckedCreateWithoutChainInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutChainInput | BlacklistCreateOrConnectWithoutChainInput[]
    createMany?: BlacklistCreateManyChainInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type DumpUncheckedCreateNestedManyWithoutChainInput = {
    create?: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput> | DumpCreateWithoutChainInput[] | DumpUncheckedCreateWithoutChainInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutChainInput | DumpCreateOrConnectWithoutChainInput[]
    createMany?: DumpCreateManyChainInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type ExplorerUpdateManyWithoutChainNestedInput = {
    create?: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput> | ExplorerCreateWithoutChainInput[] | ExplorerUncheckedCreateWithoutChainInput[]
    connectOrCreate?: ExplorerCreateOrConnectWithoutChainInput | ExplorerCreateOrConnectWithoutChainInput[]
    upsert?: ExplorerUpsertWithWhereUniqueWithoutChainInput | ExplorerUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: ExplorerCreateManyChainInputEnvelope
    set?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    disconnect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    delete?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    connect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    update?: ExplorerUpdateWithWhereUniqueWithoutChainInput | ExplorerUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: ExplorerUpdateManyWithWhereWithoutChainInput | ExplorerUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: ExplorerScalarWhereInput | ExplorerScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutComputeChainNestedInput = {
    create?: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput> | CampaignCreateWithoutComputeChainInput[] | CampaignUncheckedCreateWithoutComputeChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutComputeChainInput | CampaignCreateOrConnectWithoutComputeChainInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutComputeChainInput | CampaignUpsertWithWhereUniqueWithoutComputeChainInput[]
    createMany?: CampaignCreateManyComputeChainInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutComputeChainInput | CampaignUpdateWithWhereUniqueWithoutComputeChainInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutComputeChainInput | CampaignUpdateManyWithWhereWithoutComputeChainInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutDistributionChainNestedInput = {
    create?: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput> | CampaignCreateWithoutDistributionChainInput[] | CampaignUncheckedCreateWithoutDistributionChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionChainInput | CampaignCreateOrConnectWithoutDistributionChainInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutDistributionChainInput | CampaignUpsertWithWhereUniqueWithoutDistributionChainInput[]
    createMany?: CampaignCreateManyDistributionChainInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutDistributionChainInput | CampaignUpdateWithWhereUniqueWithoutDistributionChainInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutDistributionChainInput | CampaignUpdateManyWithWhereWithoutDistributionChainInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutChainNestedInput = {
    create?: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput> | TokenCreateWithoutChainInput[] | TokenUncheckedCreateWithoutChainInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutChainInput | TokenCreateOrConnectWithoutChainInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutChainInput | TokenUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: TokenCreateManyChainInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutChainInput | TokenUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutChainInput | TokenUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutChainNestedInput = {
    create?: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput> | OpportunityCreateWithoutChainInput[] | OpportunityUncheckedCreateWithoutChainInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutChainInput | OpportunityCreateOrConnectWithoutChainInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutChainInput | OpportunityUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: OpportunityCreateManyChainInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutChainInput | OpportunityUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutChainInput | OpportunityUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type MerklRootUpdateManyWithoutChainNestedInput = {
    create?: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput> | MerklRootCreateWithoutChainInput[] | MerklRootUncheckedCreateWithoutChainInput[]
    connectOrCreate?: MerklRootCreateOrConnectWithoutChainInput | MerklRootCreateOrConnectWithoutChainInput[]
    upsert?: MerklRootUpsertWithWhereUniqueWithoutChainInput | MerklRootUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: MerklRootCreateManyChainInputEnvelope
    set?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    disconnect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    delete?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    connect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    update?: MerklRootUpdateWithWhereUniqueWithoutChainInput | MerklRootUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: MerklRootUpdateManyWithWhereWithoutChainInput | MerklRootUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: MerklRootScalarWhereInput | MerklRootScalarWhereInput[]
  }

  export type BlacklistUpdateManyWithoutChainNestedInput = {
    create?: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput> | BlacklistCreateWithoutChainInput[] | BlacklistUncheckedCreateWithoutChainInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutChainInput | BlacklistCreateOrConnectWithoutChainInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutChainInput | BlacklistUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: BlacklistCreateManyChainInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutChainInput | BlacklistUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutChainInput | BlacklistUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type DumpUpdateManyWithoutChainNestedInput = {
    create?: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput> | DumpCreateWithoutChainInput[] | DumpUncheckedCreateWithoutChainInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutChainInput | DumpCreateOrConnectWithoutChainInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutChainInput | DumpUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: DumpCreateManyChainInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutChainInput | DumpUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutChainInput | DumpUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type ExplorerUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput> | ExplorerCreateWithoutChainInput[] | ExplorerUncheckedCreateWithoutChainInput[]
    connectOrCreate?: ExplorerCreateOrConnectWithoutChainInput | ExplorerCreateOrConnectWithoutChainInput[]
    upsert?: ExplorerUpsertWithWhereUniqueWithoutChainInput | ExplorerUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: ExplorerCreateManyChainInputEnvelope
    set?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    disconnect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    delete?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    connect?: ExplorerWhereUniqueInput | ExplorerWhereUniqueInput[]
    update?: ExplorerUpdateWithWhereUniqueWithoutChainInput | ExplorerUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: ExplorerUpdateManyWithWhereWithoutChainInput | ExplorerUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: ExplorerScalarWhereInput | ExplorerScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutComputeChainNestedInput = {
    create?: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput> | CampaignCreateWithoutComputeChainInput[] | CampaignUncheckedCreateWithoutComputeChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutComputeChainInput | CampaignCreateOrConnectWithoutComputeChainInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutComputeChainInput | CampaignUpsertWithWhereUniqueWithoutComputeChainInput[]
    createMany?: CampaignCreateManyComputeChainInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutComputeChainInput | CampaignUpdateWithWhereUniqueWithoutComputeChainInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutComputeChainInput | CampaignUpdateManyWithWhereWithoutComputeChainInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput = {
    create?: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput> | CampaignCreateWithoutDistributionChainInput[] | CampaignUncheckedCreateWithoutDistributionChainInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutDistributionChainInput | CampaignCreateOrConnectWithoutDistributionChainInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutDistributionChainInput | CampaignUpsertWithWhereUniqueWithoutDistributionChainInput[]
    createMany?: CampaignCreateManyDistributionChainInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutDistributionChainInput | CampaignUpdateWithWhereUniqueWithoutDistributionChainInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutDistributionChainInput | CampaignUpdateManyWithWhereWithoutDistributionChainInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput> | TokenCreateWithoutChainInput[] | TokenUncheckedCreateWithoutChainInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutChainInput | TokenCreateOrConnectWithoutChainInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutChainInput | TokenUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: TokenCreateManyChainInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutChainInput | TokenUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutChainInput | TokenUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput> | OpportunityCreateWithoutChainInput[] | OpportunityUncheckedCreateWithoutChainInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutChainInput | OpportunityCreateOrConnectWithoutChainInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutChainInput | OpportunityUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: OpportunityCreateManyChainInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutChainInput | OpportunityUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutChainInput | OpportunityUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type MerklRootUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput> | MerklRootCreateWithoutChainInput[] | MerklRootUncheckedCreateWithoutChainInput[]
    connectOrCreate?: MerklRootCreateOrConnectWithoutChainInput | MerklRootCreateOrConnectWithoutChainInput[]
    upsert?: MerklRootUpsertWithWhereUniqueWithoutChainInput | MerklRootUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: MerklRootCreateManyChainInputEnvelope
    set?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    disconnect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    delete?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    connect?: MerklRootWhereUniqueInput | MerklRootWhereUniqueInput[]
    update?: MerklRootUpdateWithWhereUniqueWithoutChainInput | MerklRootUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: MerklRootUpdateManyWithWhereWithoutChainInput | MerklRootUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: MerklRootScalarWhereInput | MerklRootScalarWhereInput[]
  }

  export type BlacklistUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput> | BlacklistCreateWithoutChainInput[] | BlacklistUncheckedCreateWithoutChainInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutChainInput | BlacklistCreateOrConnectWithoutChainInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutChainInput | BlacklistUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: BlacklistCreateManyChainInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutChainInput | BlacklistUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutChainInput | BlacklistUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type DumpUncheckedUpdateManyWithoutChainNestedInput = {
    create?: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput> | DumpCreateWithoutChainInput[] | DumpUncheckedCreateWithoutChainInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutChainInput | DumpCreateOrConnectWithoutChainInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutChainInput | DumpUpsertWithWhereUniqueWithoutChainInput[]
    createMany?: DumpCreateManyChainInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutChainInput | DumpUpdateWithWhereUniqueWithoutChainInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutChainInput | DumpUpdateManyWithWhereWithoutChainInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type ChainCreateNestedOneWithoutExplorerInput = {
    create?: XOR<ChainCreateWithoutExplorerInput, ChainUncheckedCreateWithoutExplorerInput>
    connectOrCreate?: ChainCreateOrConnectWithoutExplorerInput
    connect?: ChainWhereUniqueInput
  }

  export type EnumExplorerTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExplorerType
  }

  export type ChainUpdateOneRequiredWithoutExplorerNestedInput = {
    create?: XOR<ChainCreateWithoutExplorerInput, ChainUncheckedCreateWithoutExplorerInput>
    connectOrCreate?: ChainCreateOrConnectWithoutExplorerInput
    upsert?: ChainUpsertWithoutExplorerInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutExplorerInput, ChainUpdateWithoutExplorerInput>, ChainUncheckedUpdateWithoutExplorerInput>
  }

  export type OpportunityCreatehowToStepsInput = {
    set: string[]
  }

  export type OpportunityCreatetagsInput = {
    set: string[]
  }

  export type OpportunityCreatemanualOverridesInput = {
    set: $Enums.OpportunityManualOverride[]
  }

  export type ChainCreateNestedOneWithoutOpportunityInput = {
    create?: XOR<ChainCreateWithoutOpportunityInput, ChainUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ChainCreateOrConnectWithoutOpportunityInput
    connect?: ChainWhereUniqueInput
  }

  export type TokenCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput> | TokenCreateWithoutOpportunityInput[] | TokenUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOpportunityInput | TokenCreateOrConnectWithoutOpportunityInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput> | CampaignCreateWithoutOpportunityInput[] | CampaignUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOpportunityInput | CampaignCreateOrConnectWithoutOpportunityInput[]
    createMany?: CampaignCreateManyOpportunityInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ProtocolCreateNestedManyWithoutOpportunitiesInput = {
    create?: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput> | ProtocolCreateWithoutOpportunitiesInput[] | ProtocolUncheckedCreateWithoutOpportunitiesInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOpportunitiesInput | ProtocolCreateOrConnectWithoutOpportunitiesInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type ProtocolCreateNestedOneWithoutMainOpportunitiesInput = {
    create?: XOR<ProtocolCreateWithoutMainOpportunitiesInput, ProtocolUncheckedCreateWithoutMainOpportunitiesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutMainOpportunitiesInput
    connect?: ProtocolWhereUniqueInput
  }

  export type TVLRecordCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput> | TVLRecordCreateWithoutOpportunityInput[] | TVLRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TVLRecordCreateOrConnectWithoutOpportunityInput | TVLRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: TVLRecordCreateManyOpportunityInputEnvelope
    connect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
  }

  export type AprRecordCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput> | AprRecordCreateWithoutOpportunityInput[] | AprRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: AprRecordCreateOrConnectWithoutOpportunityInput | AprRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: AprRecordCreateManyOpportunityInputEnvelope
    connect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
  }

  export type DailyRewardsRecordCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput> | DailyRewardsRecordCreateWithoutOpportunityInput[] | DailyRewardsRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutOpportunityInput | DailyRewardsRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: DailyRewardsRecordCreateManyOpportunityInputEnvelope
    connect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput> | TokenCreateWithoutOpportunityInput[] | TokenUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOpportunityInput | TokenCreateOrConnectWithoutOpportunityInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput> | CampaignCreateWithoutOpportunityInput[] | CampaignUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOpportunityInput | CampaignCreateOrConnectWithoutOpportunityInput[]
    createMany?: CampaignCreateManyOpportunityInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput = {
    create?: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput> | ProtocolCreateWithoutOpportunitiesInput[] | ProtocolUncheckedCreateWithoutOpportunitiesInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOpportunitiesInput | ProtocolCreateOrConnectWithoutOpportunitiesInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput> | TVLRecordCreateWithoutOpportunityInput[] | TVLRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TVLRecordCreateOrConnectWithoutOpportunityInput | TVLRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: TVLRecordCreateManyOpportunityInputEnvelope
    connect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
  }

  export type AprRecordUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput> | AprRecordCreateWithoutOpportunityInput[] | AprRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: AprRecordCreateOrConnectWithoutOpportunityInput | AprRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: AprRecordCreateManyOpportunityInputEnvelope
    connect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
  }

  export type DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput> | DailyRewardsRecordCreateWithoutOpportunityInput[] | DailyRewardsRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutOpportunityInput | DailyRewardsRecordCreateOrConnectWithoutOpportunityInput[]
    createMany?: DailyRewardsRecordCreateManyOpportunityInputEnvelope
    connect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
  }

  export type OpportunityUpdatehowToStepsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type EnumOpportunityActionFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityAction
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OpportunityUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OpportunityUpdatemanualOverridesInput = {
    set?: $Enums.OpportunityManualOverride[]
    push?: $Enums.OpportunityManualOverride | $Enums.OpportunityManualOverride[]
  }

  export type ChainUpdateOneRequiredWithoutOpportunityNestedInput = {
    create?: XOR<ChainCreateWithoutOpportunityInput, ChainUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: ChainCreateOrConnectWithoutOpportunityInput
    upsert?: ChainUpsertWithoutOpportunityInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutOpportunityInput, ChainUpdateWithoutOpportunityInput>, ChainUncheckedUpdateWithoutOpportunityInput>
  }

  export type TokenUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput> | TokenCreateWithoutOpportunityInput[] | TokenUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOpportunityInput | TokenCreateOrConnectWithoutOpportunityInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutOpportunityInput | TokenUpsertWithWhereUniqueWithoutOpportunityInput[]
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutOpportunityInput | TokenUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutOpportunityInput | TokenUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput> | CampaignCreateWithoutOpportunityInput[] | CampaignUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOpportunityInput | CampaignCreateOrConnectWithoutOpportunityInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutOpportunityInput | CampaignUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CampaignCreateManyOpportunityInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutOpportunityInput | CampaignUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutOpportunityInput | CampaignUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ProtocolUpdateManyWithoutOpportunitiesNestedInput = {
    create?: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput> | ProtocolCreateWithoutOpportunitiesInput[] | ProtocolUncheckedCreateWithoutOpportunitiesInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOpportunitiesInput | ProtocolCreateOrConnectWithoutOpportunitiesInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutOpportunitiesInput | ProtocolUpsertWithWhereUniqueWithoutOpportunitiesInput[]
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutOpportunitiesInput | ProtocolUpdateWithWhereUniqueWithoutOpportunitiesInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutOpportunitiesInput | ProtocolUpdateManyWithWhereWithoutOpportunitiesInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type ProtocolUpdateOneWithoutMainOpportunitiesNestedInput = {
    create?: XOR<ProtocolCreateWithoutMainOpportunitiesInput, ProtocolUncheckedCreateWithoutMainOpportunitiesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutMainOpportunitiesInput
    upsert?: ProtocolUpsertWithoutMainOpportunitiesInput
    disconnect?: ProtocolWhereInput | boolean
    delete?: ProtocolWhereInput | boolean
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutMainOpportunitiesInput, ProtocolUpdateWithoutMainOpportunitiesInput>, ProtocolUncheckedUpdateWithoutMainOpportunitiesInput>
  }

  export type TVLRecordUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput> | TVLRecordCreateWithoutOpportunityInput[] | TVLRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TVLRecordCreateOrConnectWithoutOpportunityInput | TVLRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: TVLRecordUpsertWithWhereUniqueWithoutOpportunityInput | TVLRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: TVLRecordCreateManyOpportunityInputEnvelope
    set?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    disconnect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    delete?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    connect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    update?: TVLRecordUpdateWithWhereUniqueWithoutOpportunityInput | TVLRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: TVLRecordUpdateManyWithWhereWithoutOpportunityInput | TVLRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: TVLRecordScalarWhereInput | TVLRecordScalarWhereInput[]
  }

  export type AprRecordUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput> | AprRecordCreateWithoutOpportunityInput[] | AprRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: AprRecordCreateOrConnectWithoutOpportunityInput | AprRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: AprRecordUpsertWithWhereUniqueWithoutOpportunityInput | AprRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: AprRecordCreateManyOpportunityInputEnvelope
    set?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    disconnect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    delete?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    connect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    update?: AprRecordUpdateWithWhereUniqueWithoutOpportunityInput | AprRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: AprRecordUpdateManyWithWhereWithoutOpportunityInput | AprRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: AprRecordScalarWhereInput | AprRecordScalarWhereInput[]
  }

  export type DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput> | DailyRewardsRecordCreateWithoutOpportunityInput[] | DailyRewardsRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutOpportunityInput | DailyRewardsRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: DailyRewardsRecordUpsertWithWhereUniqueWithoutOpportunityInput | DailyRewardsRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: DailyRewardsRecordCreateManyOpportunityInputEnvelope
    set?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    disconnect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    delete?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    connect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    update?: DailyRewardsRecordUpdateWithWhereUniqueWithoutOpportunityInput | DailyRewardsRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: DailyRewardsRecordUpdateManyWithWhereWithoutOpportunityInput | DailyRewardsRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: DailyRewardsRecordScalarWhereInput | DailyRewardsRecordScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput> | TokenCreateWithoutOpportunityInput[] | TokenUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOpportunityInput | TokenCreateOrConnectWithoutOpportunityInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutOpportunityInput | TokenUpsertWithWhereUniqueWithoutOpportunityInput[]
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutOpportunityInput | TokenUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutOpportunityInput | TokenUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput> | CampaignCreateWithoutOpportunityInput[] | CampaignUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOpportunityInput | CampaignCreateOrConnectWithoutOpportunityInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutOpportunityInput | CampaignUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CampaignCreateManyOpportunityInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutOpportunityInput | CampaignUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutOpportunityInput | CampaignUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput = {
    create?: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput> | ProtocolCreateWithoutOpportunitiesInput[] | ProtocolUncheckedCreateWithoutOpportunitiesInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOpportunitiesInput | ProtocolCreateOrConnectWithoutOpportunitiesInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutOpportunitiesInput | ProtocolUpsertWithWhereUniqueWithoutOpportunitiesInput[]
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutOpportunitiesInput | ProtocolUpdateWithWhereUniqueWithoutOpportunitiesInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutOpportunitiesInput | ProtocolUpdateManyWithWhereWithoutOpportunitiesInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput> | TVLRecordCreateWithoutOpportunityInput[] | TVLRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: TVLRecordCreateOrConnectWithoutOpportunityInput | TVLRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: TVLRecordUpsertWithWhereUniqueWithoutOpportunityInput | TVLRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: TVLRecordCreateManyOpportunityInputEnvelope
    set?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    disconnect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    delete?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    connect?: TVLRecordWhereUniqueInput | TVLRecordWhereUniqueInput[]
    update?: TVLRecordUpdateWithWhereUniqueWithoutOpportunityInput | TVLRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: TVLRecordUpdateManyWithWhereWithoutOpportunityInput | TVLRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: TVLRecordScalarWhereInput | TVLRecordScalarWhereInput[]
  }

  export type AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput> | AprRecordCreateWithoutOpportunityInput[] | AprRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: AprRecordCreateOrConnectWithoutOpportunityInput | AprRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: AprRecordUpsertWithWhereUniqueWithoutOpportunityInput | AprRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: AprRecordCreateManyOpportunityInputEnvelope
    set?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    disconnect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    delete?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    connect?: AprRecordWhereUniqueInput | AprRecordWhereUniqueInput[]
    update?: AprRecordUpdateWithWhereUniqueWithoutOpportunityInput | AprRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: AprRecordUpdateManyWithWhereWithoutOpportunityInput | AprRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: AprRecordScalarWhereInput | AprRecordScalarWhereInput[]
  }

  export type DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput> | DailyRewardsRecordCreateWithoutOpportunityInput[] | DailyRewardsRecordUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutOpportunityInput | DailyRewardsRecordCreateOrConnectWithoutOpportunityInput[]
    upsert?: DailyRewardsRecordUpsertWithWhereUniqueWithoutOpportunityInput | DailyRewardsRecordUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: DailyRewardsRecordCreateManyOpportunityInputEnvelope
    set?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    disconnect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    delete?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    connect?: DailyRewardsRecordWhereUniqueInput | DailyRewardsRecordWhereUniqueInput[]
    update?: DailyRewardsRecordUpdateWithWhereUniqueWithoutOpportunityInput | DailyRewardsRecordUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: DailyRewardsRecordUpdateManyWithWhereWithoutOpportunityInput | DailyRewardsRecordUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: DailyRewardsRecordScalarWhereInput | DailyRewardsRecordScalarWhereInput[]
  }

  export type ProtocolCreatetagsInput = {
    set: string[]
  }

  export type OpportunityCreateNestedManyWithoutMainProtocolInput = {
    create?: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput> | OpportunityCreateWithoutMainProtocolInput[] | OpportunityUncheckedCreateWithoutMainProtocolInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutMainProtocolInput | OpportunityCreateOrConnectWithoutMainProtocolInput[]
    createMany?: OpportunityCreateManyMainProtocolInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutProtocolsInput = {
    create?: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput> | OpportunityCreateWithoutProtocolsInput[] | OpportunityUncheckedCreateWithoutProtocolsInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProtocolsInput | OpportunityCreateOrConnectWithoutProtocolsInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type RewardBreakdownCreateNestedManyWithoutProtocolInput = {
    create?: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput> | RewardBreakdownCreateWithoutProtocolInput[] | RewardBreakdownUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutProtocolInput | RewardBreakdownCreateOrConnectWithoutProtocolInput[]
    createMany?: RewardBreakdownCreateManyProtocolInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutMainProtocolInput = {
    create?: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput> | OpportunityCreateWithoutMainProtocolInput[] | OpportunityUncheckedCreateWithoutMainProtocolInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutMainProtocolInput | OpportunityCreateOrConnectWithoutMainProtocolInput[]
    createMany?: OpportunityCreateManyMainProtocolInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutProtocolsInput = {
    create?: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput> | OpportunityCreateWithoutProtocolsInput[] | OpportunityUncheckedCreateWithoutProtocolsInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProtocolsInput | OpportunityCreateOrConnectWithoutProtocolsInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type RewardBreakdownUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput> | RewardBreakdownCreateWithoutProtocolInput[] | RewardBreakdownUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutProtocolInput | RewardBreakdownCreateOrConnectWithoutProtocolInput[]
    createMany?: RewardBreakdownCreateManyProtocolInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type ProtocolUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OpportunityUpdateManyWithoutMainProtocolNestedInput = {
    create?: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput> | OpportunityCreateWithoutMainProtocolInput[] | OpportunityUncheckedCreateWithoutMainProtocolInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutMainProtocolInput | OpportunityCreateOrConnectWithoutMainProtocolInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutMainProtocolInput | OpportunityUpsertWithWhereUniqueWithoutMainProtocolInput[]
    createMany?: OpportunityCreateManyMainProtocolInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutMainProtocolInput | OpportunityUpdateWithWhereUniqueWithoutMainProtocolInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutMainProtocolInput | OpportunityUpdateManyWithWhereWithoutMainProtocolInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutProtocolsNestedInput = {
    create?: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput> | OpportunityCreateWithoutProtocolsInput[] | OpportunityUncheckedCreateWithoutProtocolsInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProtocolsInput | OpportunityCreateOrConnectWithoutProtocolsInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutProtocolsInput | OpportunityUpsertWithWhereUniqueWithoutProtocolsInput[]
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutProtocolsInput | OpportunityUpdateWithWhereUniqueWithoutProtocolsInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutProtocolsInput | OpportunityUpdateManyWithWhereWithoutProtocolsInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type RewardBreakdownUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput> | RewardBreakdownCreateWithoutProtocolInput[] | RewardBreakdownUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutProtocolInput | RewardBreakdownCreateOrConnectWithoutProtocolInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutProtocolInput | RewardBreakdownUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: RewardBreakdownCreateManyProtocolInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutProtocolInput | RewardBreakdownUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutProtocolInput | RewardBreakdownUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutMainProtocolNestedInput = {
    create?: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput> | OpportunityCreateWithoutMainProtocolInput[] | OpportunityUncheckedCreateWithoutMainProtocolInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutMainProtocolInput | OpportunityCreateOrConnectWithoutMainProtocolInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutMainProtocolInput | OpportunityUpsertWithWhereUniqueWithoutMainProtocolInput[]
    createMany?: OpportunityCreateManyMainProtocolInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutMainProtocolInput | OpportunityUpdateWithWhereUniqueWithoutMainProtocolInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutMainProtocolInput | OpportunityUpdateManyWithWhereWithoutMainProtocolInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutProtocolsNestedInput = {
    create?: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput> | OpportunityCreateWithoutProtocolsInput[] | OpportunityUncheckedCreateWithoutProtocolsInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProtocolsInput | OpportunityCreateOrConnectWithoutProtocolsInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutProtocolsInput | OpportunityUpsertWithWhereUniqueWithoutProtocolsInput[]
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutProtocolsInput | OpportunityUpdateWithWhereUniqueWithoutProtocolsInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutProtocolsInput | OpportunityUpdateManyWithWhereWithoutProtocolsInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput> | RewardBreakdownCreateWithoutProtocolInput[] | RewardBreakdownUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutProtocolInput | RewardBreakdownCreateOrConnectWithoutProtocolInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutProtocolInput | RewardBreakdownUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: RewardBreakdownCreateManyProtocolInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutProtocolInput | RewardBreakdownUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutProtocolInput | RewardBreakdownUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type ChainCreateNestedOneWithoutTokenInput = {
    create?: XOR<ChainCreateWithoutTokenInput, ChainUncheckedCreateWithoutTokenInput>
    connectOrCreate?: ChainCreateOrConnectWithoutTokenInput
    connect?: ChainWhereUniqueInput
  }

  export type OpportunityCreateNestedManyWithoutTokensInput = {
    create?: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput> | OpportunityCreateWithoutTokensInput[] | OpportunityUncheckedCreateWithoutTokensInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTokensInput | OpportunityCreateOrConnectWithoutTokensInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutRewardTokenInput = {
    create?: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput> | CampaignCreateWithoutRewardTokenInput[] | CampaignUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardTokenInput | CampaignCreateOrConnectWithoutRewardTokenInput[]
    createMany?: CampaignCreateManyRewardTokenInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type RewardCreateNestedManyWithoutRewardTokenInput = {
    create?: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput> | RewardCreateWithoutRewardTokenInput[] | RewardUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutRewardTokenInput | RewardCreateOrConnectWithoutRewardTokenInput[]
    createMany?: RewardCreateManyRewardTokenInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type DumpCreateNestedManyWithoutToTokenInput = {
    create?: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput> | DumpCreateWithoutToTokenInput[] | DumpUncheckedCreateWithoutToTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutToTokenInput | DumpCreateOrConnectWithoutToTokenInput[]
    createMany?: DumpCreateManyToTokenInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type DumpCreateNestedManyWithoutFromTokenInput = {
    create?: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput> | DumpCreateWithoutFromTokenInput[] | DumpUncheckedCreateWithoutFromTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutFromTokenInput | DumpCreateOrConnectWithoutFromTokenInput[]
    createMany?: DumpCreateManyFromTokenInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutTokensInput = {
    create?: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput> | OpportunityCreateWithoutTokensInput[] | OpportunityUncheckedCreateWithoutTokensInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTokensInput | OpportunityCreateOrConnectWithoutTokensInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutRewardTokenInput = {
    create?: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput> | CampaignCreateWithoutRewardTokenInput[] | CampaignUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardTokenInput | CampaignCreateOrConnectWithoutRewardTokenInput[]
    createMany?: CampaignCreateManyRewardTokenInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutRewardTokenInput = {
    create?: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput> | RewardCreateWithoutRewardTokenInput[] | RewardUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutRewardTokenInput | RewardCreateOrConnectWithoutRewardTokenInput[]
    createMany?: RewardCreateManyRewardTokenInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type DumpUncheckedCreateNestedManyWithoutToTokenInput = {
    create?: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput> | DumpCreateWithoutToTokenInput[] | DumpUncheckedCreateWithoutToTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutToTokenInput | DumpCreateOrConnectWithoutToTokenInput[]
    createMany?: DumpCreateManyToTokenInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type DumpUncheckedCreateNestedManyWithoutFromTokenInput = {
    create?: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput> | DumpCreateWithoutFromTokenInput[] | DumpUncheckedCreateWithoutFromTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutFromTokenInput | DumpCreateOrConnectWithoutFromTokenInput[]
    createMany?: DumpCreateManyFromTokenInputEnvelope
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ChainUpdateOneRequiredWithoutTokenNestedInput = {
    create?: XOR<ChainCreateWithoutTokenInput, ChainUncheckedCreateWithoutTokenInput>
    connectOrCreate?: ChainCreateOrConnectWithoutTokenInput
    upsert?: ChainUpsertWithoutTokenInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutTokenInput, ChainUpdateWithoutTokenInput>, ChainUncheckedUpdateWithoutTokenInput>
  }

  export type OpportunityUpdateManyWithoutTokensNestedInput = {
    create?: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput> | OpportunityCreateWithoutTokensInput[] | OpportunityUncheckedCreateWithoutTokensInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTokensInput | OpportunityCreateOrConnectWithoutTokensInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTokensInput | OpportunityUpsertWithWhereUniqueWithoutTokensInput[]
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTokensInput | OpportunityUpdateWithWhereUniqueWithoutTokensInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTokensInput | OpportunityUpdateManyWithWhereWithoutTokensInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutRewardTokenNestedInput = {
    create?: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput> | CampaignCreateWithoutRewardTokenInput[] | CampaignUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardTokenInput | CampaignCreateOrConnectWithoutRewardTokenInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutRewardTokenInput | CampaignUpsertWithWhereUniqueWithoutRewardTokenInput[]
    createMany?: CampaignCreateManyRewardTokenInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutRewardTokenInput | CampaignUpdateWithWhereUniqueWithoutRewardTokenInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutRewardTokenInput | CampaignUpdateManyWithWhereWithoutRewardTokenInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type RewardUpdateManyWithoutRewardTokenNestedInput = {
    create?: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput> | RewardCreateWithoutRewardTokenInput[] | RewardUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutRewardTokenInput | RewardCreateOrConnectWithoutRewardTokenInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutRewardTokenInput | RewardUpsertWithWhereUniqueWithoutRewardTokenInput[]
    createMany?: RewardCreateManyRewardTokenInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutRewardTokenInput | RewardUpdateWithWhereUniqueWithoutRewardTokenInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutRewardTokenInput | RewardUpdateManyWithWhereWithoutRewardTokenInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type DumpUpdateManyWithoutToTokenNestedInput = {
    create?: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput> | DumpCreateWithoutToTokenInput[] | DumpUncheckedCreateWithoutToTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutToTokenInput | DumpCreateOrConnectWithoutToTokenInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutToTokenInput | DumpUpsertWithWhereUniqueWithoutToTokenInput[]
    createMany?: DumpCreateManyToTokenInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutToTokenInput | DumpUpdateWithWhereUniqueWithoutToTokenInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutToTokenInput | DumpUpdateManyWithWhereWithoutToTokenInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type DumpUpdateManyWithoutFromTokenNestedInput = {
    create?: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput> | DumpCreateWithoutFromTokenInput[] | DumpUncheckedCreateWithoutFromTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutFromTokenInput | DumpCreateOrConnectWithoutFromTokenInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutFromTokenInput | DumpUpsertWithWhereUniqueWithoutFromTokenInput[]
    createMany?: DumpCreateManyFromTokenInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutFromTokenInput | DumpUpdateWithWhereUniqueWithoutFromTokenInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutFromTokenInput | DumpUpdateManyWithWhereWithoutFromTokenInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutTokensNestedInput = {
    create?: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput> | OpportunityCreateWithoutTokensInput[] | OpportunityUncheckedCreateWithoutTokensInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTokensInput | OpportunityCreateOrConnectWithoutTokensInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTokensInput | OpportunityUpsertWithWhereUniqueWithoutTokensInput[]
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTokensInput | OpportunityUpdateWithWhereUniqueWithoutTokensInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTokensInput | OpportunityUpdateManyWithWhereWithoutTokensInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput = {
    create?: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput> | CampaignCreateWithoutRewardTokenInput[] | CampaignUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardTokenInput | CampaignCreateOrConnectWithoutRewardTokenInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutRewardTokenInput | CampaignUpsertWithWhereUniqueWithoutRewardTokenInput[]
    createMany?: CampaignCreateManyRewardTokenInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutRewardTokenInput | CampaignUpdateWithWhereUniqueWithoutRewardTokenInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutRewardTokenInput | CampaignUpdateManyWithWhereWithoutRewardTokenInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutRewardTokenNestedInput = {
    create?: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput> | RewardCreateWithoutRewardTokenInput[] | RewardUncheckedCreateWithoutRewardTokenInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutRewardTokenInput | RewardCreateOrConnectWithoutRewardTokenInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutRewardTokenInput | RewardUpsertWithWhereUniqueWithoutRewardTokenInput[]
    createMany?: RewardCreateManyRewardTokenInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutRewardTokenInput | RewardUpdateWithWhereUniqueWithoutRewardTokenInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutRewardTokenInput | RewardUpdateManyWithWhereWithoutRewardTokenInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type DumpUncheckedUpdateManyWithoutToTokenNestedInput = {
    create?: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput> | DumpCreateWithoutToTokenInput[] | DumpUncheckedCreateWithoutToTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutToTokenInput | DumpCreateOrConnectWithoutToTokenInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutToTokenInput | DumpUpsertWithWhereUniqueWithoutToTokenInput[]
    createMany?: DumpCreateManyToTokenInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutToTokenInput | DumpUpdateWithWhereUniqueWithoutToTokenInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutToTokenInput | DumpUpdateManyWithWhereWithoutToTokenInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type DumpUncheckedUpdateManyWithoutFromTokenNestedInput = {
    create?: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput> | DumpCreateWithoutFromTokenInput[] | DumpUncheckedCreateWithoutFromTokenInput[]
    connectOrCreate?: DumpCreateOrConnectWithoutFromTokenInput | DumpCreateOrConnectWithoutFromTokenInput[]
    upsert?: DumpUpsertWithWhereUniqueWithoutFromTokenInput | DumpUpsertWithWhereUniqueWithoutFromTokenInput[]
    createMany?: DumpCreateManyFromTokenInputEnvelope
    set?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    disconnect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    delete?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    connect?: DumpWhereUniqueInput | DumpWhereUniqueInput[]
    update?: DumpUpdateWithWhereUniqueWithoutFromTokenInput | DumpUpdateWithWhereUniqueWithoutFromTokenInput[]
    updateMany?: DumpUpdateManyWithWhereWithoutFromTokenInput | DumpUpdateManyWithWhereWithoutFromTokenInput[]
    deleteMany?: DumpScalarWhereInput | DumpScalarWhereInput[]
  }

  export type AprBreakdownCreateNestedManyWithoutAprRecordInput = {
    create?: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput> | AprBreakdownCreateWithoutAprRecordInput[] | AprBreakdownUncheckedCreateWithoutAprRecordInput[]
    connectOrCreate?: AprBreakdownCreateOrConnectWithoutAprRecordInput | AprBreakdownCreateOrConnectWithoutAprRecordInput[]
    createMany?: AprBreakdownCreateManyAprRecordInputEnvelope
    connect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
  }

  export type OpportunityCreateNestedOneWithoutAprRecordsInput = {
    create?: XOR<OpportunityCreateWithoutAprRecordsInput, OpportunityUncheckedCreateWithoutAprRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutAprRecordsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type AprBreakdownUncheckedCreateNestedManyWithoutAprRecordInput = {
    create?: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput> | AprBreakdownCreateWithoutAprRecordInput[] | AprBreakdownUncheckedCreateWithoutAprRecordInput[]
    connectOrCreate?: AprBreakdownCreateOrConnectWithoutAprRecordInput | AprBreakdownCreateOrConnectWithoutAprRecordInput[]
    createMany?: AprBreakdownCreateManyAprRecordInputEnvelope
    connect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
  }

  export type AprBreakdownUpdateManyWithoutAprRecordNestedInput = {
    create?: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput> | AprBreakdownCreateWithoutAprRecordInput[] | AprBreakdownUncheckedCreateWithoutAprRecordInput[]
    connectOrCreate?: AprBreakdownCreateOrConnectWithoutAprRecordInput | AprBreakdownCreateOrConnectWithoutAprRecordInput[]
    upsert?: AprBreakdownUpsertWithWhereUniqueWithoutAprRecordInput | AprBreakdownUpsertWithWhereUniqueWithoutAprRecordInput[]
    createMany?: AprBreakdownCreateManyAprRecordInputEnvelope
    set?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    disconnect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    delete?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    connect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    update?: AprBreakdownUpdateWithWhereUniqueWithoutAprRecordInput | AprBreakdownUpdateWithWhereUniqueWithoutAprRecordInput[]
    updateMany?: AprBreakdownUpdateManyWithWhereWithoutAprRecordInput | AprBreakdownUpdateManyWithWhereWithoutAprRecordInput[]
    deleteMany?: AprBreakdownScalarWhereInput | AprBreakdownScalarWhereInput[]
  }

  export type OpportunityUpdateOneRequiredWithoutAprRecordsNestedInput = {
    create?: XOR<OpportunityCreateWithoutAprRecordsInput, OpportunityUncheckedCreateWithoutAprRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutAprRecordsInput
    upsert?: OpportunityUpsertWithoutAprRecordsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutAprRecordsInput, OpportunityUpdateWithoutAprRecordsInput>, OpportunityUncheckedUpdateWithoutAprRecordsInput>
  }

  export type AprBreakdownUncheckedUpdateManyWithoutAprRecordNestedInput = {
    create?: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput> | AprBreakdownCreateWithoutAprRecordInput[] | AprBreakdownUncheckedCreateWithoutAprRecordInput[]
    connectOrCreate?: AprBreakdownCreateOrConnectWithoutAprRecordInput | AprBreakdownCreateOrConnectWithoutAprRecordInput[]
    upsert?: AprBreakdownUpsertWithWhereUniqueWithoutAprRecordInput | AprBreakdownUpsertWithWhereUniqueWithoutAprRecordInput[]
    createMany?: AprBreakdownCreateManyAprRecordInputEnvelope
    set?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    disconnect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    delete?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    connect?: AprBreakdownWhereUniqueInput | AprBreakdownWhereUniqueInput[]
    update?: AprBreakdownUpdateWithWhereUniqueWithoutAprRecordInput | AprBreakdownUpdateWithWhereUniqueWithoutAprRecordInput[]
    updateMany?: AprBreakdownUpdateManyWithWhereWithoutAprRecordInput | AprBreakdownUpdateManyWithWhereWithoutAprRecordInput[]
    deleteMany?: AprBreakdownScalarWhereInput | AprBreakdownScalarWhereInput[]
  }

  export type AprRecordCreateNestedOneWithoutAprBreakdownInput = {
    create?: XOR<AprRecordCreateWithoutAprBreakdownInput, AprRecordUncheckedCreateWithoutAprBreakdownInput>
    connectOrCreate?: AprRecordCreateOrConnectWithoutAprBreakdownInput
    connect?: AprRecordWhereUniqueInput
  }

  export type EnumAprTypeFieldUpdateOperationsInput = {
    set?: $Enums.AprType
  }

  export type AprRecordUpdateOneRequiredWithoutAprBreakdownNestedInput = {
    create?: XOR<AprRecordCreateWithoutAprBreakdownInput, AprRecordUncheckedCreateWithoutAprBreakdownInput>
    connectOrCreate?: AprRecordCreateOrConnectWithoutAprBreakdownInput
    upsert?: AprRecordUpsertWithoutAprBreakdownInput
    connect?: AprRecordWhereUniqueInput
    update?: XOR<XOR<AprRecordUpdateToOneWithWhereWithoutAprBreakdownInput, AprRecordUpdateWithoutAprBreakdownInput>, AprRecordUncheckedUpdateWithoutAprBreakdownInput>
  }

  export type TVLBreakdownCreateNestedManyWithoutTvlRecordInput = {
    create?: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput> | TVLBreakdownCreateWithoutTvlRecordInput[] | TVLBreakdownUncheckedCreateWithoutTvlRecordInput[]
    connectOrCreate?: TVLBreakdownCreateOrConnectWithoutTvlRecordInput | TVLBreakdownCreateOrConnectWithoutTvlRecordInput[]
    createMany?: TVLBreakdownCreateManyTvlRecordInputEnvelope
    connect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
  }

  export type OpportunityCreateNestedOneWithoutTvlRecordsInput = {
    create?: XOR<OpportunityCreateWithoutTvlRecordsInput, OpportunityUncheckedCreateWithoutTvlRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutTvlRecordsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type TVLBreakdownUncheckedCreateNestedManyWithoutTvlRecordInput = {
    create?: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput> | TVLBreakdownCreateWithoutTvlRecordInput[] | TVLBreakdownUncheckedCreateWithoutTvlRecordInput[]
    connectOrCreate?: TVLBreakdownCreateOrConnectWithoutTvlRecordInput | TVLBreakdownCreateOrConnectWithoutTvlRecordInput[]
    createMany?: TVLBreakdownCreateManyTvlRecordInputEnvelope
    connect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
  }

  export type TVLBreakdownUpdateManyWithoutTvlRecordNestedInput = {
    create?: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput> | TVLBreakdownCreateWithoutTvlRecordInput[] | TVLBreakdownUncheckedCreateWithoutTvlRecordInput[]
    connectOrCreate?: TVLBreakdownCreateOrConnectWithoutTvlRecordInput | TVLBreakdownCreateOrConnectWithoutTvlRecordInput[]
    upsert?: TVLBreakdownUpsertWithWhereUniqueWithoutTvlRecordInput | TVLBreakdownUpsertWithWhereUniqueWithoutTvlRecordInput[]
    createMany?: TVLBreakdownCreateManyTvlRecordInputEnvelope
    set?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    disconnect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    delete?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    connect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    update?: TVLBreakdownUpdateWithWhereUniqueWithoutTvlRecordInput | TVLBreakdownUpdateWithWhereUniqueWithoutTvlRecordInput[]
    updateMany?: TVLBreakdownUpdateManyWithWhereWithoutTvlRecordInput | TVLBreakdownUpdateManyWithWhereWithoutTvlRecordInput[]
    deleteMany?: TVLBreakdownScalarWhereInput | TVLBreakdownScalarWhereInput[]
  }

  export type OpportunityUpdateOneRequiredWithoutTvlRecordsNestedInput = {
    create?: XOR<OpportunityCreateWithoutTvlRecordsInput, OpportunityUncheckedCreateWithoutTvlRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutTvlRecordsInput
    upsert?: OpportunityUpsertWithoutTvlRecordsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutTvlRecordsInput, OpportunityUpdateWithoutTvlRecordsInput>, OpportunityUncheckedUpdateWithoutTvlRecordsInput>
  }

  export type TVLBreakdownUncheckedUpdateManyWithoutTvlRecordNestedInput = {
    create?: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput> | TVLBreakdownCreateWithoutTvlRecordInput[] | TVLBreakdownUncheckedCreateWithoutTvlRecordInput[]
    connectOrCreate?: TVLBreakdownCreateOrConnectWithoutTvlRecordInput | TVLBreakdownCreateOrConnectWithoutTvlRecordInput[]
    upsert?: TVLBreakdownUpsertWithWhereUniqueWithoutTvlRecordInput | TVLBreakdownUpsertWithWhereUniqueWithoutTvlRecordInput[]
    createMany?: TVLBreakdownCreateManyTvlRecordInputEnvelope
    set?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    disconnect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    delete?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    connect?: TVLBreakdownWhereUniqueInput | TVLBreakdownWhereUniqueInput[]
    update?: TVLBreakdownUpdateWithWhereUniqueWithoutTvlRecordInput | TVLBreakdownUpdateWithWhereUniqueWithoutTvlRecordInput[]
    updateMany?: TVLBreakdownUpdateManyWithWhereWithoutTvlRecordInput | TVLBreakdownUpdateManyWithWhereWithoutTvlRecordInput[]
    deleteMany?: TVLBreakdownScalarWhereInput | TVLBreakdownScalarWhereInput[]
  }

  export type TVLRecordCreateNestedOneWithoutTvlBreakdownInput = {
    create?: XOR<TVLRecordCreateWithoutTvlBreakdownInput, TVLRecordUncheckedCreateWithoutTvlBreakdownInput>
    connectOrCreate?: TVLRecordCreateOrConnectWithoutTvlBreakdownInput
    connect?: TVLRecordWhereUniqueInput
  }

  export type EnumTvlTypeFieldUpdateOperationsInput = {
    set?: $Enums.TvlType
  }

  export type TVLRecordUpdateOneRequiredWithoutTvlBreakdownNestedInput = {
    create?: XOR<TVLRecordCreateWithoutTvlBreakdownInput, TVLRecordUncheckedCreateWithoutTvlBreakdownInput>
    connectOrCreate?: TVLRecordCreateOrConnectWithoutTvlBreakdownInput
    upsert?: TVLRecordUpsertWithoutTvlBreakdownInput
    connect?: TVLRecordWhereUniqueInput
    update?: XOR<XOR<TVLRecordUpdateToOneWithWhereWithoutTvlBreakdownInput, TVLRecordUpdateWithoutTvlBreakdownInput>, TVLRecordUncheckedUpdateWithoutTvlBreakdownInput>
  }

  export type DailyRewardsBreakdownCreateNestedManyWithoutDailyRewardsRecordInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput> | DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput[] | DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput | DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput[]
    createMany?: DailyRewardsBreakdownCreateManyDailyRewardsRecordInputEnvelope
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
  }

  export type OpportunityCreateNestedOneWithoutDailyRewardsRecordsInput = {
    create?: XOR<OpportunityCreateWithoutDailyRewardsRecordsInput, OpportunityUncheckedCreateWithoutDailyRewardsRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutDailyRewardsRecordsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type DailyRewardsBreakdownUncheckedCreateNestedManyWithoutDailyRewardsRecordInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput> | DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput[] | DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput | DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput[]
    createMany?: DailyRewardsBreakdownCreateManyDailyRewardsRecordInputEnvelope
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
  }

  export type DailyRewardsBreakdownUpdateManyWithoutDailyRewardsRecordNestedInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput> | DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput[] | DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput | DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput[]
    upsert?: DailyRewardsBreakdownUpsertWithWhereUniqueWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpsertWithWhereUniqueWithoutDailyRewardsRecordInput[]
    createMany?: DailyRewardsBreakdownCreateManyDailyRewardsRecordInputEnvelope
    set?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    disconnect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    delete?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    update?: DailyRewardsBreakdownUpdateWithWhereUniqueWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpdateWithWhereUniqueWithoutDailyRewardsRecordInput[]
    updateMany?: DailyRewardsBreakdownUpdateManyWithWhereWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpdateManyWithWhereWithoutDailyRewardsRecordInput[]
    deleteMany?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
  }

  export type OpportunityUpdateOneRequiredWithoutDailyRewardsRecordsNestedInput = {
    create?: XOR<OpportunityCreateWithoutDailyRewardsRecordsInput, OpportunityUncheckedCreateWithoutDailyRewardsRecordsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutDailyRewardsRecordsInput
    upsert?: OpportunityUpsertWithoutDailyRewardsRecordsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutDailyRewardsRecordsInput, OpportunityUpdateWithoutDailyRewardsRecordsInput>, OpportunityUncheckedUpdateWithoutDailyRewardsRecordsInput>
  }

  export type DailyRewardsBreakdownUncheckedUpdateManyWithoutDailyRewardsRecordNestedInput = {
    create?: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput> | DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput[] | DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput[]
    connectOrCreate?: DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput | DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput[]
    upsert?: DailyRewardsBreakdownUpsertWithWhereUniqueWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpsertWithWhereUniqueWithoutDailyRewardsRecordInput[]
    createMany?: DailyRewardsBreakdownCreateManyDailyRewardsRecordInputEnvelope
    set?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    disconnect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    delete?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    connect?: DailyRewardsBreakdownWhereUniqueInput | DailyRewardsBreakdownWhereUniqueInput[]
    update?: DailyRewardsBreakdownUpdateWithWhereUniqueWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpdateWithWhereUniqueWithoutDailyRewardsRecordInput[]
    updateMany?: DailyRewardsBreakdownUpdateManyWithWhereWithoutDailyRewardsRecordInput | DailyRewardsBreakdownUpdateManyWithWhereWithoutDailyRewardsRecordInput[]
    deleteMany?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutDailyRewardsBreakdownInput = {
    create?: XOR<CampaignCreateWithoutDailyRewardsBreakdownInput, CampaignUncheckedCreateWithoutDailyRewardsBreakdownInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDailyRewardsBreakdownInput
    connect?: CampaignWhereUniqueInput
  }

  export type DailyRewardsRecordCreateNestedOneWithoutDailyRewardsBreakdownInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedCreateWithoutDailyRewardsBreakdownInput>
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutDailyRewardsBreakdownInput
    connect?: DailyRewardsRecordWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput = {
    create?: XOR<CampaignCreateWithoutDailyRewardsBreakdownInput, CampaignUncheckedCreateWithoutDailyRewardsBreakdownInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDailyRewardsBreakdownInput
    upsert?: CampaignUpsertWithoutDailyRewardsBreakdownInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutDailyRewardsBreakdownInput, CampaignUpdateWithoutDailyRewardsBreakdownInput>, CampaignUncheckedUpdateWithoutDailyRewardsBreakdownInput>
  }

  export type DailyRewardsRecordUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput = {
    create?: XOR<DailyRewardsRecordCreateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedCreateWithoutDailyRewardsBreakdownInput>
    connectOrCreate?: DailyRewardsRecordCreateOrConnectWithoutDailyRewardsBreakdownInput
    upsert?: DailyRewardsRecordUpsertWithoutDailyRewardsBreakdownInput
    connect?: DailyRewardsRecordWhereUniqueInput
    update?: XOR<XOR<DailyRewardsRecordUpdateToOneWithWhereWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUpdateWithoutDailyRewardsBreakdownInput>, DailyRewardsRecordUncheckedUpdateWithoutDailyRewardsBreakdownInput>
  }

  export type UserCreatetagsInput = {
    set: string[]
  }

  export type RewardCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type BlacklistCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserComputedValueCreateNestedManyWithoutUserInput = {
    create?: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput> | UserComputedValueCreateWithoutUserInput[] | UserComputedValueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutUserInput | UserComputedValueCreateOrConnectWithoutUserInput[]
    createMany?: UserComputedValueCreateManyUserInputEnvelope
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
  }

  export type CreatorCreateNestedOneWithoutUsersInput = {
    create?: XOR<CreatorCreateWithoutUsersInput, CreatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUsersInput
    connect?: CreatorWhereUniqueInput
  }

  export type RewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type BlacklistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserComputedValueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput> | UserComputedValueCreateWithoutUserInput[] | UserComputedValueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutUserInput | UserComputedValueCreateOrConnectWithoutUserInput[]
    createMany?: UserComputedValueCreateManyUserInputEnvelope
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
  }

  export type UserUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type BlacklistUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutUserInput | BlacklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutUserInput | BlacklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutUserInput | BlacklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserComputedValueUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput> | UserComputedValueCreateWithoutUserInput[] | UserComputedValueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutUserInput | UserComputedValueCreateOrConnectWithoutUserInput[]
    upsert?: UserComputedValueUpsertWithWhereUniqueWithoutUserInput | UserComputedValueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserComputedValueCreateManyUserInputEnvelope
    set?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    disconnect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    delete?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    update?: UserComputedValueUpdateWithWhereUniqueWithoutUserInput | UserComputedValueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserComputedValueUpdateManyWithWhereWithoutUserInput | UserComputedValueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
  }

  export type CreatorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CreatorCreateWithoutUsersInput, CreatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUsersInput
    upsert?: CreatorUpsertWithoutUsersInput
    disconnect?: CreatorWhereInput | boolean
    delete?: CreatorWhereInput | boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<XOR<CreatorUpdateToOneWithWhereWithoutUsersInput, CreatorUpdateWithoutUsersInput>, CreatorUncheckedUpdateWithoutUsersInput>
  }

  export type RewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type BlacklistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutUserInput | BlacklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutUserInput | BlacklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutUserInput | BlacklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserComputedValueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput> | UserComputedValueCreateWithoutUserInput[] | UserComputedValueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserComputedValueCreateOrConnectWithoutUserInput | UserComputedValueCreateOrConnectWithoutUserInput[]
    upsert?: UserComputedValueUpsertWithWhereUniqueWithoutUserInput | UserComputedValueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserComputedValueCreateManyUserInputEnvelope
    set?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    disconnect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    delete?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    connect?: UserComputedValueWhereUniqueInput | UserComputedValueWhereUniqueInput[]
    update?: UserComputedValueUpdateWithWhereUniqueWithoutUserInput | UserComputedValueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserComputedValueUpdateManyWithWhereWithoutUserInput | UserComputedValueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatorInput | UserUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatorInput | UserUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatorInput | UserUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput> | UserCreateWithoutCreatorInput[] | UserUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput | UserCreateOrConnectWithoutCreatorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatorInput | UserUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserCreateManyCreatorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatorInput | UserUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatorInput | UserUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RewardCreateproofsInput = {
    set: string[]
  }

  export type MerklRootCreateNestedOneWithoutRewardsInput = {
    create?: XOR<MerklRootCreateWithoutRewardsInput, MerklRootUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: MerklRootCreateOrConnectWithoutRewardsInput
    connect?: MerklRootWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutRewardInput = {
    create?: XOR<TokenCreateWithoutRewardInput, TokenUncheckedCreateWithoutRewardInput>
    connectOrCreate?: TokenCreateOrConnectWithoutRewardInput
    connect?: TokenWhereUniqueInput
  }

  export type RewardBreakdownCreateNestedManyWithoutRewardInput = {
    create?: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput> | RewardBreakdownCreateWithoutRewardInput[] | RewardBreakdownUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutRewardInput | RewardBreakdownCreateOrConnectWithoutRewardInput[]
    createMany?: RewardBreakdownCreateManyRewardInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type RewardBreakdownUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput> | RewardBreakdownCreateWithoutRewardInput[] | RewardBreakdownUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutRewardInput | RewardBreakdownCreateOrConnectWithoutRewardInput[]
    createMany?: RewardBreakdownCreateManyRewardInputEnvelope
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
  }

  export type RewardUpdateproofsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MerklRootUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<MerklRootCreateWithoutRewardsInput, MerklRootUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: MerklRootCreateOrConnectWithoutRewardsInput
    upsert?: MerklRootUpsertWithoutRewardsInput
    connect?: MerklRootWhereUniqueInput
    update?: XOR<XOR<MerklRootUpdateToOneWithWhereWithoutRewardsInput, MerklRootUpdateWithoutRewardsInput>, MerklRootUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardsInput, UserUpdateWithoutRewardsInput>, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type TokenUpdateOneRequiredWithoutRewardNestedInput = {
    create?: XOR<TokenCreateWithoutRewardInput, TokenUncheckedCreateWithoutRewardInput>
    connectOrCreate?: TokenCreateOrConnectWithoutRewardInput
    upsert?: TokenUpsertWithoutRewardInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutRewardInput, TokenUpdateWithoutRewardInput>, TokenUncheckedUpdateWithoutRewardInput>
  }

  export type RewardBreakdownUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput> | RewardBreakdownCreateWithoutRewardInput[] | RewardBreakdownUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutRewardInput | RewardBreakdownCreateOrConnectWithoutRewardInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutRewardInput | RewardBreakdownUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RewardBreakdownCreateManyRewardInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutRewardInput | RewardBreakdownUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutRewardInput | RewardBreakdownUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput> | RewardBreakdownCreateWithoutRewardInput[] | RewardBreakdownUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RewardBreakdownCreateOrConnectWithoutRewardInput | RewardBreakdownCreateOrConnectWithoutRewardInput[]
    upsert?: RewardBreakdownUpsertWithWhereUniqueWithoutRewardInput | RewardBreakdownUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RewardBreakdownCreateManyRewardInputEnvelope
    set?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    disconnect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    delete?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    connect?: RewardBreakdownWhereUniqueInput | RewardBreakdownWhereUniqueInput[]
    update?: RewardBreakdownUpdateWithWhereUniqueWithoutRewardInput | RewardBreakdownUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RewardBreakdownUpdateManyWithWhereWithoutRewardInput | RewardBreakdownUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
  }

  export type ProtocolCreateNestedOneWithoutRewardBreakdownInput = {
    create?: XOR<ProtocolCreateWithoutRewardBreakdownInput, ProtocolUncheckedCreateWithoutRewardBreakdownInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutRewardBreakdownInput
    connect?: ProtocolWhereUniqueInput
  }

  export type RewardCreateNestedOneWithoutBreakdownInput = {
    create?: XOR<RewardCreateWithoutBreakdownInput, RewardUncheckedCreateWithoutBreakdownInput>
    connectOrCreate?: RewardCreateOrConnectWithoutBreakdownInput
    connect?: RewardWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutRewardBreakdownInput = {
    create?: XOR<CampaignCreateWithoutRewardBreakdownInput, CampaignUncheckedCreateWithoutRewardBreakdownInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardBreakdownInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutRewardBreakdownSubCampaignInput = {
    create?: XOR<CampaignCreateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedCreateWithoutRewardBreakdownSubCampaignInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardBreakdownSubCampaignInput
    connect?: CampaignWhereUniqueInput
  }

  export type ProtocolUpdateOneWithoutRewardBreakdownNestedInput = {
    create?: XOR<ProtocolCreateWithoutRewardBreakdownInput, ProtocolUncheckedCreateWithoutRewardBreakdownInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutRewardBreakdownInput
    upsert?: ProtocolUpsertWithoutRewardBreakdownInput
    disconnect?: ProtocolWhereInput | boolean
    delete?: ProtocolWhereInput | boolean
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutRewardBreakdownInput, ProtocolUpdateWithoutRewardBreakdownInput>, ProtocolUncheckedUpdateWithoutRewardBreakdownInput>
  }

  export type RewardUpdateOneRequiredWithoutBreakdownNestedInput = {
    create?: XOR<RewardCreateWithoutBreakdownInput, RewardUncheckedCreateWithoutBreakdownInput>
    connectOrCreate?: RewardCreateOrConnectWithoutBreakdownInput
    upsert?: RewardUpsertWithoutBreakdownInput
    connect?: RewardWhereUniqueInput
    update?: XOR<XOR<RewardUpdateToOneWithWhereWithoutBreakdownInput, RewardUpdateWithoutBreakdownInput>, RewardUncheckedUpdateWithoutBreakdownInput>
  }

  export type CampaignUpdateOneRequiredWithoutRewardBreakdownNestedInput = {
    create?: XOR<CampaignCreateWithoutRewardBreakdownInput, CampaignUncheckedCreateWithoutRewardBreakdownInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardBreakdownInput
    upsert?: CampaignUpsertWithoutRewardBreakdownInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRewardBreakdownInput, CampaignUpdateWithoutRewardBreakdownInput>, CampaignUncheckedUpdateWithoutRewardBreakdownInput>
  }

  export type CampaignUpdateOneWithoutRewardBreakdownSubCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedCreateWithoutRewardBreakdownSubCampaignInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRewardBreakdownSubCampaignInput
    upsert?: CampaignUpsertWithoutRewardBreakdownSubCampaignInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRewardBreakdownSubCampaignInput, CampaignUpdateWithoutRewardBreakdownSubCampaignInput>, CampaignUncheckedUpdateWithoutRewardBreakdownSubCampaignInput>
  }

  export type ChainCreateNestedOneWithoutMerklRootInput = {
    create?: XOR<ChainCreateWithoutMerklRootInput, ChainUncheckedCreateWithoutMerklRootInput>
    connectOrCreate?: ChainCreateOrConnectWithoutMerklRootInput
    connect?: ChainWhereUniqueInput
  }

  export type RewardCreateNestedManyWithoutMerklRootInput = {
    create?: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput> | RewardCreateWithoutMerklRootInput[] | RewardUncheckedCreateWithoutMerklRootInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerklRootInput | RewardCreateOrConnectWithoutMerklRootInput[]
    createMany?: RewardCreateManyMerklRootInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutMerklRootInput = {
    create?: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput> | RewardCreateWithoutMerklRootInput[] | RewardUncheckedCreateWithoutMerklRootInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerklRootInput | RewardCreateOrConnectWithoutMerklRootInput[]
    createMany?: RewardCreateManyMerklRootInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type ChainUpdateOneRequiredWithoutMerklRootNestedInput = {
    create?: XOR<ChainCreateWithoutMerklRootInput, ChainUncheckedCreateWithoutMerklRootInput>
    connectOrCreate?: ChainCreateOrConnectWithoutMerklRootInput
    upsert?: ChainUpsertWithoutMerklRootInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutMerklRootInput, ChainUpdateWithoutMerklRootInput>, ChainUncheckedUpdateWithoutMerklRootInput>
  }

  export type RewardUpdateManyWithoutMerklRootNestedInput = {
    create?: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput> | RewardCreateWithoutMerklRootInput[] | RewardUncheckedCreateWithoutMerklRootInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerklRootInput | RewardCreateOrConnectWithoutMerklRootInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutMerklRootInput | RewardUpsertWithWhereUniqueWithoutMerklRootInput[]
    createMany?: RewardCreateManyMerklRootInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutMerklRootInput | RewardUpdateWithWhereUniqueWithoutMerklRootInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutMerklRootInput | RewardUpdateManyWithWhereWithoutMerklRootInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutMerklRootNestedInput = {
    create?: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput> | RewardCreateWithoutMerklRootInput[] | RewardUncheckedCreateWithoutMerklRootInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutMerklRootInput | RewardCreateOrConnectWithoutMerklRootInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutMerklRootInput | RewardUpsertWithWhereUniqueWithoutMerklRootInput[]
    createMany?: RewardCreateManyMerklRootInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutMerklRootInput | RewardUpdateWithWhereUniqueWithoutMerklRootInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutMerklRootInput | RewardUpdateManyWithWhereWithoutMerklRootInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type EnumPriceSourceMethodFieldUpdateOperationsInput = {
    set?: $Enums.PriceSourceMethod
  }

  export type ChainCreateNestedOneWithoutBlacklistInput = {
    create?: XOR<ChainCreateWithoutBlacklistInput, ChainUncheckedCreateWithoutBlacklistInput>
    connectOrCreate?: ChainCreateOrConnectWithoutBlacklistInput
    connect?: ChainWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlacklistInput = {
    create?: XOR<UserCreateWithoutBlacklistInput, UserUncheckedCreateWithoutBlacklistInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistInput
    connect?: UserWhereUniqueInput
  }

  export type ChainUpdateOneRequiredWithoutBlacklistNestedInput = {
    create?: XOR<ChainCreateWithoutBlacklistInput, ChainUncheckedCreateWithoutBlacklistInput>
    connectOrCreate?: ChainCreateOrConnectWithoutBlacklistInput
    upsert?: ChainUpsertWithoutBlacklistInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutBlacklistInput, ChainUpdateWithoutBlacklistInput>, ChainUncheckedUpdateWithoutBlacklistInput>
  }

  export type UserUpdateOneRequiredWithoutBlacklistNestedInput = {
    create?: XOR<UserCreateWithoutBlacklistInput, UserUncheckedCreateWithoutBlacklistInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistInput
    upsert?: UserUpsertWithoutBlacklistInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlacklistInput, UserUpdateWithoutBlacklistInput>, UserUncheckedUpdateWithoutBlacklistInput>
  }

  export type ChainCreateNestedOneWithoutDumpInput = {
    create?: XOR<ChainCreateWithoutDumpInput, ChainUncheckedCreateWithoutDumpInput>
    connectOrCreate?: ChainCreateOrConnectWithoutDumpInput
    connect?: ChainWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDumpFromInput = {
    create?: XOR<TokenCreateWithoutDumpFromInput, TokenUncheckedCreateWithoutDumpFromInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDumpFromInput
    connect?: TokenWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDumpToInput = {
    create?: XOR<TokenCreateWithoutDumpToInput, TokenUncheckedCreateWithoutDumpToInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDumpToInput
    connect?: TokenWhereUniqueInput
  }

  export type ChainUpdateOneRequiredWithoutDumpNestedInput = {
    create?: XOR<ChainCreateWithoutDumpInput, ChainUncheckedCreateWithoutDumpInput>
    connectOrCreate?: ChainCreateOrConnectWithoutDumpInput
    upsert?: ChainUpsertWithoutDumpInput
    connect?: ChainWhereUniqueInput
    update?: XOR<XOR<ChainUpdateToOneWithWhereWithoutDumpInput, ChainUpdateWithoutDumpInput>, ChainUncheckedUpdateWithoutDumpInput>
  }

  export type TokenUpdateOneRequiredWithoutDumpFromNestedInput = {
    create?: XOR<TokenCreateWithoutDumpFromInput, TokenUncheckedCreateWithoutDumpFromInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDumpFromInput
    upsert?: TokenUpsertWithoutDumpFromInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDumpFromInput, TokenUpdateWithoutDumpFromInput>, TokenUncheckedUpdateWithoutDumpFromInput>
  }

  export type TokenUpdateOneRequiredWithoutDumpToNestedInput = {
    create?: XOR<TokenCreateWithoutDumpToInput, TokenUncheckedCreateWithoutDumpToInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDumpToInput
    upsert?: TokenUpsertWithoutDumpToInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDumpToInput, TokenUpdateWithoutDumpToInput>, TokenUncheckedUpdateWithoutDumpToInput>
  }

  export type EnumLoggedEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoggedEntityType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumDistributionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DistributionType | EnumDistributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributionTypeFilter<$PrismaModel> | $Enums.DistributionType
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDistributionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DistributionType | EnumDistributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DistributionType[] | ListEnumDistributionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DistributionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDistributionTypeFilter<$PrismaModel>
    _max?: NestedEnumDistributionTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RunStatus | EnumRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRunStatusFilter<$PrismaModel> | $Enums.RunStatus
  }

  export type NestedEnumRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RunStatus | EnumRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RunStatus[] | ListEnumRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.RunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRunStatusFilter<$PrismaModel>
    _max?: NestedEnumRunStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumExplorerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExplorerType | EnumExplorerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExplorerTypeFilter<$PrismaModel> | $Enums.ExplorerType
  }

  export type NestedEnumExplorerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExplorerType | EnumExplorerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExplorerType[] | ListEnumExplorerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExplorerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExplorerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExplorerTypeFilter<$PrismaModel>
    _max?: NestedEnumExplorerTypeFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumOpportunityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityAction | EnumOpportunityActionFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityActionFilter<$PrismaModel> | $Enums.OpportunityAction
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityAction | EnumOpportunityActionFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityAction[] | ListEnumOpportunityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityActionWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityActionFilter<$PrismaModel>
    _max?: NestedEnumOpportunityActionFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAprTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AprType | EnumAprTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAprTypeFilter<$PrismaModel> | $Enums.AprType
  }

  export type NestedEnumAprTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AprType | EnumAprTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AprType[] | ListEnumAprTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAprTypeWithAggregatesFilter<$PrismaModel> | $Enums.AprType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAprTypeFilter<$PrismaModel>
    _max?: NestedEnumAprTypeFilter<$PrismaModel>
  }

  export type NestedEnumTvlTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TvlType | EnumTvlTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTvlTypeFilter<$PrismaModel> | $Enums.TvlType
  }

  export type NestedEnumTvlTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TvlType | EnumTvlTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TvlType[] | ListEnumTvlTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTvlTypeWithAggregatesFilter<$PrismaModel> | $Enums.TvlType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTvlTypeFilter<$PrismaModel>
    _max?: NestedEnumTvlTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriceSourceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceSourceMethod | EnumPriceSourceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceSourceMethodFilter<$PrismaModel> | $Enums.PriceSourceMethod
  }

  export type NestedEnumPriceSourceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceSourceMethod | EnumPriceSourceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceSourceMethod[] | ListEnumPriceSourceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceSourceMethodWithAggregatesFilter<$PrismaModel> | $Enums.PriceSourceMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceSourceMethodFilter<$PrismaModel>
    _max?: NestedEnumPriceSourceMethodFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLoggedEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoggedEntityType | EnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoggedEntityTypeFilter<$PrismaModel> | $Enums.LoggedEntityType
  }

  export type NestedEnumLoggedEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoggedEntityType | EnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoggedEntityType[] | ListEnumLoggedEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoggedEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoggedEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoggedEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumLoggedEntityTypeFilter<$PrismaModel>
  }

  export type ChainCreateWithoutCampaignsInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutCampaignsInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutCampaignsInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutCampaignsInput, ChainUncheckedCreateWithoutCampaignsInput>
  }

  export type ChainCreateWithoutDistributionInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutDistributionInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutDistributionInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutDistributionInput, ChainUncheckedCreateWithoutDistributionInput>
  }

  export type TokenCreateWithoutCampaignsInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateWithoutCampaignsInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenCreateOrConnectWithoutCampaignsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutCampaignsInput, TokenUncheckedCreateWithoutCampaignsInput>
  }

  export type OpportunityCreateWithoutCampaignsInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutCampaignsInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutCampaignsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutCampaignsInput, OpportunityUncheckedCreateWithoutCampaignsInput>
  }

  export type RewardBreakdownCreateWithoutCampaignInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    Protocol?: ProtocolCreateNestedOneWithoutRewardBreakdownInput
    Reward: RewardCreateNestedOneWithoutBreakdownInput
    SubCampaign?: CampaignCreateNestedOneWithoutRewardBreakdownSubCampaignInput
  }

  export type RewardBreakdownUncheckedCreateWithoutCampaignInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownCreateOrConnectWithoutCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    create: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput>
  }

  export type RewardBreakdownCreateManyCampaignInputEnvelope = {
    data: RewardBreakdownCreateManyCampaignInput | RewardBreakdownCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DailyRewardsBreakdownCreateWithoutCampaignInput = {
    id?: string
    value: number
    DailyRewardsRecord: DailyRewardsRecordCreateNestedOneWithoutDailyRewardsBreakdownInput
  }

  export type DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput = {
    id?: string
    value: number
    dailyRewardsRecordId: string
  }

  export type DailyRewardsBreakdownCreateOrConnectWithoutCampaignInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    create: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput>
  }

  export type DailyRewardsBreakdownCreateManyCampaignInputEnvelope = {
    data: DailyRewardsBreakdownCreateManyCampaignInput | DailyRewardsBreakdownCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCampaignsCreatedInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistCreateNestedManyWithoutUserInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutUserInput
    Creator?: CreatorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCampaignsCreatedInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
    Rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsCreatedInput, UserUncheckedCreateWithoutCampaignsCreatedInput>
  }

  export type CampaignStatusCreateWithoutCampaignInput = {
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUncheckedCreateWithoutCampaignInput = {
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusCreateOrConnectWithoutCampaignInput = {
    where: CampaignStatusWhereUniqueInput
    create: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignStatusCreateManyCampaignInputEnvelope = {
    data: CampaignStatusCreateManyCampaignInput | CampaignStatusCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignComputedValueCreateWithoutCampaignInput = {
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
  }

  export type CampaignComputedValueUncheckedCreateWithoutCampaignInput = {
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
  }

  export type CampaignComputedValueCreateOrConnectWithoutCampaignInput = {
    where: CampaignComputedValueWhereUniqueInput
    create: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignComputedValueCreateManyCampaignInputEnvelope = {
    data: CampaignComputedValueCreateManyCampaignInput | CampaignComputedValueCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserComputedValueCreateWithoutCampaignInput = {
    id?: string
    reason: string
    boost?: number | null
    User?: UserCreateNestedOneWithoutUserComputedValueInput
  }

  export type UserComputedValueUncheckedCreateWithoutCampaignInput = {
    id?: string
    address: string
    reason: string
    boost?: number | null
  }

  export type UserComputedValueCreateOrConnectWithoutCampaignInput = {
    where: UserComputedValueWhereUniqueInput
    create: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput>
  }

  export type UserComputedValueCreateManyCampaignInputEnvelope = {
    data: UserComputedValueCreateManyCampaignInput | UserComputedValueCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutSubCampaignsInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSubCampaignsInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSubCampaignsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
  }

  export type CampaignCreateWithoutRootCampaignInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRootCampaignInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRootCampaignInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput>
  }

  export type CampaignCreateManyRootCampaignInputEnvelope = {
    data: CampaignCreateManyRootCampaignInput | CampaignCreateManyRootCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutChildCampaignsInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutChildCampaignsInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutChildCampaignsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutChildCampaignsInput, CampaignUncheckedCreateWithoutChildCampaignsInput>
  }

  export type CampaignCreateWithoutParentCampaignInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutParentCampaignInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput>
  }

  export type CampaignCreateManyParentCampaignInputEnvelope = {
    data: CampaignCreateManyParentCampaignInput | CampaignCreateManyParentCampaignInput[]
    skipDuplicates?: boolean
  }

  export type RewardBreakdownCreateWithoutSubCampaignInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    Protocol?: ProtocolCreateNestedOneWithoutRewardBreakdownInput
    Reward: RewardCreateNestedOneWithoutBreakdownInput
    Campaign: CampaignCreateNestedOneWithoutRewardBreakdownInput
  }

  export type RewardBreakdownUncheckedCreateWithoutSubCampaignInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
  }

  export type RewardBreakdownCreateOrConnectWithoutSubCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    create: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput>
  }

  export type RewardBreakdownCreateManySubCampaignInputEnvelope = {
    data: RewardBreakdownCreateManySubCampaignInput | RewardBreakdownCreateManySubCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ChainUpsertWithoutCampaignsInput = {
    update: XOR<ChainUpdateWithoutCampaignsInput, ChainUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ChainCreateWithoutCampaignsInput, ChainUncheckedCreateWithoutCampaignsInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutCampaignsInput, ChainUncheckedUpdateWithoutCampaignsInput>
  }

  export type ChainUpdateWithoutCampaignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutCampaignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type ChainUpsertWithoutDistributionInput = {
    update: XOR<ChainUpdateWithoutDistributionInput, ChainUncheckedUpdateWithoutDistributionInput>
    create: XOR<ChainCreateWithoutDistributionInput, ChainUncheckedCreateWithoutDistributionInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutDistributionInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutDistributionInput, ChainUncheckedUpdateWithoutDistributionInput>
  }

  export type ChainUpdateWithoutDistributionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutDistributionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type TokenUpsertWithoutCampaignsInput = {
    update: XOR<TokenUpdateWithoutCampaignsInput, TokenUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TokenCreateWithoutCampaignsInput, TokenUncheckedCreateWithoutCampaignsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutCampaignsInput, TokenUncheckedUpdateWithoutCampaignsInput>
  }

  export type TokenUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type OpportunityUpsertWithoutCampaignsInput = {
    update: XOR<OpportunityUpdateWithoutCampaignsInput, OpportunityUncheckedUpdateWithoutCampaignsInput>
    create: XOR<OpportunityCreateWithoutCampaignsInput, OpportunityUncheckedCreateWithoutCampaignsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutCampaignsInput, OpportunityUncheckedUpdateWithoutCampaignsInput>
  }

  export type OpportunityUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type RewardBreakdownUpsertWithWhereUniqueWithoutCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    update: XOR<RewardBreakdownUpdateWithoutCampaignInput, RewardBreakdownUncheckedUpdateWithoutCampaignInput>
    create: XOR<RewardBreakdownCreateWithoutCampaignInput, RewardBreakdownUncheckedCreateWithoutCampaignInput>
  }

  export type RewardBreakdownUpdateWithWhereUniqueWithoutCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    data: XOR<RewardBreakdownUpdateWithoutCampaignInput, RewardBreakdownUncheckedUpdateWithoutCampaignInput>
  }

  export type RewardBreakdownUpdateManyWithWhereWithoutCampaignInput = {
    where: RewardBreakdownScalarWhereInput
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyWithoutCampaignInput>
  }

  export type RewardBreakdownScalarWhereInput = {
    AND?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
    OR?: RewardBreakdownScalarWhereInput[]
    NOT?: RewardBreakdownScalarWhereInput | RewardBreakdownScalarWhereInput[]
    id?: UuidFilter<"RewardBreakdown"> | string
    protocolId?: StringNullableFilter<"RewardBreakdown"> | string | null
    reason?: StringFilter<"RewardBreakdown"> | string
    amount?: StringFilter<"RewardBreakdown"> | string
    claimed?: StringFilter<"RewardBreakdown"> | string
    pending?: StringFilter<"RewardBreakdown"> | string
    rewardId?: StringFilter<"RewardBreakdown"> | string
    campaignId?: StringFilter<"RewardBreakdown"> | string
    subCampaignId?: StringNullableFilter<"RewardBreakdown"> | string | null
  }

  export type DailyRewardsBreakdownUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    update: XOR<DailyRewardsBreakdownUpdateWithoutCampaignInput, DailyRewardsBreakdownUncheckedUpdateWithoutCampaignInput>
    create: XOR<DailyRewardsBreakdownCreateWithoutCampaignInput, DailyRewardsBreakdownUncheckedCreateWithoutCampaignInput>
  }

  export type DailyRewardsBreakdownUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    data: XOR<DailyRewardsBreakdownUpdateWithoutCampaignInput, DailyRewardsBreakdownUncheckedUpdateWithoutCampaignInput>
  }

  export type DailyRewardsBreakdownUpdateManyWithWhereWithoutCampaignInput = {
    where: DailyRewardsBreakdownScalarWhereInput
    data: XOR<DailyRewardsBreakdownUpdateManyMutationInput, DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignInput>
  }

  export type DailyRewardsBreakdownScalarWhereInput = {
    AND?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
    OR?: DailyRewardsBreakdownScalarWhereInput[]
    NOT?: DailyRewardsBreakdownScalarWhereInput | DailyRewardsBreakdownScalarWhereInput[]
    id?: UuidFilter<"DailyRewardsBreakdown"> | string
    value?: FloatFilter<"DailyRewardsBreakdown"> | number
    campaignId?: StringFilter<"DailyRewardsBreakdown"> | string
    dailyRewardsRecordId?: StringFilter<"DailyRewardsBreakdown"> | string
  }

  export type UserUpsertWithoutCampaignsCreatedInput = {
    update: XOR<UserUpdateWithoutCampaignsCreatedInput, UserUncheckedUpdateWithoutCampaignsCreatedInput>
    create: XOR<UserCreateWithoutCampaignsCreatedInput, UserUncheckedCreateWithoutCampaignsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsCreatedInput, UserUncheckedUpdateWithoutCampaignsCreatedInput>
  }

  export type UserUpdateWithoutCampaignsCreatedInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUpdateManyWithoutUserNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutUserNestedInput
    Creator?: CreatorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsCreatedInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    Rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignStatusUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignStatusWhereUniqueInput
    update: XOR<CampaignStatusUpdateWithoutCampaignInput, CampaignStatusUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignStatusCreateWithoutCampaignInput, CampaignStatusUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignStatusUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignStatusWhereUniqueInput
    data: XOR<CampaignStatusUpdateWithoutCampaignInput, CampaignStatusUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignStatusUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignStatusScalarWhereInput
    data: XOR<CampaignStatusUpdateManyMutationInput, CampaignStatusUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignStatusScalarWhereInput = {
    AND?: CampaignStatusScalarWhereInput | CampaignStatusScalarWhereInput[]
    OR?: CampaignStatusScalarWhereInput[]
    NOT?: CampaignStatusScalarWhereInput | CampaignStatusScalarWhereInput[]
    campaignId?: StringFilter<"CampaignStatus"> | string
    computedUntil?: BigIntFilter<"CampaignStatus"> | bigint | number
    processingStarted?: BigIntFilter<"CampaignStatus"> | bigint | number
    status?: EnumRunStatusFilter<"CampaignStatus"> | $Enums.RunStatus
    error?: StringFilter<"CampaignStatus"> | string
    details?: JsonFilter<"CampaignStatus">
  }

  export type CampaignComputedValueUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignComputedValueWhereUniqueInput
    update: XOR<CampaignComputedValueUpdateWithoutCampaignInput, CampaignComputedValueUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignComputedValueCreateWithoutCampaignInput, CampaignComputedValueUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignComputedValueUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignComputedValueWhereUniqueInput
    data: XOR<CampaignComputedValueUpdateWithoutCampaignInput, CampaignComputedValueUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignComputedValueUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignComputedValueScalarWhereInput
    data: XOR<CampaignComputedValueUpdateManyMutationInput, CampaignComputedValueUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignComputedValueScalarWhereInput = {
    AND?: CampaignComputedValueScalarWhereInput | CampaignComputedValueScalarWhereInput[]
    OR?: CampaignComputedValueScalarWhereInput[]
    NOT?: CampaignComputedValueScalarWhereInput | CampaignComputedValueScalarWhereInput[]
    campaignId?: StringFilter<"CampaignComputedValue"> | string
    averageBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    totalDistributedInUSD?: FloatNullableFilter<"CampaignComputedValue"> | number | null
    forfeitingBoost?: FloatNullableFilter<"CampaignComputedValue"> | number | null
  }

  export type UserComputedValueUpsertWithWhereUniqueWithoutCampaignInput = {
    where: UserComputedValueWhereUniqueInput
    update: XOR<UserComputedValueUpdateWithoutCampaignInput, UserComputedValueUncheckedUpdateWithoutCampaignInput>
    create: XOR<UserComputedValueCreateWithoutCampaignInput, UserComputedValueUncheckedCreateWithoutCampaignInput>
  }

  export type UserComputedValueUpdateWithWhereUniqueWithoutCampaignInput = {
    where: UserComputedValueWhereUniqueInput
    data: XOR<UserComputedValueUpdateWithoutCampaignInput, UserComputedValueUncheckedUpdateWithoutCampaignInput>
  }

  export type UserComputedValueUpdateManyWithWhereWithoutCampaignInput = {
    where: UserComputedValueScalarWhereInput
    data: XOR<UserComputedValueUpdateManyMutationInput, UserComputedValueUncheckedUpdateManyWithoutCampaignInput>
  }

  export type UserComputedValueScalarWhereInput = {
    AND?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
    OR?: UserComputedValueScalarWhereInput[]
    NOT?: UserComputedValueScalarWhereInput | UserComputedValueScalarWhereInput[]
    id?: UuidFilter<"UserComputedValue"> | string
    campaignId?: StringFilter<"UserComputedValue"> | string
    address?: StringFilter<"UserComputedValue"> | string
    reason?: StringFilter<"UserComputedValue"> | string
    boost?: FloatNullableFilter<"UserComputedValue"> | number | null
  }

  export type CampaignUpsertWithoutSubCampaignsInput = {
    update: XOR<CampaignUpdateWithoutSubCampaignsInput, CampaignUncheckedUpdateWithoutSubCampaignsInput>
    create: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSubCampaignsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSubCampaignsInput, CampaignUncheckedUpdateWithoutSubCampaignsInput>
  }

  export type CampaignUpdateWithoutSubCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSubCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutRootCampaignInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutRootCampaignInput, CampaignUncheckedUpdateWithoutRootCampaignInput>
    create: XOR<CampaignCreateWithoutRootCampaignInput, CampaignUncheckedCreateWithoutRootCampaignInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutRootCampaignInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutRootCampaignInput, CampaignUncheckedUpdateWithoutRootCampaignInput>
  }

  export type CampaignUpdateManyWithWhereWithoutRootCampaignInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutRootCampaignInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    computeChainId?: IntFilter<"Campaign"> | number
    distributionChainId?: IntFilter<"Campaign"> | number
    campaignId?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    distributionType?: EnumDistributionTypeFilter<"Campaign"> | $Enums.DistributionType
    subType?: IntNullableFilter<"Campaign"> | number | null
    rewardTokenId?: StringFilter<"Campaign"> | string
    amount?: StringFilter<"Campaign"> | string
    opportunityId?: StringFilter<"Campaign"> | string
    startTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    endTimestamp?: BigIntFilter<"Campaign"> | bigint | number
    params?: JsonFilter<"Campaign">
    description?: StringNullableFilter<"Campaign"> | string | null
    creatorAddress?: StringFilter<"Campaign"> | string
    manualOverrides?: EnumCampaignManualOverrideNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    rootCampaignId?: StringNullableFilter<"Campaign"> | string | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
  }

  export type CampaignUpsertWithoutChildCampaignsInput = {
    update: XOR<CampaignUpdateWithoutChildCampaignsInput, CampaignUncheckedUpdateWithoutChildCampaignsInput>
    create: XOR<CampaignCreateWithoutChildCampaignsInput, CampaignUncheckedCreateWithoutChildCampaignsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutChildCampaignsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutChildCampaignsInput, CampaignUncheckedUpdateWithoutChildCampaignsInput>
  }

  export type CampaignUpdateWithoutChildCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutChildCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutParentCampaignInput, CampaignUncheckedUpdateWithoutParentCampaignInput>
    create: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutParentCampaignInput, CampaignUncheckedUpdateWithoutParentCampaignInput>
  }

  export type CampaignUpdateManyWithWhereWithoutParentCampaignInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutParentCampaignInput>
  }

  export type RewardBreakdownUpsertWithWhereUniqueWithoutSubCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    update: XOR<RewardBreakdownUpdateWithoutSubCampaignInput, RewardBreakdownUncheckedUpdateWithoutSubCampaignInput>
    create: XOR<RewardBreakdownCreateWithoutSubCampaignInput, RewardBreakdownUncheckedCreateWithoutSubCampaignInput>
  }

  export type RewardBreakdownUpdateWithWhereUniqueWithoutSubCampaignInput = {
    where: RewardBreakdownWhereUniqueInput
    data: XOR<RewardBreakdownUpdateWithoutSubCampaignInput, RewardBreakdownUncheckedUpdateWithoutSubCampaignInput>
  }

  export type RewardBreakdownUpdateManyWithWhereWithoutSubCampaignInput = {
    where: RewardBreakdownScalarWhereInput
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyWithoutSubCampaignInput>
  }

  export type CampaignCreateWithoutCampaignStatusInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaignStatusInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaignStatusInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignStatusInput, CampaignUncheckedCreateWithoutCampaignStatusInput>
  }

  export type CampaignUpsertWithoutCampaignStatusInput = {
    update: XOR<CampaignUpdateWithoutCampaignStatusInput, CampaignUncheckedUpdateWithoutCampaignStatusInput>
    create: XOR<CampaignCreateWithoutCampaignStatusInput, CampaignUncheckedCreateWithoutCampaignStatusInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignStatusInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignStatusInput, CampaignUncheckedUpdateWithoutCampaignStatusInput>
  }

  export type CampaignUpdateWithoutCampaignStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignCreateWithoutCampaignEngineValuesInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaignEngineValuesInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaignEngineValuesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignEngineValuesInput, CampaignUncheckedCreateWithoutCampaignEngineValuesInput>
  }

  export type CampaignUpsertWithoutCampaignEngineValuesInput = {
    update: XOR<CampaignUpdateWithoutCampaignEngineValuesInput, CampaignUncheckedUpdateWithoutCampaignEngineValuesInput>
    create: XOR<CampaignCreateWithoutCampaignEngineValuesInput, CampaignUncheckedCreateWithoutCampaignEngineValuesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignEngineValuesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignEngineValuesInput, CampaignUncheckedUpdateWithoutCampaignEngineValuesInput>
  }

  export type CampaignUpdateWithoutCampaignEngineValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignEngineValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignCreateWithoutUserComputedValueInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutUserComputedValueInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserComputedValueInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserComputedValueInput, CampaignUncheckedCreateWithoutUserComputedValueInput>
  }

  export type UserCreateWithoutUserComputedValueInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignCreateNestedManyWithoutCreatorInput
    Creator?: CreatorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUserComputedValueInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
    Rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUserComputedValueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserComputedValueInput, UserUncheckedCreateWithoutUserComputedValueInput>
  }

  export type CampaignUpsertWithoutUserComputedValueInput = {
    update: XOR<CampaignUpdateWithoutUserComputedValueInput, CampaignUncheckedUpdateWithoutUserComputedValueInput>
    create: XOR<CampaignCreateWithoutUserComputedValueInput, CampaignUncheckedCreateWithoutUserComputedValueInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutUserComputedValueInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutUserComputedValueInput, CampaignUncheckedUpdateWithoutUserComputedValueInput>
  }

  export type CampaignUpdateWithoutUserComputedValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserComputedValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type UserUpsertWithoutUserComputedValueInput = {
    update: XOR<UserUpdateWithoutUserComputedValueInput, UserUncheckedUpdateWithoutUserComputedValueInput>
    create: XOR<UserCreateWithoutUserComputedValueInput, UserUncheckedCreateWithoutUserComputedValueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserComputedValueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserComputedValueInput, UserUncheckedUpdateWithoutUserComputedValueInput>
  }

  export type UserUpdateWithoutUserComputedValueInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUpdateManyWithoutCreatorNestedInput
    Creator?: CreatorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUserComputedValueInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    Rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ExplorerCreateWithoutChainInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
  }

  export type ExplorerUncheckedCreateWithoutChainInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
  }

  export type ExplorerCreateOrConnectWithoutChainInput = {
    where: ExplorerWhereUniqueInput
    create: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput>
  }

  export type ExplorerCreateManyChainInputEnvelope = {
    data: ExplorerCreateManyChainInput | ExplorerCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutComputeChainInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutComputeChainInput = {
    id: string
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutComputeChainInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput>
  }

  export type CampaignCreateManyComputeChainInputEnvelope = {
    data: CampaignCreateManyComputeChainInput | CampaignCreateManyComputeChainInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutDistributionChainInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutDistributionChainInput = {
    id: string
    computeChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutDistributionChainInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput>
  }

  export type CampaignCreateManyDistributionChainInputEnvelope = {
    data: CampaignCreateManyDistributionChainInput | CampaignCreateManyDistributionChainInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutChainInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateWithoutChainInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenCreateOrConnectWithoutChainInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput>
  }

  export type TokenCreateManyChainInputEnvelope = {
    data: TokenCreateManyChainInput | TokenCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutChainInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutChainInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutChainInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput>
  }

  export type OpportunityCreateManyChainInputEnvelope = {
    data: OpportunityCreateManyChainInput | OpportunityCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type MerklRootCreateWithoutChainInput = {
    root: string
    epoch: number
    timestamp: bigint | number
    Rewards?: RewardCreateNestedManyWithoutMerklRootInput
  }

  export type MerklRootUncheckedCreateWithoutChainInput = {
    root: string
    epoch: number
    timestamp: bigint | number
    Rewards?: RewardUncheckedCreateNestedManyWithoutMerklRootInput
  }

  export type MerklRootCreateOrConnectWithoutChainInput = {
    where: MerklRootWhereUniqueInput
    create: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput>
  }

  export type MerklRootCreateManyChainInputEnvelope = {
    data: MerklRootCreateManyChainInput | MerklRootCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type BlacklistCreateWithoutChainInput = {
    id: string
    poolAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
    User: UserCreateNestedOneWithoutBlacklistInput
  }

  export type BlacklistUncheckedCreateWithoutChainInput = {
    id: string
    poolAddress: string
    userAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistCreateOrConnectWithoutChainInput = {
    where: BlacklistWhereUniqueInput
    create: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput>
  }

  export type BlacklistCreateManyChainInputEnvelope = {
    data: BlacklistCreateManyChainInput | BlacklistCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type DumpCreateWithoutChainInput = {
    id: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
    FromToken: TokenCreateNestedOneWithoutDumpFromInput
    ToToken: TokenCreateNestedOneWithoutDumpToInput
  }

  export type DumpUncheckedCreateWithoutChainInput = {
    id: string
    fromTokenId: string
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpCreateOrConnectWithoutChainInput = {
    where: DumpWhereUniqueInput
    create: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput>
  }

  export type DumpCreateManyChainInputEnvelope = {
    data: DumpCreateManyChainInput | DumpCreateManyChainInput[]
    skipDuplicates?: boolean
  }

  export type ExplorerUpsertWithWhereUniqueWithoutChainInput = {
    where: ExplorerWhereUniqueInput
    update: XOR<ExplorerUpdateWithoutChainInput, ExplorerUncheckedUpdateWithoutChainInput>
    create: XOR<ExplorerCreateWithoutChainInput, ExplorerUncheckedCreateWithoutChainInput>
  }

  export type ExplorerUpdateWithWhereUniqueWithoutChainInput = {
    where: ExplorerWhereUniqueInput
    data: XOR<ExplorerUpdateWithoutChainInput, ExplorerUncheckedUpdateWithoutChainInput>
  }

  export type ExplorerUpdateManyWithWhereWithoutChainInput = {
    where: ExplorerScalarWhereInput
    data: XOR<ExplorerUpdateManyMutationInput, ExplorerUncheckedUpdateManyWithoutChainInput>
  }

  export type ExplorerScalarWhereInput = {
    AND?: ExplorerScalarWhereInput | ExplorerScalarWhereInput[]
    OR?: ExplorerScalarWhereInput[]
    NOT?: ExplorerScalarWhereInput | ExplorerScalarWhereInput[]
    id?: StringFilter<"Explorer"> | string
    type?: EnumExplorerTypeFilter<"Explorer"> | $Enums.ExplorerType
    url?: StringFilter<"Explorer"> | string
    chainId?: IntFilter<"Explorer"> | number
  }

  export type CampaignUpsertWithWhereUniqueWithoutComputeChainInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutComputeChainInput, CampaignUncheckedUpdateWithoutComputeChainInput>
    create: XOR<CampaignCreateWithoutComputeChainInput, CampaignUncheckedCreateWithoutComputeChainInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutComputeChainInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutComputeChainInput, CampaignUncheckedUpdateWithoutComputeChainInput>
  }

  export type CampaignUpdateManyWithWhereWithoutComputeChainInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutComputeChainInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutDistributionChainInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutDistributionChainInput, CampaignUncheckedUpdateWithoutDistributionChainInput>
    create: XOR<CampaignCreateWithoutDistributionChainInput, CampaignUncheckedCreateWithoutDistributionChainInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutDistributionChainInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutDistributionChainInput, CampaignUncheckedUpdateWithoutDistributionChainInput>
  }

  export type CampaignUpdateManyWithWhereWithoutDistributionChainInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutDistributionChainInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutChainInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutChainInput, TokenUncheckedUpdateWithoutChainInput>
    create: XOR<TokenCreateWithoutChainInput, TokenUncheckedCreateWithoutChainInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutChainInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutChainInput, TokenUncheckedUpdateWithoutChainInput>
  }

  export type TokenUpdateManyWithWhereWithoutChainInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutChainInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringNullableFilter<"Token"> | string | null
    chainId?: IntFilter<"Token"> | number
    address?: StringFilter<"Token"> | string
    decimals?: IntFilter<"Token"> | number
    symbol?: StringFilter<"Token"> | string
    displaySymbol?: StringFilter<"Token"> | string
    icon?: StringFilter<"Token"> | string
    verified?: BoolFilter<"Token"> | boolean
    isTest?: BoolFilter<"Token"> | boolean
    isPoint?: BoolFilter<"Token"> | boolean
    isPreTGE?: BoolFilter<"Token"> | boolean
    isNative?: BoolFilter<"Token"> | boolean
    price?: FloatNullableFilter<"Token"> | number | null
  }

  export type OpportunityUpsertWithWhereUniqueWithoutChainInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutChainInput, OpportunityUncheckedUpdateWithoutChainInput>
    create: XOR<OpportunityCreateWithoutChainInput, OpportunityUncheckedCreateWithoutChainInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutChainInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutChainInput, OpportunityUncheckedUpdateWithoutChainInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutChainInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutChainInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    chainId?: IntFilter<"Opportunity"> | number
    type?: StringFilter<"Opportunity"> | string
    identifier?: StringFilter<"Opportunity"> | string
    name?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    howToSteps?: StringNullableListFilter<"Opportunity">
    depositUrl?: StringNullableFilter<"Opportunity"> | string | null
    explorerAddress?: StringNullableFilter<"Opportunity"> | string | null
    status?: EnumStatusFilter<"Opportunity"> | $Enums.Status
    action?: EnumOpportunityActionFilter<"Opportunity"> | $Enums.OpportunityAction
    mainProtocolId?: StringNullableFilter<"Opportunity"> | string | null
    tvl?: FloatFilter<"Opportunity"> | number
    apr?: FloatFilter<"Opportunity"> | number
    dailyRewards?: FloatFilter<"Opportunity"> | number
    tags?: StringNullableListFilter<"Opportunity">
    lastCampaignCreatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    manualOverrides?: EnumOpportunityManualOverrideNullableListFilter<"Opportunity">
  }

  export type MerklRootUpsertWithWhereUniqueWithoutChainInput = {
    where: MerklRootWhereUniqueInput
    update: XOR<MerklRootUpdateWithoutChainInput, MerklRootUncheckedUpdateWithoutChainInput>
    create: XOR<MerklRootCreateWithoutChainInput, MerklRootUncheckedCreateWithoutChainInput>
  }

  export type MerklRootUpdateWithWhereUniqueWithoutChainInput = {
    where: MerklRootWhereUniqueInput
    data: XOR<MerklRootUpdateWithoutChainInput, MerklRootUncheckedUpdateWithoutChainInput>
  }

  export type MerklRootUpdateManyWithWhereWithoutChainInput = {
    where: MerklRootScalarWhereInput
    data: XOR<MerklRootUpdateManyMutationInput, MerklRootUncheckedUpdateManyWithoutChainInput>
  }

  export type MerklRootScalarWhereInput = {
    AND?: MerklRootScalarWhereInput | MerklRootScalarWhereInput[]
    OR?: MerklRootScalarWhereInput[]
    NOT?: MerklRootScalarWhereInput | MerklRootScalarWhereInput[]
    root?: StringFilter<"MerklRoot"> | string
    chainId?: IntFilter<"MerklRoot"> | number
    epoch?: IntFilter<"MerklRoot"> | number
    timestamp?: BigIntFilter<"MerklRoot"> | bigint | number
  }

  export type BlacklistUpsertWithWhereUniqueWithoutChainInput = {
    where: BlacklistWhereUniqueInput
    update: XOR<BlacklistUpdateWithoutChainInput, BlacklistUncheckedUpdateWithoutChainInput>
    create: XOR<BlacklistCreateWithoutChainInput, BlacklistUncheckedCreateWithoutChainInput>
  }

  export type BlacklistUpdateWithWhereUniqueWithoutChainInput = {
    where: BlacklistWhereUniqueInput
    data: XOR<BlacklistUpdateWithoutChainInput, BlacklistUncheckedUpdateWithoutChainInput>
  }

  export type BlacklistUpdateManyWithWhereWithoutChainInput = {
    where: BlacklistScalarWhereInput
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyWithoutChainInput>
  }

  export type BlacklistScalarWhereInput = {
    AND?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
    OR?: BlacklistScalarWhereInput[]
    NOT?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
    id?: StringFilter<"Blacklist"> | string
    chainId?: IntFilter<"Blacklist"> | number
    poolAddress?: StringFilter<"Blacklist"> | string
    userAddress?: StringFilter<"Blacklist"> | string
    arrestTimestamp?: BigIntFilter<"Blacklist"> | bigint | number
    arrestDetails?: JsonFilter<"Blacklist">
  }

  export type DumpUpsertWithWhereUniqueWithoutChainInput = {
    where: DumpWhereUniqueInput
    update: XOR<DumpUpdateWithoutChainInput, DumpUncheckedUpdateWithoutChainInput>
    create: XOR<DumpCreateWithoutChainInput, DumpUncheckedCreateWithoutChainInput>
  }

  export type DumpUpdateWithWhereUniqueWithoutChainInput = {
    where: DumpWhereUniqueInput
    data: XOR<DumpUpdateWithoutChainInput, DumpUncheckedUpdateWithoutChainInput>
  }

  export type DumpUpdateManyWithWhereWithoutChainInput = {
    where: DumpScalarWhereInput
    data: XOR<DumpUpdateManyMutationInput, DumpUncheckedUpdateManyWithoutChainInput>
  }

  export type DumpScalarWhereInput = {
    AND?: DumpScalarWhereInput | DumpScalarWhereInput[]
    OR?: DumpScalarWhereInput[]
    NOT?: DumpScalarWhereInput | DumpScalarWhereInput[]
    id?: StringFilter<"Dump"> | string
    chainId?: IntFilter<"Dump"> | number
    fromTokenId?: StringFilter<"Dump"> | string
    toTokenId?: StringFilter<"Dump"> | string
    multisig?: StringFilter<"Dump"> | string
    recipient?: StringFilter<"Dump"> | string
    amountIn?: StringFilter<"Dump"> | string
    amountOut?: StringFilter<"Dump"> | string
    datetime?: DateTimeFilter<"Dump"> | Date | string
    timestamp?: IntFilter<"Dump"> | number
  }

  export type ChainCreateWithoutExplorerInput = {
    id: number
    name: string
    icon: string
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutExplorerInput = {
    id: number
    name: string
    icon: string
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutExplorerInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutExplorerInput, ChainUncheckedCreateWithoutExplorerInput>
  }

  export type ChainUpsertWithoutExplorerInput = {
    update: XOR<ChainUpdateWithoutExplorerInput, ChainUncheckedUpdateWithoutExplorerInput>
    create: XOR<ChainCreateWithoutExplorerInput, ChainUncheckedCreateWithoutExplorerInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutExplorerInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutExplorerInput, ChainUncheckedUpdateWithoutExplorerInput>
  }

  export type ChainUpdateWithoutExplorerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutExplorerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type ChainCreateWithoutOpportunityInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutOpportunityInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutOpportunityInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutOpportunityInput, ChainUncheckedCreateWithoutOpportunityInput>
  }

  export type TokenCreateWithoutOpportunityInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateWithoutOpportunityInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenCreateOrConnectWithoutOpportunityInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput>
  }

  export type CampaignCreateWithoutOpportunityInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOpportunityInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOpportunityInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput>
  }

  export type CampaignCreateManyOpportunityInputEnvelope = {
    data: CampaignCreateManyOpportunityInput | CampaignCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolCreateWithoutOpportunitiesInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityCreateNestedManyWithoutMainProtocolInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutOpportunitiesInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityUncheckedCreateNestedManyWithoutMainProtocolInput
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutOpportunitiesInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput>
  }

  export type ProtocolCreateWithoutMainOpportunitiesInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    Opportunities?: OpportunityCreateNestedManyWithoutProtocolsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutMainOpportunitiesInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    Opportunities?: OpportunityUncheckedCreateNestedManyWithoutProtocolsInput
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutMainOpportunitiesInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutMainOpportunitiesInput, ProtocolUncheckedCreateWithoutMainOpportunitiesInput>
  }

  export type TVLRecordCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
    TvlBreakdown?: TVLBreakdownCreateNestedManyWithoutTvlRecordInput
  }

  export type TVLRecordUncheckedCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
    TvlBreakdown?: TVLBreakdownUncheckedCreateNestedManyWithoutTvlRecordInput
  }

  export type TVLRecordCreateOrConnectWithoutOpportunityInput = {
    where: TVLRecordWhereUniqueInput
    create: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type TVLRecordCreateManyOpportunityInputEnvelope = {
    data: TVLRecordCreateManyOpportunityInput | TVLRecordCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type AprRecordCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    AprBreakdown?: AprBreakdownCreateNestedManyWithoutAprRecordInput
  }

  export type AprRecordUncheckedCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    AprBreakdown?: AprBreakdownUncheckedCreateNestedManyWithoutAprRecordInput
  }

  export type AprRecordCreateOrConnectWithoutOpportunityInput = {
    where: AprRecordWhereUniqueInput
    create: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type AprRecordCreateManyOpportunityInputEnvelope = {
    data: AprRecordCreateManyOpportunityInput | AprRecordCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type DailyRewardsRecordCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutDailyRewardsRecordInput
  }

  export type DailyRewardsRecordUncheckedCreateWithoutOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutDailyRewardsRecordInput
  }

  export type DailyRewardsRecordCreateOrConnectWithoutOpportunityInput = {
    where: DailyRewardsRecordWhereUniqueInput
    create: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type DailyRewardsRecordCreateManyOpportunityInputEnvelope = {
    data: DailyRewardsRecordCreateManyOpportunityInput | DailyRewardsRecordCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ChainUpsertWithoutOpportunityInput = {
    update: XOR<ChainUpdateWithoutOpportunityInput, ChainUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ChainCreateWithoutOpportunityInput, ChainUncheckedCreateWithoutOpportunityInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutOpportunityInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutOpportunityInput, ChainUncheckedUpdateWithoutOpportunityInput>
  }

  export type ChainUpdateWithoutOpportunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutOpportunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type TokenUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutOpportunityInput, TokenUncheckedUpdateWithoutOpportunityInput>
    create: XOR<TokenCreateWithoutOpportunityInput, TokenUncheckedCreateWithoutOpportunityInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutOpportunityInput, TokenUncheckedUpdateWithoutOpportunityInput>
  }

  export type TokenUpdateManyWithWhereWithoutOpportunityInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutOpportunityInput, CampaignUncheckedUpdateWithoutOpportunityInput>
    create: XOR<CampaignCreateWithoutOpportunityInput, CampaignUncheckedCreateWithoutOpportunityInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutOpportunityInput, CampaignUncheckedUpdateWithoutOpportunityInput>
  }

  export type CampaignUpdateManyWithWhereWithoutOpportunityInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type ProtocolUpsertWithWhereUniqueWithoutOpportunitiesInput = {
    where: ProtocolWhereUniqueInput
    update: XOR<ProtocolUpdateWithoutOpportunitiesInput, ProtocolUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<ProtocolCreateWithoutOpportunitiesInput, ProtocolUncheckedCreateWithoutOpportunitiesInput>
  }

  export type ProtocolUpdateWithWhereUniqueWithoutOpportunitiesInput = {
    where: ProtocolWhereUniqueInput
    data: XOR<ProtocolUpdateWithoutOpportunitiesInput, ProtocolUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ProtocolUpdateManyWithWhereWithoutOpportunitiesInput = {
    where: ProtocolScalarWhereInput
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyWithoutOpportunitiesInput>
  }

  export type ProtocolScalarWhereInput = {
    AND?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
    OR?: ProtocolScalarWhereInput[]
    NOT?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
    id?: StringFilter<"Protocol"> | string
    tags?: StringNullableListFilter<"Protocol">
    name?: StringFilter<"Protocol"> | string
    description?: StringFilter<"Protocol"> | string
    url?: StringFilter<"Protocol"> | string
    icon?: StringFilter<"Protocol"> | string
  }

  export type ProtocolUpsertWithoutMainOpportunitiesInput = {
    update: XOR<ProtocolUpdateWithoutMainOpportunitiesInput, ProtocolUncheckedUpdateWithoutMainOpportunitiesInput>
    create: XOR<ProtocolCreateWithoutMainOpportunitiesInput, ProtocolUncheckedCreateWithoutMainOpportunitiesInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutMainOpportunitiesInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutMainOpportunitiesInput, ProtocolUncheckedUpdateWithoutMainOpportunitiesInput>
  }

  export type ProtocolUpdateWithoutMainOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Opportunities?: OpportunityUpdateManyWithoutProtocolsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutMainOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Opportunities?: OpportunityUncheckedUpdateManyWithoutProtocolsNestedInput
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type TVLRecordUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: TVLRecordWhereUniqueInput
    update: XOR<TVLRecordUpdateWithoutOpportunityInput, TVLRecordUncheckedUpdateWithoutOpportunityInput>
    create: XOR<TVLRecordCreateWithoutOpportunityInput, TVLRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type TVLRecordUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: TVLRecordWhereUniqueInput
    data: XOR<TVLRecordUpdateWithoutOpportunityInput, TVLRecordUncheckedUpdateWithoutOpportunityInput>
  }

  export type TVLRecordUpdateManyWithWhereWithoutOpportunityInput = {
    where: TVLRecordScalarWhereInput
    data: XOR<TVLRecordUpdateManyMutationInput, TVLRecordUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type TVLRecordScalarWhereInput = {
    AND?: TVLRecordScalarWhereInput | TVLRecordScalarWhereInput[]
    OR?: TVLRecordScalarWhereInput[]
    NOT?: TVLRecordScalarWhereInput | TVLRecordScalarWhereInput[]
    id?: StringFilter<"TVLRecord"> | string
    timestamp?: BigIntFilter<"TVLRecord"> | bigint | number
    total?: FloatFilter<"TVLRecord"> | number
    opportunityId?: StringFilter<"TVLRecord"> | string
  }

  export type AprRecordUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: AprRecordWhereUniqueInput
    update: XOR<AprRecordUpdateWithoutOpportunityInput, AprRecordUncheckedUpdateWithoutOpportunityInput>
    create: XOR<AprRecordCreateWithoutOpportunityInput, AprRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type AprRecordUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: AprRecordWhereUniqueInput
    data: XOR<AprRecordUpdateWithoutOpportunityInput, AprRecordUncheckedUpdateWithoutOpportunityInput>
  }

  export type AprRecordUpdateManyWithWhereWithoutOpportunityInput = {
    where: AprRecordScalarWhereInput
    data: XOR<AprRecordUpdateManyMutationInput, AprRecordUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type AprRecordScalarWhereInput = {
    AND?: AprRecordScalarWhereInput | AprRecordScalarWhereInput[]
    OR?: AprRecordScalarWhereInput[]
    NOT?: AprRecordScalarWhereInput | AprRecordScalarWhereInput[]
    id?: StringFilter<"AprRecord"> | string
    timestamp?: BigIntFilter<"AprRecord"> | bigint | number
    cumulated?: FloatFilter<"AprRecord"> | number
    opportunityId?: StringFilter<"AprRecord"> | string
  }

  export type DailyRewardsRecordUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: DailyRewardsRecordWhereUniqueInput
    update: XOR<DailyRewardsRecordUpdateWithoutOpportunityInput, DailyRewardsRecordUncheckedUpdateWithoutOpportunityInput>
    create: XOR<DailyRewardsRecordCreateWithoutOpportunityInput, DailyRewardsRecordUncheckedCreateWithoutOpportunityInput>
  }

  export type DailyRewardsRecordUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: DailyRewardsRecordWhereUniqueInput
    data: XOR<DailyRewardsRecordUpdateWithoutOpportunityInput, DailyRewardsRecordUncheckedUpdateWithoutOpportunityInput>
  }

  export type DailyRewardsRecordUpdateManyWithWhereWithoutOpportunityInput = {
    where: DailyRewardsRecordScalarWhereInput
    data: XOR<DailyRewardsRecordUpdateManyMutationInput, DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type DailyRewardsRecordScalarWhereInput = {
    AND?: DailyRewardsRecordScalarWhereInput | DailyRewardsRecordScalarWhereInput[]
    OR?: DailyRewardsRecordScalarWhereInput[]
    NOT?: DailyRewardsRecordScalarWhereInput | DailyRewardsRecordScalarWhereInput[]
    id?: StringFilter<"DailyRewardsRecord"> | string
    timestamp?: BigIntFilter<"DailyRewardsRecord"> | bigint | number
    total?: FloatFilter<"DailyRewardsRecord"> | number
    opportunityId?: StringFilter<"DailyRewardsRecord"> | string
  }

  export type OpportunityCreateWithoutMainProtocolInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutMainProtocolInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutMainProtocolInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput>
  }

  export type OpportunityCreateManyMainProtocolInputEnvelope = {
    data: OpportunityCreateManyMainProtocolInput | OpportunityCreateManyMainProtocolInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutProtocolsInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutProtocolsInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutProtocolsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput>
  }

  export type RewardBreakdownCreateWithoutProtocolInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    Reward: RewardCreateNestedOneWithoutBreakdownInput
    Campaign: CampaignCreateNestedOneWithoutRewardBreakdownInput
    SubCampaign?: CampaignCreateNestedOneWithoutRewardBreakdownSubCampaignInput
  }

  export type RewardBreakdownUncheckedCreateWithoutProtocolInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownCreateOrConnectWithoutProtocolInput = {
    where: RewardBreakdownWhereUniqueInput
    create: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput>
  }

  export type RewardBreakdownCreateManyProtocolInputEnvelope = {
    data: RewardBreakdownCreateManyProtocolInput | RewardBreakdownCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityUpsertWithWhereUniqueWithoutMainProtocolInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutMainProtocolInput, OpportunityUncheckedUpdateWithoutMainProtocolInput>
    create: XOR<OpportunityCreateWithoutMainProtocolInput, OpportunityUncheckedCreateWithoutMainProtocolInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutMainProtocolInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutMainProtocolInput, OpportunityUncheckedUpdateWithoutMainProtocolInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutMainProtocolInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutMainProtocolInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutProtocolsInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutProtocolsInput, OpportunityUncheckedUpdateWithoutProtocolsInput>
    create: XOR<OpportunityCreateWithoutProtocolsInput, OpportunityUncheckedCreateWithoutProtocolsInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutProtocolsInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutProtocolsInput, OpportunityUncheckedUpdateWithoutProtocolsInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutProtocolsInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutProtocolsInput>
  }

  export type RewardBreakdownUpsertWithWhereUniqueWithoutProtocolInput = {
    where: RewardBreakdownWhereUniqueInput
    update: XOR<RewardBreakdownUpdateWithoutProtocolInput, RewardBreakdownUncheckedUpdateWithoutProtocolInput>
    create: XOR<RewardBreakdownCreateWithoutProtocolInput, RewardBreakdownUncheckedCreateWithoutProtocolInput>
  }

  export type RewardBreakdownUpdateWithWhereUniqueWithoutProtocolInput = {
    where: RewardBreakdownWhereUniqueInput
    data: XOR<RewardBreakdownUpdateWithoutProtocolInput, RewardBreakdownUncheckedUpdateWithoutProtocolInput>
  }

  export type RewardBreakdownUpdateManyWithWhereWithoutProtocolInput = {
    where: RewardBreakdownScalarWhereInput
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyWithoutProtocolInput>
  }

  export type ChainCreateWithoutTokenInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutTokenInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutTokenInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutTokenInput, ChainUncheckedCreateWithoutTokenInput>
  }

  export type OpportunityCreateWithoutTokensInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutTokensInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutTokensInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput>
  }

  export type CampaignCreateWithoutRewardTokenInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRewardTokenInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRewardTokenInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput>
  }

  export type CampaignCreateManyRewardTokenInputEnvelope = {
    data: CampaignCreateManyRewardTokenInput | CampaignCreateManyRewardTokenInput[]
    skipDuplicates?: boolean
  }

  export type RewardCreateWithoutRewardTokenInput = {
    id: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    MerklRoot: MerklRootCreateNestedOneWithoutRewardsInput
    User: UserCreateNestedOneWithoutRewardsInput
    Breakdown?: RewardBreakdownCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutRewardTokenInput = {
    id: string
    root: string
    recipient: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutRewardTokenInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput>
  }

  export type RewardCreateManyRewardTokenInputEnvelope = {
    data: RewardCreateManyRewardTokenInput | RewardCreateManyRewardTokenInput[]
    skipDuplicates?: boolean
  }

  export type DumpCreateWithoutToTokenInput = {
    id: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
    Chain: ChainCreateNestedOneWithoutDumpInput
    FromToken: TokenCreateNestedOneWithoutDumpFromInput
  }

  export type DumpUncheckedCreateWithoutToTokenInput = {
    id: string
    chainId: number
    fromTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpCreateOrConnectWithoutToTokenInput = {
    where: DumpWhereUniqueInput
    create: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput>
  }

  export type DumpCreateManyToTokenInputEnvelope = {
    data: DumpCreateManyToTokenInput | DumpCreateManyToTokenInput[]
    skipDuplicates?: boolean
  }

  export type DumpCreateWithoutFromTokenInput = {
    id: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
    Chain: ChainCreateNestedOneWithoutDumpInput
    ToToken: TokenCreateNestedOneWithoutDumpToInput
  }

  export type DumpUncheckedCreateWithoutFromTokenInput = {
    id: string
    chainId: number
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpCreateOrConnectWithoutFromTokenInput = {
    where: DumpWhereUniqueInput
    create: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput>
  }

  export type DumpCreateManyFromTokenInputEnvelope = {
    data: DumpCreateManyFromTokenInput | DumpCreateManyFromTokenInput[]
    skipDuplicates?: boolean
  }

  export type ChainUpsertWithoutTokenInput = {
    update: XOR<ChainUpdateWithoutTokenInput, ChainUncheckedUpdateWithoutTokenInput>
    create: XOR<ChainCreateWithoutTokenInput, ChainUncheckedCreateWithoutTokenInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutTokenInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutTokenInput, ChainUncheckedUpdateWithoutTokenInput>
  }

  export type ChainUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type OpportunityUpsertWithWhereUniqueWithoutTokensInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutTokensInput, OpportunityUncheckedUpdateWithoutTokensInput>
    create: XOR<OpportunityCreateWithoutTokensInput, OpportunityUncheckedCreateWithoutTokensInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutTokensInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutTokensInput, OpportunityUncheckedUpdateWithoutTokensInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutTokensInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutTokensInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutRewardTokenInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutRewardTokenInput, CampaignUncheckedUpdateWithoutRewardTokenInput>
    create: XOR<CampaignCreateWithoutRewardTokenInput, CampaignUncheckedCreateWithoutRewardTokenInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutRewardTokenInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutRewardTokenInput, CampaignUncheckedUpdateWithoutRewardTokenInput>
  }

  export type CampaignUpdateManyWithWhereWithoutRewardTokenInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutRewardTokenInput>
  }

  export type RewardUpsertWithWhereUniqueWithoutRewardTokenInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutRewardTokenInput, RewardUncheckedUpdateWithoutRewardTokenInput>
    create: XOR<RewardCreateWithoutRewardTokenInput, RewardUncheckedCreateWithoutRewardTokenInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutRewardTokenInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutRewardTokenInput, RewardUncheckedUpdateWithoutRewardTokenInput>
  }

  export type RewardUpdateManyWithWhereWithoutRewardTokenInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutRewardTokenInput>
  }

  export type RewardScalarWhereInput = {
    AND?: RewardScalarWhereInput | RewardScalarWhereInput[]
    OR?: RewardScalarWhereInput[]
    NOT?: RewardScalarWhereInput | RewardScalarWhereInput[]
    id?: StringFilter<"Reward"> | string
    root?: StringFilter<"Reward"> | string
    recipient?: StringFilter<"Reward"> | string
    rewardTokenId?: StringFilter<"Reward"> | string
    amount?: StringFilter<"Reward"> | string
    claimed?: StringFilter<"Reward"> | string
    pending?: StringFilter<"Reward"> | string
    proofs?: StringNullableListFilter<"Reward">
  }

  export type DumpUpsertWithWhereUniqueWithoutToTokenInput = {
    where: DumpWhereUniqueInput
    update: XOR<DumpUpdateWithoutToTokenInput, DumpUncheckedUpdateWithoutToTokenInput>
    create: XOR<DumpCreateWithoutToTokenInput, DumpUncheckedCreateWithoutToTokenInput>
  }

  export type DumpUpdateWithWhereUniqueWithoutToTokenInput = {
    where: DumpWhereUniqueInput
    data: XOR<DumpUpdateWithoutToTokenInput, DumpUncheckedUpdateWithoutToTokenInput>
  }

  export type DumpUpdateManyWithWhereWithoutToTokenInput = {
    where: DumpScalarWhereInput
    data: XOR<DumpUpdateManyMutationInput, DumpUncheckedUpdateManyWithoutToTokenInput>
  }

  export type DumpUpsertWithWhereUniqueWithoutFromTokenInput = {
    where: DumpWhereUniqueInput
    update: XOR<DumpUpdateWithoutFromTokenInput, DumpUncheckedUpdateWithoutFromTokenInput>
    create: XOR<DumpCreateWithoutFromTokenInput, DumpUncheckedCreateWithoutFromTokenInput>
  }

  export type DumpUpdateWithWhereUniqueWithoutFromTokenInput = {
    where: DumpWhereUniqueInput
    data: XOR<DumpUpdateWithoutFromTokenInput, DumpUncheckedUpdateWithoutFromTokenInput>
  }

  export type DumpUpdateManyWithWhereWithoutFromTokenInput = {
    where: DumpScalarWhereInput
    data: XOR<DumpUpdateManyMutationInput, DumpUncheckedUpdateManyWithoutFromTokenInput>
  }

  export type AprBreakdownCreateWithoutAprRecordInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
  }

  export type AprBreakdownUncheckedCreateWithoutAprRecordInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
  }

  export type AprBreakdownCreateOrConnectWithoutAprRecordInput = {
    where: AprBreakdownWhereUniqueInput
    create: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput>
  }

  export type AprBreakdownCreateManyAprRecordInputEnvelope = {
    data: AprBreakdownCreateManyAprRecordInput | AprBreakdownCreateManyAprRecordInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutAprRecordsInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutAprRecordsInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutAprRecordsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutAprRecordsInput, OpportunityUncheckedCreateWithoutAprRecordsInput>
  }

  export type AprBreakdownUpsertWithWhereUniqueWithoutAprRecordInput = {
    where: AprBreakdownWhereUniqueInput
    update: XOR<AprBreakdownUpdateWithoutAprRecordInput, AprBreakdownUncheckedUpdateWithoutAprRecordInput>
    create: XOR<AprBreakdownCreateWithoutAprRecordInput, AprBreakdownUncheckedCreateWithoutAprRecordInput>
  }

  export type AprBreakdownUpdateWithWhereUniqueWithoutAprRecordInput = {
    where: AprBreakdownWhereUniqueInput
    data: XOR<AprBreakdownUpdateWithoutAprRecordInput, AprBreakdownUncheckedUpdateWithoutAprRecordInput>
  }

  export type AprBreakdownUpdateManyWithWhereWithoutAprRecordInput = {
    where: AprBreakdownScalarWhereInput
    data: XOR<AprBreakdownUpdateManyMutationInput, AprBreakdownUncheckedUpdateManyWithoutAprRecordInput>
  }

  export type AprBreakdownScalarWhereInput = {
    AND?: AprBreakdownScalarWhereInput | AprBreakdownScalarWhereInput[]
    OR?: AprBreakdownScalarWhereInput[]
    NOT?: AprBreakdownScalarWhereInput | AprBreakdownScalarWhereInput[]
    id?: UuidFilter<"AprBreakdown"> | string
    identifier?: StringFilter<"AprBreakdown"> | string
    type?: EnumAprTypeFilter<"AprBreakdown"> | $Enums.AprType
    value?: FloatFilter<"AprBreakdown"> | number
    aprRecordId?: StringFilter<"AprBreakdown"> | string
  }

  export type OpportunityUpsertWithoutAprRecordsInput = {
    update: XOR<OpportunityUpdateWithoutAprRecordsInput, OpportunityUncheckedUpdateWithoutAprRecordsInput>
    create: XOR<OpportunityCreateWithoutAprRecordsInput, OpportunityUncheckedCreateWithoutAprRecordsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutAprRecordsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutAprRecordsInput, OpportunityUncheckedUpdateWithoutAprRecordsInput>
  }

  export type OpportunityUpdateWithoutAprRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutAprRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type AprRecordCreateWithoutAprBreakdownInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    Opportunity: OpportunityCreateNestedOneWithoutAprRecordsInput
  }

  export type AprRecordUncheckedCreateWithoutAprBreakdownInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
    opportunityId: string
  }

  export type AprRecordCreateOrConnectWithoutAprBreakdownInput = {
    where: AprRecordWhereUniqueInput
    create: XOR<AprRecordCreateWithoutAprBreakdownInput, AprRecordUncheckedCreateWithoutAprBreakdownInput>
  }

  export type AprRecordUpsertWithoutAprBreakdownInput = {
    update: XOR<AprRecordUpdateWithoutAprBreakdownInput, AprRecordUncheckedUpdateWithoutAprBreakdownInput>
    create: XOR<AprRecordCreateWithoutAprBreakdownInput, AprRecordUncheckedCreateWithoutAprBreakdownInput>
    where?: AprRecordWhereInput
  }

  export type AprRecordUpdateToOneWithWhereWithoutAprBreakdownInput = {
    where?: AprRecordWhereInput
    data: XOR<AprRecordUpdateWithoutAprBreakdownInput, AprRecordUncheckedUpdateWithoutAprBreakdownInput>
  }

  export type AprRecordUpdateWithoutAprBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    Opportunity?: OpportunityUpdateOneRequiredWithoutAprRecordsNestedInput
  }

  export type AprRecordUncheckedUpdateWithoutAprBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type TVLBreakdownCreateWithoutTvlRecordInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
  }

  export type TVLBreakdownUncheckedCreateWithoutTvlRecordInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
  }

  export type TVLBreakdownCreateOrConnectWithoutTvlRecordInput = {
    where: TVLBreakdownWhereUniqueInput
    create: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput>
  }

  export type TVLBreakdownCreateManyTvlRecordInputEnvelope = {
    data: TVLBreakdownCreateManyTvlRecordInput | TVLBreakdownCreateManyTvlRecordInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutTvlRecordsInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutTvlRecordsInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutTvlRecordsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutTvlRecordsInput, OpportunityUncheckedCreateWithoutTvlRecordsInput>
  }

  export type TVLBreakdownUpsertWithWhereUniqueWithoutTvlRecordInput = {
    where: TVLBreakdownWhereUniqueInput
    update: XOR<TVLBreakdownUpdateWithoutTvlRecordInput, TVLBreakdownUncheckedUpdateWithoutTvlRecordInput>
    create: XOR<TVLBreakdownCreateWithoutTvlRecordInput, TVLBreakdownUncheckedCreateWithoutTvlRecordInput>
  }

  export type TVLBreakdownUpdateWithWhereUniqueWithoutTvlRecordInput = {
    where: TVLBreakdownWhereUniqueInput
    data: XOR<TVLBreakdownUpdateWithoutTvlRecordInput, TVLBreakdownUncheckedUpdateWithoutTvlRecordInput>
  }

  export type TVLBreakdownUpdateManyWithWhereWithoutTvlRecordInput = {
    where: TVLBreakdownScalarWhereInput
    data: XOR<TVLBreakdownUpdateManyMutationInput, TVLBreakdownUncheckedUpdateManyWithoutTvlRecordInput>
  }

  export type TVLBreakdownScalarWhereInput = {
    AND?: TVLBreakdownScalarWhereInput | TVLBreakdownScalarWhereInput[]
    OR?: TVLBreakdownScalarWhereInput[]
    NOT?: TVLBreakdownScalarWhereInput | TVLBreakdownScalarWhereInput[]
    id?: UuidFilter<"TVLBreakdown"> | string
    identifier?: StringFilter<"TVLBreakdown"> | string
    type?: EnumTvlTypeFilter<"TVLBreakdown"> | $Enums.TvlType
    value?: FloatFilter<"TVLBreakdown"> | number
    tvlRecordId?: StringFilter<"TVLBreakdown"> | string
  }

  export type OpportunityUpsertWithoutTvlRecordsInput = {
    update: XOR<OpportunityUpdateWithoutTvlRecordsInput, OpportunityUncheckedUpdateWithoutTvlRecordsInput>
    create: XOR<OpportunityCreateWithoutTvlRecordsInput, OpportunityUncheckedCreateWithoutTvlRecordsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutTvlRecordsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutTvlRecordsInput, OpportunityUncheckedUpdateWithoutTvlRecordsInput>
  }

  export type OpportunityUpdateWithoutTvlRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutTvlRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type TVLRecordCreateWithoutTvlBreakdownInput = {
    id: string
    timestamp: bigint | number
    total: number
    Opportunity: OpportunityCreateNestedOneWithoutTvlRecordsInput
  }

  export type TVLRecordUncheckedCreateWithoutTvlBreakdownInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
  }

  export type TVLRecordCreateOrConnectWithoutTvlBreakdownInput = {
    where: TVLRecordWhereUniqueInput
    create: XOR<TVLRecordCreateWithoutTvlBreakdownInput, TVLRecordUncheckedCreateWithoutTvlBreakdownInput>
  }

  export type TVLRecordUpsertWithoutTvlBreakdownInput = {
    update: XOR<TVLRecordUpdateWithoutTvlBreakdownInput, TVLRecordUncheckedUpdateWithoutTvlBreakdownInput>
    create: XOR<TVLRecordCreateWithoutTvlBreakdownInput, TVLRecordUncheckedCreateWithoutTvlBreakdownInput>
    where?: TVLRecordWhereInput
  }

  export type TVLRecordUpdateToOneWithWhereWithoutTvlBreakdownInput = {
    where?: TVLRecordWhereInput
    data: XOR<TVLRecordUpdateWithoutTvlBreakdownInput, TVLRecordUncheckedUpdateWithoutTvlBreakdownInput>
  }

  export type TVLRecordUpdateWithoutTvlBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    Opportunity?: OpportunityUpdateOneRequiredWithoutTvlRecordsNestedInput
  }

  export type TVLRecordUncheckedUpdateWithoutTvlBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput = {
    id?: string
    value: number
    Campaign: CampaignCreateNestedOneWithoutDailyRewardsBreakdownInput
  }

  export type DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput = {
    id?: string
    value: number
    campaignId: string
  }

  export type DailyRewardsBreakdownCreateOrConnectWithoutDailyRewardsRecordInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    create: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput>
  }

  export type DailyRewardsBreakdownCreateManyDailyRewardsRecordInputEnvelope = {
    data: DailyRewardsBreakdownCreateManyDailyRewardsRecordInput | DailyRewardsBreakdownCreateManyDailyRewardsRecordInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutDailyRewardsRecordsInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain: ChainCreateNestedOneWithoutOpportunityInput
    Tokens?: TokenCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolCreateNestedManyWithoutOpportunitiesInput
    MainProtocol?: ProtocolCreateNestedOneWithoutMainOpportunitiesInput
    TvlRecords?: TVLRecordCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutDailyRewardsRecordsInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedCreateNestedManyWithoutOpportunityInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutOpportunityInput
    Protocols?: ProtocolUncheckedCreateNestedManyWithoutOpportunitiesInput
    TvlRecords?: TVLRecordUncheckedCreateNestedManyWithoutOpportunityInput
    AprRecords?: AprRecordUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutDailyRewardsRecordsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutDailyRewardsRecordsInput, OpportunityUncheckedCreateWithoutDailyRewardsRecordsInput>
  }

  export type DailyRewardsBreakdownUpsertWithWhereUniqueWithoutDailyRewardsRecordInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    update: XOR<DailyRewardsBreakdownUpdateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedUpdateWithoutDailyRewardsRecordInput>
    create: XOR<DailyRewardsBreakdownCreateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedCreateWithoutDailyRewardsRecordInput>
  }

  export type DailyRewardsBreakdownUpdateWithWhereUniqueWithoutDailyRewardsRecordInput = {
    where: DailyRewardsBreakdownWhereUniqueInput
    data: XOR<DailyRewardsBreakdownUpdateWithoutDailyRewardsRecordInput, DailyRewardsBreakdownUncheckedUpdateWithoutDailyRewardsRecordInput>
  }

  export type DailyRewardsBreakdownUpdateManyWithWhereWithoutDailyRewardsRecordInput = {
    where: DailyRewardsBreakdownScalarWhereInput
    data: XOR<DailyRewardsBreakdownUpdateManyMutationInput, DailyRewardsBreakdownUncheckedUpdateManyWithoutDailyRewardsRecordInput>
  }

  export type OpportunityUpsertWithoutDailyRewardsRecordsInput = {
    update: XOR<OpportunityUpdateWithoutDailyRewardsRecordsInput, OpportunityUncheckedUpdateWithoutDailyRewardsRecordsInput>
    create: XOR<OpportunityCreateWithoutDailyRewardsRecordsInput, OpportunityUncheckedCreateWithoutDailyRewardsRecordsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutDailyRewardsRecordsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutDailyRewardsRecordsInput, OpportunityUncheckedUpdateWithoutDailyRewardsRecordsInput>
  }

  export type OpportunityUpdateWithoutDailyRewardsRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutDailyRewardsRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type CampaignCreateWithoutDailyRewardsBreakdownInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutDailyRewardsBreakdownInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutDailyRewardsBreakdownInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDailyRewardsBreakdownInput, CampaignUncheckedCreateWithoutDailyRewardsBreakdownInput>
  }

  export type DailyRewardsRecordCreateWithoutDailyRewardsBreakdownInput = {
    id: string
    timestamp: bigint | number
    total: number
    Opportunity: OpportunityCreateNestedOneWithoutDailyRewardsRecordsInput
  }

  export type DailyRewardsRecordUncheckedCreateWithoutDailyRewardsBreakdownInput = {
    id: string
    timestamp: bigint | number
    total: number
    opportunityId: string
  }

  export type DailyRewardsRecordCreateOrConnectWithoutDailyRewardsBreakdownInput = {
    where: DailyRewardsRecordWhereUniqueInput
    create: XOR<DailyRewardsRecordCreateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedCreateWithoutDailyRewardsBreakdownInput>
  }

  export type CampaignUpsertWithoutDailyRewardsBreakdownInput = {
    update: XOR<CampaignUpdateWithoutDailyRewardsBreakdownInput, CampaignUncheckedUpdateWithoutDailyRewardsBreakdownInput>
    create: XOR<CampaignCreateWithoutDailyRewardsBreakdownInput, CampaignUncheckedCreateWithoutDailyRewardsBreakdownInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutDailyRewardsBreakdownInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutDailyRewardsBreakdownInput, CampaignUncheckedUpdateWithoutDailyRewardsBreakdownInput>
  }

  export type CampaignUpdateWithoutDailyRewardsBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDailyRewardsBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type DailyRewardsRecordUpsertWithoutDailyRewardsBreakdownInput = {
    update: XOR<DailyRewardsRecordUpdateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedUpdateWithoutDailyRewardsBreakdownInput>
    create: XOR<DailyRewardsRecordCreateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedCreateWithoutDailyRewardsBreakdownInput>
    where?: DailyRewardsRecordWhereInput
  }

  export type DailyRewardsRecordUpdateToOneWithWhereWithoutDailyRewardsBreakdownInput = {
    where?: DailyRewardsRecordWhereInput
    data: XOR<DailyRewardsRecordUpdateWithoutDailyRewardsBreakdownInput, DailyRewardsRecordUncheckedUpdateWithoutDailyRewardsBreakdownInput>
  }

  export type DailyRewardsRecordUpdateWithoutDailyRewardsBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    Opportunity?: OpportunityUpdateOneRequiredWithoutDailyRewardsRecordsNestedInput
  }

  export type DailyRewardsRecordUncheckedUpdateWithoutDailyRewardsBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardCreateWithoutUserInput = {
    id: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    MerklRoot: MerklRootCreateNestedOneWithoutRewardsInput
    RewardToken: TokenCreateNestedOneWithoutRewardInput
    Breakdown?: RewardBreakdownCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutUserInput = {
    id: string
    root: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutUserInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardCreateManyUserInputEnvelope = {
    data: RewardCreateManyUserInput | RewardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlacklistCreateWithoutUserInput = {
    id: string
    poolAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
    Chain: ChainCreateNestedOneWithoutBlacklistInput
  }

  export type BlacklistUncheckedCreateWithoutUserInput = {
    id: string
    chainId: number
    poolAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistCreateOrConnectWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    create: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput>
  }

  export type BlacklistCreateManyUserInputEnvelope = {
    data: BlacklistCreateManyUserInput | BlacklistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutCreatorInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreatorInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignCreateManyCreatorInputEnvelope = {
    data: CampaignCreateManyCreatorInput | CampaignCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserComputedValueCreateWithoutUserInput = {
    id?: string
    reason: string
    boost?: number | null
    Campaign: CampaignCreateNestedOneWithoutUserComputedValueInput
  }

  export type UserComputedValueUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    reason: string
    boost?: number | null
  }

  export type UserComputedValueCreateOrConnectWithoutUserInput = {
    where: UserComputedValueWhereUniqueInput
    create: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput>
  }

  export type UserComputedValueCreateManyUserInputEnvelope = {
    data: UserComputedValueCreateManyUserInput | UserComputedValueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CreatorCreateWithoutUsersInput = {
    id: string
    icon?: string | null
    name: string
    rebateFee?: number
  }

  export type CreatorUncheckedCreateWithoutUsersInput = {
    id: string
    icon?: string | null
    name: string
    rebateFee?: number
  }

  export type CreatorCreateOrConnectWithoutUsersInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutUsersInput, CreatorUncheckedCreateWithoutUsersInput>
  }

  export type RewardUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
  }

  export type RewardUpdateManyWithWhereWithoutUserInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutUserInput>
  }

  export type BlacklistUpsertWithWhereUniqueWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    update: XOR<BlacklistUpdateWithoutUserInput, BlacklistUncheckedUpdateWithoutUserInput>
    create: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput>
  }

  export type BlacklistUpdateWithWhereUniqueWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    data: XOR<BlacklistUpdateWithoutUserInput, BlacklistUncheckedUpdateWithoutUserInput>
  }

  export type BlacklistUpdateManyWithWhereWithoutUserInput = {
    where: BlacklistScalarWhereInput
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCreatorInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UserComputedValueUpsertWithWhereUniqueWithoutUserInput = {
    where: UserComputedValueWhereUniqueInput
    update: XOR<UserComputedValueUpdateWithoutUserInput, UserComputedValueUncheckedUpdateWithoutUserInput>
    create: XOR<UserComputedValueCreateWithoutUserInput, UserComputedValueUncheckedCreateWithoutUserInput>
  }

  export type UserComputedValueUpdateWithWhereUniqueWithoutUserInput = {
    where: UserComputedValueWhereUniqueInput
    data: XOR<UserComputedValueUpdateWithoutUserInput, UserComputedValueUncheckedUpdateWithoutUserInput>
  }

  export type UserComputedValueUpdateManyWithWhereWithoutUserInput = {
    where: UserComputedValueScalarWhereInput
    data: XOR<UserComputedValueUpdateManyMutationInput, UserComputedValueUncheckedUpdateManyWithoutUserInput>
  }

  export type CreatorUpsertWithoutUsersInput = {
    update: XOR<CreatorUpdateWithoutUsersInput, CreatorUncheckedUpdateWithoutUsersInput>
    create: XOR<CreatorCreateWithoutUsersInput, CreatorUncheckedCreateWithoutUsersInput>
    where?: CreatorWhereInput
  }

  export type CreatorUpdateToOneWithWhereWithoutUsersInput = {
    where?: CreatorWhereInput
    data: XOR<CreatorUpdateWithoutUsersInput, CreatorUncheckedUpdateWithoutUsersInput>
  }

  export type CreatorUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
  }

  export type CreatorUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rebateFee?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutCreatorInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatorInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type UserCreateManyCreatorInputEnvelope = {
    data: UserCreateManyCreatorInput | UserCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCreatorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    address?: StringFilter<"User"> | string
    tags?: StringNullableListFilter<"User">
    creatorId?: StringNullableFilter<"User"> | string | null
  }

  export type MerklRootCreateWithoutRewardsInput = {
    root: string
    epoch: number
    timestamp: bigint | number
    Chain: ChainCreateNestedOneWithoutMerklRootInput
  }

  export type MerklRootUncheckedCreateWithoutRewardsInput = {
    root: string
    chainId: number
    epoch: number
    timestamp: bigint | number
  }

  export type MerklRootCreateOrConnectWithoutRewardsInput = {
    where: MerklRootWhereUniqueInput
    create: XOR<MerklRootCreateWithoutRewardsInput, MerklRootUncheckedCreateWithoutRewardsInput>
  }

  export type UserCreateWithoutRewardsInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Blacklist?: BlacklistCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutUserInput
    Creator?: CreatorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type TokenCreateWithoutRewardInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateWithoutRewardInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenCreateOrConnectWithoutRewardInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutRewardInput, TokenUncheckedCreateWithoutRewardInput>
  }

  export type RewardBreakdownCreateWithoutRewardInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    Protocol?: ProtocolCreateNestedOneWithoutRewardBreakdownInput
    Campaign: CampaignCreateNestedOneWithoutRewardBreakdownInput
    SubCampaign?: CampaignCreateNestedOneWithoutRewardBreakdownSubCampaignInput
  }

  export type RewardBreakdownUncheckedCreateWithoutRewardInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownCreateOrConnectWithoutRewardInput = {
    where: RewardBreakdownWhereUniqueInput
    create: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput>
  }

  export type RewardBreakdownCreateManyRewardInputEnvelope = {
    data: RewardBreakdownCreateManyRewardInput | RewardBreakdownCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type MerklRootUpsertWithoutRewardsInput = {
    update: XOR<MerklRootUpdateWithoutRewardsInput, MerklRootUncheckedUpdateWithoutRewardsInput>
    create: XOR<MerklRootCreateWithoutRewardsInput, MerklRootUncheckedCreateWithoutRewardsInput>
    where?: MerklRootWhereInput
  }

  export type MerklRootUpdateToOneWithWhereWithoutRewardsInput = {
    where?: MerklRootWhereInput
    data: XOR<MerklRootUpdateWithoutRewardsInput, MerklRootUncheckedUpdateWithoutRewardsInput>
  }

  export type MerklRootUpdateWithoutRewardsInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    Chain?: ChainUpdateOneRequiredWithoutMerklRootNestedInput
  }

  export type MerklRootUncheckedUpdateWithoutRewardsInput = {
    root?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Blacklist?: BlacklistUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutUserNestedInput
    Creator?: CreatorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    Blacklist?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TokenUpsertWithoutRewardInput = {
    update: XOR<TokenUpdateWithoutRewardInput, TokenUncheckedUpdateWithoutRewardInput>
    create: XOR<TokenCreateWithoutRewardInput, TokenUncheckedCreateWithoutRewardInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutRewardInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutRewardInput, TokenUncheckedUpdateWithoutRewardInput>
  }

  export type TokenUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type RewardBreakdownUpsertWithWhereUniqueWithoutRewardInput = {
    where: RewardBreakdownWhereUniqueInput
    update: XOR<RewardBreakdownUpdateWithoutRewardInput, RewardBreakdownUncheckedUpdateWithoutRewardInput>
    create: XOR<RewardBreakdownCreateWithoutRewardInput, RewardBreakdownUncheckedCreateWithoutRewardInput>
  }

  export type RewardBreakdownUpdateWithWhereUniqueWithoutRewardInput = {
    where: RewardBreakdownWhereUniqueInput
    data: XOR<RewardBreakdownUpdateWithoutRewardInput, RewardBreakdownUncheckedUpdateWithoutRewardInput>
  }

  export type RewardBreakdownUpdateManyWithWhereWithoutRewardInput = {
    where: RewardBreakdownScalarWhereInput
    data: XOR<RewardBreakdownUpdateManyMutationInput, RewardBreakdownUncheckedUpdateManyWithoutRewardInput>
  }

  export type ProtocolCreateWithoutRewardBreakdownInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityCreateNestedManyWithoutMainProtocolInput
    Opportunities?: OpportunityCreateNestedManyWithoutProtocolsInput
  }

  export type ProtocolUncheckedCreateWithoutRewardBreakdownInput = {
    id: string
    tags?: ProtocolCreatetagsInput | string[]
    name: string
    description?: string
    url: string
    icon: string
    MainOpportunities?: OpportunityUncheckedCreateNestedManyWithoutMainProtocolInput
    Opportunities?: OpportunityUncheckedCreateNestedManyWithoutProtocolsInput
  }

  export type ProtocolCreateOrConnectWithoutRewardBreakdownInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutRewardBreakdownInput, ProtocolUncheckedCreateWithoutRewardBreakdownInput>
  }

  export type RewardCreateWithoutBreakdownInput = {
    id: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    MerklRoot: MerklRootCreateNestedOneWithoutRewardsInput
    User: UserCreateNestedOneWithoutRewardsInput
    RewardToken: TokenCreateNestedOneWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutBreakdownInput = {
    id: string
    root: string
    recipient: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
  }

  export type RewardCreateOrConnectWithoutBreakdownInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutBreakdownInput, RewardUncheckedCreateWithoutBreakdownInput>
  }

  export type CampaignCreateWithoutRewardBreakdownInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRewardBreakdownInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedCreateNestedManyWithoutSubCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRewardBreakdownInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRewardBreakdownInput, CampaignUncheckedCreateWithoutRewardBreakdownInput>
  }

  export type CampaignCreateWithoutRewardBreakdownSubCampaignInput = {
    id: string
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    ComputeChain: ChainCreateNestedOneWithoutCampaignsInput
    DistributionChain: ChainCreateNestedOneWithoutDistributionInput
    RewardToken: TokenCreateNestedOneWithoutCampaignsInput
    Opportunity: OpportunityCreateNestedOneWithoutCampaignsInput
    RewardBreakdown?: RewardBreakdownCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownCreateNestedManyWithoutCampaignInput
    Creator: UserCreateNestedOneWithoutCampaignsCreatedInput
    CampaignStatus?: CampaignStatusCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutCampaignInput
    rootCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutRootCampaignInput
    parentCampaign?: CampaignCreateNestedOneWithoutChildCampaignsInput
    childCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRewardBreakdownSubCampaignInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
    RewardBreakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedCreateNestedManyWithoutCampaignInput
    CampaignStatus?: CampaignStatusUncheckedCreateNestedManyWithoutCampaignInput
    CampaignEngineValues?: CampaignComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutCampaignInput
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutRootCampaignInput
    childCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRewardBreakdownSubCampaignInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedCreateWithoutRewardBreakdownSubCampaignInput>
  }

  export type ProtocolUpsertWithoutRewardBreakdownInput = {
    update: XOR<ProtocolUpdateWithoutRewardBreakdownInput, ProtocolUncheckedUpdateWithoutRewardBreakdownInput>
    create: XOR<ProtocolCreateWithoutRewardBreakdownInput, ProtocolUncheckedCreateWithoutRewardBreakdownInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutRewardBreakdownInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutRewardBreakdownInput, ProtocolUncheckedUpdateWithoutRewardBreakdownInput>
  }

  export type ProtocolUpdateWithoutRewardBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUpdateManyWithoutMainProtocolNestedInput
    Opportunities?: OpportunityUpdateManyWithoutProtocolsNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutRewardBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUncheckedUpdateManyWithoutMainProtocolNestedInput
    Opportunities?: OpportunityUncheckedUpdateManyWithoutProtocolsNestedInput
  }

  export type RewardUpsertWithoutBreakdownInput = {
    update: XOR<RewardUpdateWithoutBreakdownInput, RewardUncheckedUpdateWithoutBreakdownInput>
    create: XOR<RewardCreateWithoutBreakdownInput, RewardUncheckedCreateWithoutBreakdownInput>
    where?: RewardWhereInput
  }

  export type RewardUpdateToOneWithWhereWithoutBreakdownInput = {
    where?: RewardWhereInput
    data: XOR<RewardUpdateWithoutBreakdownInput, RewardUncheckedUpdateWithoutBreakdownInput>
  }

  export type RewardUpdateWithoutBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    MerklRoot?: MerklRootUpdateOneRequiredWithoutRewardsNestedInput
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }

  export type CampaignUpsertWithoutRewardBreakdownInput = {
    update: XOR<CampaignUpdateWithoutRewardBreakdownInput, CampaignUncheckedUpdateWithoutRewardBreakdownInput>
    create: XOR<CampaignCreateWithoutRewardBreakdownInput, CampaignUncheckedCreateWithoutRewardBreakdownInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRewardBreakdownInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRewardBreakdownInput, CampaignUncheckedUpdateWithoutRewardBreakdownInput>
  }

  export type CampaignUpdateWithoutRewardBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRewardBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUpsertWithoutRewardBreakdownSubCampaignInput = {
    update: XOR<CampaignUpdateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedUpdateWithoutRewardBreakdownSubCampaignInput>
    create: XOR<CampaignCreateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedCreateWithoutRewardBreakdownSubCampaignInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRewardBreakdownSubCampaignInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRewardBreakdownSubCampaignInput, CampaignUncheckedUpdateWithoutRewardBreakdownSubCampaignInput>
  }

  export type CampaignUpdateWithoutRewardBreakdownSubCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRewardBreakdownSubCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
  }

  export type ChainCreateWithoutMerklRootInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutMerklRootInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutMerklRootInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutMerklRootInput, ChainUncheckedCreateWithoutMerklRootInput>
  }

  export type RewardCreateWithoutMerklRootInput = {
    id: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    User: UserCreateNestedOneWithoutRewardsInput
    RewardToken: TokenCreateNestedOneWithoutRewardInput
    Breakdown?: RewardBreakdownCreateNestedManyWithoutRewardInput
  }

  export type RewardUncheckedCreateWithoutMerklRootInput = {
    id: string
    recipient: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardCreateOrConnectWithoutMerklRootInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput>
  }

  export type RewardCreateManyMerklRootInputEnvelope = {
    data: RewardCreateManyMerklRootInput | RewardCreateManyMerklRootInput[]
    skipDuplicates?: boolean
  }

  export type ChainUpsertWithoutMerklRootInput = {
    update: XOR<ChainUpdateWithoutMerklRootInput, ChainUncheckedUpdateWithoutMerklRootInput>
    create: XOR<ChainCreateWithoutMerklRootInput, ChainUncheckedCreateWithoutMerklRootInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutMerklRootInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutMerklRootInput, ChainUncheckedUpdateWithoutMerklRootInput>
  }

  export type ChainUpdateWithoutMerklRootInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutMerklRootInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type RewardUpsertWithWhereUniqueWithoutMerklRootInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutMerklRootInput, RewardUncheckedUpdateWithoutMerklRootInput>
    create: XOR<RewardCreateWithoutMerklRootInput, RewardUncheckedCreateWithoutMerklRootInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutMerklRootInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutMerklRootInput, RewardUncheckedUpdateWithoutMerklRootInput>
  }

  export type RewardUpdateManyWithWhereWithoutMerklRootInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutMerklRootInput>
  }

  export type ChainCreateWithoutBlacklistInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Dump?: DumpCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutBlacklistInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Dump?: DumpUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutBlacklistInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutBlacklistInput, ChainUncheckedCreateWithoutBlacklistInput>
  }

  export type UserCreateWithoutBlacklistInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    Rewards?: RewardCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueCreateNestedManyWithoutUserInput
    Creator?: CreatorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBlacklistInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
    creatorId?: string | null
    Rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    CampaignsCreated?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    UserComputedValue?: UserComputedValueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlacklistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlacklistInput, UserUncheckedCreateWithoutBlacklistInput>
  }

  export type ChainUpsertWithoutBlacklistInput = {
    update: XOR<ChainUpdateWithoutBlacklistInput, ChainUncheckedUpdateWithoutBlacklistInput>
    create: XOR<ChainCreateWithoutBlacklistInput, ChainUncheckedCreateWithoutBlacklistInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutBlacklistInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutBlacklistInput, ChainUncheckedUpdateWithoutBlacklistInput>
  }

  export type ChainUpdateWithoutBlacklistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Dump?: DumpUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutBlacklistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Dump?: DumpUncheckedUpdateManyWithoutChainNestedInput
  }

  export type UserUpsertWithoutBlacklistInput = {
    update: XOR<UserUpdateWithoutBlacklistInput, UserUncheckedUpdateWithoutBlacklistInput>
    create: XOR<UserCreateWithoutBlacklistInput, UserUncheckedCreateWithoutBlacklistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlacklistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlacklistInput, UserUncheckedUpdateWithoutBlacklistInput>
  }

  export type UserUpdateWithoutBlacklistInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutUserNestedInput
    Creator?: CreatorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlacklistInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    Rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChainCreateWithoutDumpInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerCreateNestedManyWithoutChainInput
    Campaigns?: CampaignCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignCreateNestedManyWithoutDistributionChainInput
    Token?: TokenCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistCreateNestedManyWithoutChainInput
  }

  export type ChainUncheckedCreateWithoutDumpInput = {
    id: number
    name: string
    icon: string
    Explorer?: ExplorerUncheckedCreateNestedManyWithoutChainInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutComputeChainInput
    Distribution?: CampaignUncheckedCreateNestedManyWithoutDistributionChainInput
    Token?: TokenUncheckedCreateNestedManyWithoutChainInput
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutChainInput
    MerklRoot?: MerklRootUncheckedCreateNestedManyWithoutChainInput
    Blacklist?: BlacklistUncheckedCreateNestedManyWithoutChainInput
  }

  export type ChainCreateOrConnectWithoutDumpInput = {
    where: ChainWhereUniqueInput
    create: XOR<ChainCreateWithoutDumpInput, ChainUncheckedCreateWithoutDumpInput>
  }

  export type TokenCreateWithoutDumpFromInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpCreateNestedManyWithoutToTokenInput
  }

  export type TokenUncheckedCreateWithoutDumpFromInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpTo?: DumpUncheckedCreateNestedManyWithoutToTokenInput
  }

  export type TokenCreateOrConnectWithoutDumpFromInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDumpFromInput, TokenUncheckedCreateWithoutDumpFromInput>
  }

  export type TokenCreateWithoutDumpToInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Chain: ChainCreateNestedOneWithoutTokenInput
    Opportunity?: OpportunityCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardCreateNestedManyWithoutRewardTokenInput
    DumpFrom?: DumpCreateNestedManyWithoutFromTokenInput
  }

  export type TokenUncheckedCreateWithoutDumpToInput = {
    id: string
    name?: string | null
    chainId: number
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
    Opportunity?: OpportunityUncheckedCreateNestedManyWithoutTokensInput
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutRewardTokenInput
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardTokenInput
    DumpFrom?: DumpUncheckedCreateNestedManyWithoutFromTokenInput
  }

  export type TokenCreateOrConnectWithoutDumpToInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDumpToInput, TokenUncheckedCreateWithoutDumpToInput>
  }

  export type ChainUpsertWithoutDumpInput = {
    update: XOR<ChainUpdateWithoutDumpInput, ChainUncheckedUpdateWithoutDumpInput>
    create: XOR<ChainCreateWithoutDumpInput, ChainUncheckedCreateWithoutDumpInput>
    where?: ChainWhereInput
  }

  export type ChainUpdateToOneWithWhereWithoutDumpInput = {
    where?: ChainWhereInput
    data: XOR<ChainUpdateWithoutDumpInput, ChainUncheckedUpdateWithoutDumpInput>
  }

  export type ChainUpdateWithoutDumpInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUpdateManyWithoutChainNestedInput
  }

  export type ChainUncheckedUpdateWithoutDumpInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    Explorer?: ExplorerUncheckedUpdateManyWithoutChainNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutComputeChainNestedInput
    Distribution?: CampaignUncheckedUpdateManyWithoutDistributionChainNestedInput
    Token?: TokenUncheckedUpdateManyWithoutChainNestedInput
    Opportunity?: OpportunityUncheckedUpdateManyWithoutChainNestedInput
    MerklRoot?: MerklRootUncheckedUpdateManyWithoutChainNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutChainNestedInput
  }

  export type TokenUpsertWithoutDumpFromInput = {
    update: XOR<TokenUpdateWithoutDumpFromInput, TokenUncheckedUpdateWithoutDumpFromInput>
    create: XOR<TokenCreateWithoutDumpFromInput, TokenUncheckedCreateWithoutDumpFromInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDumpFromInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDumpFromInput, TokenUncheckedUpdateWithoutDumpFromInput>
  }

  export type TokenUpdateWithoutDumpFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDumpFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
  }

  export type TokenUpsertWithoutDumpToInput = {
    update: XOR<TokenUpdateWithoutDumpToInput, TokenUncheckedUpdateWithoutDumpToInput>
    create: XOR<TokenCreateWithoutDumpToInput, TokenUncheckedCreateWithoutDumpToInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDumpToInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDumpToInput, TokenUncheckedUpdateWithoutDumpToInput>
  }

  export type TokenUpdateWithoutDumpToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDumpToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type RewardBreakdownCreateManyCampaignInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    subCampaignId?: string | null
  }

  export type DailyRewardsBreakdownCreateManyCampaignInput = {
    id?: string
    value: number
    dailyRewardsRecordId: string
  }

  export type CampaignStatusCreateManyCampaignInput = {
    computedUntil: bigint | number
    processingStarted: bigint | number
    status?: $Enums.RunStatus
    error?: string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignComputedValueCreateManyCampaignInput = {
    averageBoost?: number | null
    totalDistributedInUSD?: number | null
    forfeitingBoost?: number | null
  }

  export type UserComputedValueCreateManyCampaignInput = {
    id?: string
    address: string
    reason: string
    boost?: number | null
  }

  export type CampaignCreateManyRootCampaignInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    parentCampaignId?: string | null
  }

  export type CampaignCreateManyParentCampaignInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
  }

  export type RewardBreakdownCreateManySubCampaignInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
  }

  export type RewardBreakdownUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    Protocol?: ProtocolUpdateOneWithoutRewardBreakdownNestedInput
    Reward?: RewardUpdateOneRequiredWithoutBreakdownNestedInput
    SubCampaign?: CampaignUpdateOneWithoutRewardBreakdownSubCampaignNestedInput
  }

  export type RewardBreakdownUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRewardsBreakdownUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    DailyRewardsRecord?: DailyRewardsRecordUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput
  }

  export type DailyRewardsBreakdownUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dailyRewardsRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dailyRewardsRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignStatusUpdateWithoutCampaignInput = {
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUncheckedUpdateWithoutCampaignInput = {
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignStatusUncheckedUpdateManyWithoutCampaignInput = {
    computedUntil?: BigIntFieldUpdateOperationsInput | bigint | number
    processingStarted?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRunStatusFieldUpdateOperationsInput | $Enums.RunStatus
    error?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignComputedValueUpdateWithoutCampaignInput = {
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignComputedValueUncheckedUpdateWithoutCampaignInput = {
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignComputedValueUncheckedUpdateManyWithoutCampaignInput = {
    averageBoost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDistributedInUSD?: NullableFloatFieldUpdateOperationsInput | number | null
    forfeitingBoost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutUserComputedValueNestedInput
  }

  export type UserComputedValueUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignUpdateWithoutRootCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRootCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutRootCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardBreakdownUpdateWithoutSubCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    Protocol?: ProtocolUpdateOneWithoutRewardBreakdownNestedInput
    Reward?: RewardUpdateOneRequiredWithoutBreakdownNestedInput
    Campaign?: CampaignUpdateOneRequiredWithoutRewardBreakdownNestedInput
  }

  export type RewardBreakdownUncheckedUpdateWithoutSubCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutSubCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ExplorerCreateManyChainInput = {
    id: string
    type: $Enums.ExplorerType
    url: string
  }

  export type CampaignCreateManyComputeChainInput = {
    id: string
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type CampaignCreateManyDistributionChainInput = {
    id: string
    computeChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type TokenCreateManyChainInput = {
    id: string
    name?: string | null
    address: string
    decimals: number
    symbol: string
    displaySymbol?: string
    icon: string
    verified?: boolean
    isTest?: boolean
    isPoint?: boolean
    isPreTGE?: boolean
    isNative?: boolean
    price?: number | null
  }

  export type OpportunityCreateManyChainInput = {
    id: string
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    mainProtocolId?: string | null
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type MerklRootCreateManyChainInput = {
    root: string
    epoch: number
    timestamp: bigint | number
  }

  export type BlacklistCreateManyChainInput = {
    id: string
    poolAddress: string
    userAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type DumpCreateManyChainInput = {
    id: string
    fromTokenId: string
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type ExplorerUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ExplorerUncheckedUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ExplorerUncheckedUpdateManyWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExplorerTypeFieldUpdateOperationsInput | $Enums.ExplorerType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignUpdateWithoutComputeChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutComputeChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutComputeChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutDistributionChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDistributionChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutDistributionChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Opportunity?: OpportunityUncheckedUpdateManyWithoutTokensNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateManyWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OpportunityUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type MerklRootUpdateWithoutChainInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    Rewards?: RewardUpdateManyWithoutMerklRootNestedInput
  }

  export type MerklRootUncheckedUpdateWithoutChainInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    Rewards?: RewardUncheckedUpdateManyWithoutMerklRootNestedInput
  }

  export type MerklRootUncheckedUpdateManyWithoutChainInput = {
    root?: StringFieldUpdateOperationsInput | string
    epoch?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BlacklistUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
    User?: UserUpdateOneRequiredWithoutBlacklistNestedInput
  }

  export type BlacklistUncheckedUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistUncheckedUpdateManyWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type DumpUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
    FromToken?: TokenUpdateOneRequiredWithoutDumpFromNestedInput
    ToToken?: TokenUpdateOneRequiredWithoutDumpToNestedInput
  }

  export type DumpUncheckedUpdateWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTokenId?: StringFieldUpdateOperationsInput | string
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpUncheckedUpdateManyWithoutChainInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTokenId?: StringFieldUpdateOperationsInput | string
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignCreateManyOpportunityInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type TVLRecordCreateManyOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
  }

  export type AprRecordCreateManyOpportunityInput = {
    id: string
    timestamp: bigint | number
    cumulated: number
  }

  export type DailyRewardsRecordCreateManyOpportunityInput = {
    id: string
    timestamp: bigint | number
    total: number
  }

  export type TokenUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Chain?: ChainUpdateOneRequiredWithoutTokenNestedInput
    Campaigns?: CampaignUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    Campaigns?: CampaignUncheckedUpdateManyWithoutRewardTokenNestedInput
    Reward?: RewardUncheckedUpdateManyWithoutRewardTokenNestedInput
    DumpTo?: DumpUncheckedUpdateManyWithoutToTokenNestedInput
    DumpFrom?: DumpUncheckedUpdateManyWithoutFromTokenNestedInput
  }

  export type TokenUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    displaySymbol?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    isPoint?: BoolFieldUpdateOperationsInput | boolean
    isPreTGE?: BoolFieldUpdateOperationsInput | boolean
    isNative?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProtocolUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUpdateManyWithoutMainProtocolNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    MainOpportunities?: OpportunityUncheckedUpdateManyWithoutMainProtocolNestedInput
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateManyWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: ProtocolUpdatetagsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type TVLRecordUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    TvlBreakdown?: TVLBreakdownUpdateManyWithoutTvlRecordNestedInput
  }

  export type TVLRecordUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    TvlBreakdown?: TVLBreakdownUncheckedUpdateManyWithoutTvlRecordNestedInput
  }

  export type TVLRecordUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type AprRecordUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    AprBreakdown?: AprBreakdownUpdateManyWithoutAprRecordNestedInput
  }

  export type AprRecordUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
    AprBreakdown?: AprBreakdownUncheckedUpdateManyWithoutAprRecordNestedInput
  }

  export type AprRecordUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    cumulated?: FloatFieldUpdateOperationsInput | number
  }

  export type DailyRewardsRecordUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutDailyRewardsRecordNestedInput
  }

  export type DailyRewardsRecordUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutDailyRewardsRecordNestedInput
  }

  export type DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type OpportunityCreateManyMainProtocolInput = {
    id: string
    chainId: number
    type: string
    identifier: string
    name: string
    description?: string
    howToSteps?: OpportunityCreatehowToStepsInput | string[]
    depositUrl?: string | null
    explorerAddress?: string | null
    status: $Enums.Status
    action: $Enums.OpportunityAction
    tvl?: number
    apr?: number
    dailyRewards?: number
    tags?: OpportunityCreatetagsInput | string[]
    lastCampaignCreatedAt?: Date | string
    manualOverrides?: OpportunityCreatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type RewardBreakdownCreateManyProtocolInput = {
    id?: string
    reason: string
    amount: string
    claimed: string
    pending: string
    rewardId: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type OpportunityUpdateWithoutMainProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutMainProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutMainProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type OpportunityUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Tokens?: TokenUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Tokens?: TokenUncheckedUpdateManyWithoutOpportunityNestedInput
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type RewardBreakdownUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    Reward?: RewardUpdateOneRequiredWithoutBreakdownNestedInput
    Campaign?: CampaignUpdateOneRequiredWithoutRewardBreakdownNestedInput
    SubCampaign?: CampaignUpdateOneWithoutRewardBreakdownSubCampaignNestedInput
  }

  export type RewardBreakdownUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateManyRewardTokenInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    creatorAddress: string
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type RewardCreateManyRewardTokenInput = {
    id: string
    root: string
    recipient: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
  }

  export type DumpCreateManyToTokenInput = {
    id: string
    chainId: number
    fromTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type DumpCreateManyFromTokenInput = {
    id: string
    chainId: number
    toTokenId: string
    multisig: string
    recipient: string
    amountIn?: string
    amountOut?: string
    datetime: Date | string
    timestamp: number
  }

  export type OpportunityUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Chain?: ChainUpdateOneRequiredWithoutOpportunityNestedInput
    Campaigns?: CampaignUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUpdateManyWithoutOpportunitiesNestedInput
    MainProtocol?: ProtocolUpdateOneWithoutMainOpportunitiesNestedInput
    TvlRecords?: TVLRecordUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
    Campaigns?: CampaignUncheckedUpdateManyWithoutOpportunityNestedInput
    Protocols?: ProtocolUncheckedUpdateManyWithoutOpportunitiesNestedInput
    TvlRecords?: TVLRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    AprRecords?: AprRecordUncheckedUpdateManyWithoutOpportunityNestedInput
    DailyRewardsRecords?: DailyRewardsRecordUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    howToSteps?: OpportunityUpdatehowToStepsInput | string[]
    depositUrl?: NullableStringFieldUpdateOperationsInput | string | null
    explorerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumOpportunityActionFieldUpdateOperationsInput | $Enums.OpportunityAction
    mainProtocolId?: NullableStringFieldUpdateOperationsInput | string | null
    tvl?: FloatFieldUpdateOperationsInput | number
    apr?: FloatFieldUpdateOperationsInput | number
    dailyRewards?: FloatFieldUpdateOperationsInput | number
    tags?: OpportunityUpdatetagsInput | string[]
    lastCampaignCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrides?: OpportunityUpdatemanualOverridesInput | $Enums.OpportunityManualOverride[]
  }

  export type CampaignUpdateWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    Creator?: UserUpdateOneRequiredWithoutCampaignsCreatedNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorAddress?: StringFieldUpdateOperationsInput | string
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardUpdateWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    MerklRoot?: MerklRootUpdateOneRequiredWithoutRewardsNestedInput
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    Breakdown?: RewardBreakdownUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateManyWithoutRewardTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }

  export type DumpUpdateWithoutToTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
    Chain?: ChainUpdateOneRequiredWithoutDumpNestedInput
    FromToken?: TokenUpdateOneRequiredWithoutDumpFromNestedInput
  }

  export type DumpUncheckedUpdateWithoutToTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    fromTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpUncheckedUpdateManyWithoutToTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    fromTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpUpdateWithoutFromTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
    Chain?: ChainUpdateOneRequiredWithoutDumpNestedInput
    ToToken?: TokenUpdateOneRequiredWithoutDumpToNestedInput
  }

  export type DumpUncheckedUpdateWithoutFromTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type DumpUncheckedUpdateManyWithoutFromTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    toTokenId?: StringFieldUpdateOperationsInput | string
    multisig?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    amountIn?: StringFieldUpdateOperationsInput | string
    amountOut?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type AprBreakdownCreateManyAprRecordInput = {
    id?: string
    identifier: string
    type: $Enums.AprType
    value: number
  }

  export type AprBreakdownUpdateWithoutAprRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type AprBreakdownUncheckedUpdateWithoutAprRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type AprBreakdownUncheckedUpdateManyWithoutAprRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumAprTypeFieldUpdateOperationsInput | $Enums.AprType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type TVLBreakdownCreateManyTvlRecordInput = {
    id?: string
    identifier: string
    type: $Enums.TvlType
    value: number
  }

  export type TVLBreakdownUpdateWithoutTvlRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type TVLBreakdownUncheckedUpdateWithoutTvlRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type TVLBreakdownUncheckedUpdateManyWithoutTvlRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: EnumTvlTypeFieldUpdateOperationsInput | $Enums.TvlType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type DailyRewardsBreakdownCreateManyDailyRewardsRecordInput = {
    id?: string
    value: number
    campaignId: string
  }

  export type DailyRewardsBreakdownUpdateWithoutDailyRewardsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    Campaign?: CampaignUpdateOneRequiredWithoutDailyRewardsBreakdownNestedInput
  }

  export type DailyRewardsBreakdownUncheckedUpdateWithoutDailyRewardsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardsBreakdownUncheckedUpdateManyWithoutDailyRewardsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardCreateManyUserInput = {
    id: string
    root: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
  }

  export type BlacklistCreateManyUserInput = {
    id: string
    chainId: number
    poolAddress: string
    arrestTimestamp: bigint | number
    arrestDetails: JsonNullValueInput | InputJsonValue
  }

  export type CampaignCreateManyCreatorInput = {
    id: string
    computeChainId: number
    distributionChainId: number
    campaignId: string
    type: string
    distributionType?: $Enums.DistributionType
    subType?: number | null
    rewardTokenId: string
    amount: string
    opportunityId: string
    startTimestamp: bigint | number
    endTimestamp: bigint | number
    params: JsonNullValueInput | InputJsonValue
    description?: string | null
    manualOverrides?: CampaignCreatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: Date | string
    rootCampaignId?: string | null
    parentCampaignId?: string | null
  }

  export type UserComputedValueCreateManyUserInput = {
    id?: string
    campaignId: string
    reason: string
    boost?: number | null
  }

  export type RewardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    MerklRoot?: MerklRootUpdateOneRequiredWithoutRewardsNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutRewardNestedInput
    Breakdown?: RewardBreakdownUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    root?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }

  export type BlacklistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
    Chain?: ChainUpdateOneRequiredWithoutBlacklistNestedInput
  }

  export type BlacklistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type BlacklistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    poolAddress?: StringFieldUpdateOperationsInput | string
    arrestTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    arrestDetails?: JsonNullValueInput | InputJsonValue
  }

  export type CampaignUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ComputeChain?: ChainUpdateOneRequiredWithoutCampaignsNestedInput
    DistributionChain?: ChainUpdateOneRequiredWithoutDistributionNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutCampaignsNestedInput
    Opportunity?: OpportunityUpdateOneRequiredWithoutCampaignsNestedInput
    RewardBreakdown?: RewardBreakdownUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutCampaignNestedInput
    rootCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutRootCampaignNestedInput
    parentCampaign?: CampaignUpdateOneWithoutChildCampaignsNestedInput
    childCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    RewardBreakdown?: RewardBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    DailyRewardsBreakdown?: DailyRewardsBreakdownUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignStatus?: CampaignStatusUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignEngineValues?: CampaignComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutCampaignNestedInput
    subCampaigns?: CampaignUncheckedUpdateManyWithoutRootCampaignNestedInput
    childCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    RewardBreakdownSubCampaign?: RewardBreakdownUncheckedUpdateManyWithoutSubCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    computeChainId?: IntFieldUpdateOperationsInput | number
    distributionChainId?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    distributionType?: EnumDistributionTypeFieldUpdateOperationsInput | $Enums.DistributionType
    subType?: NullableIntFieldUpdateOperationsInput | number | null
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    startTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    endTimestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    params?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: CampaignUpdatemanualOverridesInput | $Enums.CampaignManualOverride[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserComputedValueUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
    Campaign?: CampaignUpdateOneRequiredWithoutUserComputedValueNestedInput
  }

  export type UserComputedValueUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserComputedValueUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    boost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyCreatorInput = {
    address: string
    tags?: UserCreatetagsInput | string[]
  }

  export type UserUpdateWithoutCreatorInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
    Rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    Blacklist?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    CampaignsCreated?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    UserComputedValue?: UserComputedValueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatorInput = {
    address?: StringFieldUpdateOperationsInput | string
    tags?: UserUpdatetagsInput | string[]
  }

  export type RewardBreakdownCreateManyRewardInput = {
    id?: string
    protocolId?: string | null
    reason: string
    amount: string
    claimed: string
    pending: string
    campaignId: string
    subCampaignId?: string | null
  }

  export type RewardBreakdownUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    Protocol?: ProtocolUpdateOneWithoutRewardBreakdownNestedInput
    Campaign?: CampaignUpdateOneRequiredWithoutRewardBreakdownNestedInput
    SubCampaign?: CampaignUpdateOneWithoutRewardBreakdownSubCampaignNestedInput
  }

  export type RewardBreakdownUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardBreakdownUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    subCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardCreateManyMerklRootInput = {
    id: string
    recipient: string
    rewardTokenId: string
    amount?: string
    claimed?: string
    pending?: string
    proofs?: RewardCreateproofsInput | string[]
  }

  export type RewardUpdateWithoutMerklRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    RewardToken?: TokenUpdateOneRequiredWithoutRewardNestedInput
    Breakdown?: RewardBreakdownUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateWithoutMerklRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
    Breakdown?: RewardBreakdownUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardUncheckedUpdateManyWithoutMerklRootInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    rewardTokenId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    claimed?: StringFieldUpdateOperationsInput | string
    pending?: StringFieldUpdateOperationsInput | string
    proofs?: RewardUpdateproofsInput | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}